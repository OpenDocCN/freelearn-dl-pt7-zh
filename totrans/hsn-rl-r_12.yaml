- en: MAB for Financial Engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Today, **machine learning** (**ML**) has taken on a fundamental role in many
    environments of the financial ecosystem: from the approval of loans and the management
    of activities, to the assessment of risks. **Artificial intelligence** (**AI**)
    systems have great importance in the management of equity portfolios and in the
    creation of algorithms for trading. Again, AI is increasingly important for fraud
    detection, and the search for and identification of fraudulent practices. Algorithms
    that are capable of learning and calibrating how they act to new threats are overcoming
    the limits of traditional processes that are based on rigid checklists. In this
    chapter, we will address some of the financial engineering problems with **reinforcement
    learning** (**RL**) to learn about optimization and anomaly identification techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have learned about the fundamental concepts
    of finance problems and how to model credit risk using Markov chains. We will
    also understand how to build a pricing optimization system to find the best price
    to launch a new product. Finally, we will learn how to optimize equity portfolios.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Finance problem essentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling credit risks as Markov chains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pricing optimization system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing equity portfolios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fraud detection techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/34ee91x](http://bit.ly/34ee91x)'
  prefs: []
  type: TYPE_NORMAL
- en: Finance problem essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technological innovation and the financial sphere have been proceeding hand
    in hand for several years, further accelerating with the entry of machine learning into
    the field. The high volumes of data, the possibility of accessing accurate historical
    documentation, and the quantitative nature of the financial sphere makes it one
    of the most suitable industries in which to integrate automatic learning. In this
    way, the operators of the sector are freed from a series of necessary activities
    that are of little creative value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Machine learning allows machines to make autonomous decisions: instead of a
    series of instructions for carrying out an activity, instructions are provided
    on how to learn to perform these activities independently. This capacity for self-learning,
    combined with the analysis of big data and special algorithms, has taken on a
    fundamental role in various financial operations, from risk assessment to loan
    approval.'
  prefs: []
  type: TYPE_NORMAL
- en: Through machine learning, a financial company can innovate its work activities
    and increase efficiency, output, and, ultimately, profitability. Understanding
    the technological evolution that's undertaken by these companies reveals numerous
    opportunities, but also the need to recognize change and welcome and manage it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the complex set of financial activities, it is difficult to hypothesize
    an area in which machine learning cannot intervene to speed up, simplify, and
    streamline procedures, and it is no coincidence that it is precisely in this context
    that there is a profound reflection on the role that human employees will have
    in the near future. But there is no need to worry: from the perspective of continuous
    growth, financial organizations will limit themselves to directing their staff
    toward high value-added activities, where artificial agents will be important
    consultants but cannot have a decision-making role.'
  prefs: []
  type: TYPE_NORMAL
- en: Finance has always been rich in terms of numbers, but in recent decades, it
    has grown in complexity. The digital revolution first and then that of communications
    has made the availability of data of all kinds grow exponentially. Interactions
    on social networks, queries on search engines, banking transactions, and e-commerce
    activities add to the immense catalog of digitized information that can be automatically
    analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: A new demand for data management services is born from recommendation systems
    for the contents of e-commerce sites because of the need to know and to stabilize
    increasingly complex credit systems. For finance, the pressure of competition
    in almost perfect markets leads to continuous improvement. We are witnessing a
    constant tension between agents trying to break the equilibrium, aspiring to new
    forms of profit, and agents pushing toward equilibrium points to realize small,
    systematic profits.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the financial sphere, there are many fields in which artificial agents can
    be useful to simplify activities, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de1defae-4c6e-412c-9a6c-775c81885ecb.png)'
  prefs: []
  type: TYPE_IMG
- en: In the upcoming sections, we will analyze the most widespread activities that
    use algorithms based on machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: Financial trading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Financial trading is a high-yield speculative investment activity that involves
    the financial market. The financial market is defined as a place where financial
    assets are traded. Trading on financial markets is based on a set of factors:
    technical analysis, micro and macroeconomic fundamentals, news, and market sentiment.
    When we talk about high-frequency trading, where the positions are maintained
    even for fractions of a second, the management that''s done by advanced algorithms
    is fundamental. The introduction of machine learning is responsible for a strong
    refinement of techniques and can be used for strategic processing based on various
    indicators, to identify arbitration opportunities and evaluate performance, learn
    the critical issues, and apply an improved model to the upcoming trading opportunities.'
  prefs: []
  type: TYPE_NORMAL
- en: Credit scoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The credit assessment process is a pillar of the business of commercial banks
    and has been refined over the years with new methodologies and access to ever
    larger datasets. Within this activity, which is often referred to as **credit
    scoring**, machine learning can make the difference and it is no coincidence that
    many institutions are already active on the front. Here too, machine learning
    is given a role in extending the procedures in place: in addition to all of the
    consolidated parameters, which continue to be the basis of credit scoring, machine
    learning can complete the evaluation process by examining extremely heterogeneous
    data such as behavior on social networks.'
  prefs: []
  type: TYPE_NORMAL
- en: Financial chatbot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among the first ever uses of machine learning in the banking sector, is virtual
    assistance. Speaking of cost reduction, entrusting a large part of customer care
    activities to a bot supported by machine learning is extremely efficient. Also,
    this rule is applied according to which routine requests (counterclaim, transfer,
    and withdrawal) are both the most common and the most easily assigned to software.
    It is no coincidence that the Bank of America introduced its Erica bot in 2016
    to simplify the management of personal finance to its tens of millions of customers.
  prefs: []
  type: TYPE_NORMAL
- en: Robo-advisor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An example of a virtual assistant is the robo-advisor, who compared to the simple
    automation of routine operations, belongs to the world of financial consulting.
    Through the robo-advisor, it is possible to receive personalized asset management
    advice based on our objectives and, possibly, to buy or sell financial products.
    The same robo-advisor can then follow the investment trend by offering the client
    periodic reports and proposing any corrective measures.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will use Markov chains to model a company's credit risk.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling credit risks as Markov chains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A financial company is exposed to different types of risk, which are generally
    divided into three main groups: market risk, credit risk, and operational risk.
    In the international financial landscape of recent years, credit scoring has acquired
    a crucial role in what is defined as the **credit risk analysis** process. The
    goal of **credit scoring** models is to be able to correctly classify who applies
    for access to a credit channel to reduce the risk related to the possible insolvency
    of the applicant. Following the global crisis that broke out in the United States
    due to the delinquencies on sub-prime mortgages, financial and credit institutions
    have had to face major losses over the last decade, followed by a long period
    of recession. All of this inevitably brought the entire credit risk analysis process
    under the magnifying glass, with emphasis on credit scoring techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: Credit scoring has undergone significant growth in recent decades. Before these
    developments, loans were granted following mostly subjective assessments, based
    on the personal relationships that were created between the applicant and the
    credit institution's credit analyst. In most cases, the latter was represented
    precisely by the bank to which funding was requested. However, the ever-growing
    requests for financing and the multitude of financial products available have
    made it necessary to adapt the credit management system. Increasingly, we have
    tried to apply automatic and objective techniques that allow the analysis of the
    potential customer in a faster and more efficient way. The output of these techniques
    involves the adoption of a **score** that can reliably classify the customer's
    creditworthiness.
  prefs: []
  type: TYPE_NORMAL
- en: A correct assessment of credit risk is essential to be able to achieve successful
    management in all of the activities of a bank. The need to increase the accuracy
    of risk assessment by financial intermediaries has led to the development, updating,
    and discovery of new models and techniques for calculating the probability of
    default and expected recovery rates. A precise analysis on the evolution of the
    creditworthiness of the debtor, and a correct estimate of the parameters that
    influence the credit risk, are also indispensable to solve the problems related
    to the pricing of loans and bonds. Among the various models and tried-and-tested
    approaches, there are the more modern ones that exploit the new technological
    capabilities of data storage, analysis, and training to statistical theory in
    order to identify credit risk components more accurately.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will deal with modeling credit scoring using some packages
    already available in R.
  prefs: []
  type: TYPE_NORMAL
- en: The CreditMetrics package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To address credit scoring techniques, we will use the `CreditMetrics` package
    that's available on CRAN. This package contains a set of functions for computing
    the `CreditMetrics` risk model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table gives some information about this package:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Package | `CreditMetrics` |'
  prefs: []
  type: TYPE_TB
- en: '| Date | 2015-02-19 |'
  prefs: []
  type: TYPE_TB
- en: '| Version | 0.0-2 |'
  prefs: []
  type: TYPE_TB
- en: '| Title | Functions for calculating the `CreditMetrics` risk model |'
  prefs: []
  type: TYPE_TB
- en: '| Author | Andreas Wittmann |'
  prefs: []
  type: TYPE_TB
- en: The `CreditMetrics` model was proposed for the first time by J.P. Morgan as
    a tool for calculating the **Value At Risk** (**VAR**) related to credit exposures.
    This model is one of the most widespread credit risk management systems. It aims
    to define a composition of the loan portfolio so that it's consistent with the
    expected risk-return combination desired by the intermediary, and therefore with
    a more efficient allocation of capital. The credit risk value, in particular,
    varies with the quality associated with the receivables present in the portfolio,
    generating movements of the single credits (migrations) among the three main classes
    identified (the financial distress, the upgrading or improvement of the credit
    rating, and the downgrading or deterioration of the quality associated with the
    individual loan). The credit risk differs substantially from the market risk (`riskmetrics`)
    because, for the latter, it is possible to assume a normal probability distribution
    that is symmetrical with respect to its average value, while what's relative to
    portfolios that are exposed to the risk of credit is positively asymmetric. In
    the next section, we will discuss a practical case of credit risk modeling using
    the `CreditMetrics` package.
  prefs: []
  type: TYPE_NORMAL
- en: The CreditMetrics risk model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Credit risk is the risk that an unexpected event, related to the repayment capacity
    or creditworthiness of a counterparty, will change the value of the credit position.
  prefs: []
  type: TYPE_NORMAL
- en: In assessing credit risk, we can distinguish between the default mode approach,
    which only considers the occurrence of insolvency, and a multi-state approach,
    in which even the deterioration of the counterpart's creditworthiness represents
    a source of credit risk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first approach envisages two possible states for a credit position: default
    or non-default. The occurrence of the default event is determined exclusively
    by the default probability of the associated binary variable. The multi-state
    approach considers the migration risk, which is the risk that the value of a position
    will change due to a deterioration in the creditworthiness of the counterparty.
    The default status represents one of the possible states and the migration in
    this state coincides with the insolvency event.'
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental tool on which the multi-state approach is based is the transition
    matrix, which can be estimated based on historical observations and is provided
    by rating agencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin our analysis by defining the migration matrix, which, as we anticipated,
    is provided by rating agencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we will import the `CreditMetrics` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s reproduce the experiment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command sets the seed of R's random number generator. You must use this
    function every time you want to get a reproducible random result. When we use
    this command, the random numbers that are generated will always be the same, so
    with each execution of the code, the results that are obtained will always be
    the same. Each seed value will correspond to a sequence of values that are generated
    for a given random number generator.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's define the migration matrix, which represents the transition matrix
    of a Markov process. Rating agencies, such as `Standard% Poor`, provide transition
    matrices based on historical data related to over 20 years of observations on
    companies in different sectors.
  prefs: []
  type: TYPE_NORMAL
- en: There are seven rating categories, from the highest AAA class to the lowest
    CCC class. The last state is the default, which is characterized by being an absorbent
    state in which the probability of exit is null.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we define the rating classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After doing this, we define the transition matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following matrix is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this table, the ratings in the first column are the starting or current
    ratings. The ratings in the first row are the ratings at the risk horizon. Furthermore,
    each row of the matrix sums to 100%. The meaning of the transition matrix is now
    clear. This is a square matrix containing the probabilities of the transition
    matrix. For example, there is an 8.33% chance that an AAA rated credit will downgrade
    to an AA rating within one year. In this way, we can recover the credit rating
    that''s going to be the most likely to occur in any year as the current one. As
    a rule, the transition matrix should be calculated for the same time interval
    as the risk horizon over which we are estimating the risk. In our case, we are
    satisfied with the values provided:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we can create the `markovchain` object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `markovchain` class has been designed to handle homogeneous Markov chain
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following slots are passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`transitionMatrix`: This is the square transition matrix containing the probabilities
    of the transition matrix.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`states`: This is the name of the states. It must be of the same `colnames`
    and `rownames` as the transition matrix—this is a character vector, listing the
    states for which transition probabilities are defined.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byrow`: This is a binary flag—a logical element indicating whether transition
    probabilities are shown by row or by column.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This is an optional character element to name the discrete time Markov
    chains.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To show a summary of the model we''ve just created, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following results are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, four slots are listed—`states`, `byrow`, `transitionMatrix`,
    and `name`. To retrieve the elements contained in each one, use the name of the
    object (`MarkovChainModel`), followed by the name of the slot, separated by the `@` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to print the states, we will write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following results are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Other information that we can extract from the newly developed model is the
    transition probability that represents the probability of passing from one state
    to another. Recall that a Markov chain is said to be homogeneous in time if the
    probabilities of transition from one state to another are independent of the time
    index. To obtain this information, we will use the `transitionProbability()` function,
    which allows us to get the transition probabilities from initial to subsequent
    states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s learn how to get this information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following result is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can confirm this result by analyzing the transition matrix. In that matrix,
    the transition from the AAA state to the AA state is given by the element p[12],
    which is just equal to 0.083.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's calculate the credit spread for the migration matrix. The credit
    spread indicates a series of measures that are used to determine how much an investor
    is paid to compensate for the assumption of the intrinsic credit risk in the security.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the credit spread, we will use the `cm.cs()` function, which requires
    a migration matrix and the loss given default as input. The loss given default
    represents the loss that the credit institution suffers due to the insolvency
    of the counterparty when it becomes effective. Therefore, it is never predictable
    a priori; it only occurs when the credit recovery operation ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we will set this value as an initial variable, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code indicates that, in the case of insolvency, the loss of the
    bank will be 40%. Now, we can apply the `cm.cs()` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns the credit spread for time *t = 1* of each rating in
    the migration matrix, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s calculate the value of the credit in one year. To do this, we can use
    the `cm.ref()` function. The following arguments are required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migration matrix, where the last row gives the default class
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Loss given default
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rating of companies
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposure at default
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Riskless interest rate
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two arguments have already been defined and used, that is, the migration
    matrix and loss given default. For the remaining three, it is necessary to initialize
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the rating of the companies whose credit value we want to
    evaluate. We will set three values, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Exposure At Default** (**EAD**) is the amount of loss that a bank may suffer
    due to default. Since the default occurs on an unknown future date, this loss
    is conditioned by the amount the bank exposed to the borrower at the time of default.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will set three values, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to set the riskless interest rate; this parameter represents
    the interest expected by an investor from a completely risk-free investment over
    a given period of time. We set this value as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all of the arguments that are required by the `cm.ref()` function,
    we just have to apply it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Two values are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '`constVal`: Credit value in one year'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`constPV`: Portfolio of all the credit values in one year'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To extract these values, we can use the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following results are printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can search the absorbing state of the model. Remember that the
    absorbing state is a state that once entered, cannot be left. To evaluate the
    absorbing state, we can use the `absorbingStates()` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following result is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It is easy to understand that the default is a state absorbed in the sense that,
    once reached, it cannot be abandoned anymore. In the next section, we will address
    the problem of price optimization using the multi-armed bandit analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Pricing optimization system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pricing is something more than simply aligning prices with those of competitors
    in the market. One of the most negative aspects of global trade is that there
    is always someone, somewhere, selling the same products at a much lower price.
    Automatically aligning prices with competitors is not a sustainable strategy.
  prefs: []
  type: TYPE_NORMAL
- en: There are two pricing strategies. The first considers the trader's point of
    view and offers an intuitive pricing method, according to which the choice of
    the right price must depend on the manager's intuition. Since this strategy is
    very subjective, and since the results depend substantially on the manager's ability,
    it is difficult to evaluate it. And if the manager leaves the company, much of
    the knowledge about it should be lost. The second is based on a more theoretical
    point of view and offers an econometric pricing method, in which the choice of
    prices must be made based on advanced mathematical parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have chosen a range of prices to apply to the financial product, it
    is good practice to adopt an optimization procedure that evaluates the market
    reactions to the new product we want to launch. In the simplest case, an optimization
    problem consists of maximizing or minimizing a real function by systematically
    choosing the input values from an allowed set and calculating the value of the
    function. The generalization of theory and optimization techniques to other formulations
    constitutes a vast area of applied mathematics. More generally, optimization includes
    searching for the best available values of some objective functions in each domain,
    including a variety of different types of objective functions and different types
    of domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many optimization methods available; the following are some of the
    most important:'
  prefs: []
  type: TYPE_NORMAL
- en: Linear programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Least squares method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplex algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lagrange multiplier method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stochastic optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, we will try to address the problem of price optimization using
    multi-armed bandit analysis and the Bandit R package. To learn more about multi-armed
    bandit algorithms, see [Chapter 4](80162fc2-33f6-4f5a-9f70-6d063b32d9c9.xhtml),
    *Multi-Armed Bandit Models*. We will begin by introducing the Bandit package.
  prefs: []
  type: TYPE_NORMAL
- en: The Bandit package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This package contains a set of functions for analyzing A/B split test data
    and web metrics in general. The following table gives some information about this
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Package | `Bandit` |'
  prefs: []
  type: TYPE_TB
- en: '| Date | 2015-02-19 |'
  prefs: []
  type: TYPE_TB
- en: '| Version | 0.5.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Title | Functions for simple A/B split test and multi-armed bandit analysis
    |'
  prefs: []
  type: TYPE_TB
- en: '| Author | Thomas Lotze and Markus Loecher |'
  prefs: []
  type: TYPE_TB
- en: In the upcoming sections, we will formalize the problem and then face it through
    multi-armed bandit analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Pricing strategy for new financial services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A financial company that is very active in the market is considering the release
    of a new financial service. After having tested all of the services already available
    on the market by competitors and having compared their performance, the company
    decides to establish a range of prices to be attributed to the launch of its own
    service.
  prefs: []
  type: TYPE_NORMAL
- en: To check which of the identified prices best suits the needs of consumers, they
    have decided to test four types of prices by collecting subscriptions to the service.
    Each price will be attributed to the service for a period of time, during which
    the users who have been contacted and the accessions that have been obtained will
    be registered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The monitoring campaign will last three months, and an analysis will be carried
    out for each month. In the end, the best performing price will be adopted. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we need to import the `Bandit` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s reproduce the experiment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we report the data that was collected in the first month related to the
    users contacted and to the purchases of the services performed, as well as to
    the prices offered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, these are three vectors, which contain the data for each category.
    At this point, we can move on to the simulation of the posterior distribution
    for each arm at various prices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we used the `sim_post()` function, which simulates the posterior distribution
    of the Bayesian probabilities for each arm being the best binomial bandit. The
    following arguments were passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Purchases1`: A vector of the number of successes'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UsersContacted1`: A vector of the number of trials'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ndraws`: The number of random draws from the posterior'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this way, we get 10,000 assessments of the posterior distribution for the
    Bayesian probabilities. In the following are the first 10 assessments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can, therefore, evaluate the winner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `prob_winner()` function was used, which computes the probability that each
    arm is the winner, given simulated posterior results obtained in the preceding
    step. This function accepts only one argument—the simulated results from the posterior,
    provided by the `sim_post()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now assign the names to the winners we have simulated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s visualize the simulation results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following results are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the simulation told us that the price that seems to have been
    the most popular among users is $306, which collected 78.5% of the probability.
  prefs: []
  type: TYPE_NORMAL
- en: As we anticipated, we continue our monitoring by extending the analysis to the
    second month.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we report the data collected in the second month relating to the
    users contacted and the purchases of the services performed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, these are two vectors that respectively contain the four data
    for each category.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can move on to the simulation of the posterior distribution
    for each arm at various prices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can, therefore, evaluate the winner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We now assign the names to the winners we have simulated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s visualize the simulation results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following results are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the simulation told us that the price that seems to have been
    the most popular among users is $306, which collected 60.3% of the probability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s move on to the last month of price monitoring:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can move on to the simulation of the posterior distribution
    for each arm at various prices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can, therefore, evaluate the winner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We now assign the names to the winners we have simulated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s visualize the simulation results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following results are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the simulation told us that the price that seems to have been
    the most popular among users is $306, which collected 52.9 % of the probability.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to see whether the results obtained are statistically significant.
    When can we say that our experiment is significant? Nothing is significant at
    all. We decide how convincing the experiment must be to make us conclude that
    it really works. A fairly common way to represent the significance of a study
    is the P-value. The P-value is a number that represents the probability that the
    result found is due to chance, rather than to the phenomenon under consideration.
    Usually, by designing the experiment, you decide that you want to reach a particular
    P-value, for example, 1%, and you decide accordingly how big the sample must be;
    in other cases, the sample size is not under our control and the significance
    of the study is calculated a posteriori.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a significance test, we will use the `significance_analysis()` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This function performs overall proportion comparison, and the following values
    are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '`successes`: A vector of the number of successes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`totals`: A vector of the number of trials'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`estimated_proportion`: The number of successes/number of trials'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lower`: 0.95 confidence interval on the estimated amount by which this alternative
    outperforms the next-lower alternative'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upper`: 0.95 confidence interval on the estimated amount by which this alternative
    outperforms the next-lower alternative'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`significance`: P-value for the test that this alternative outperforms the
    next-lower alternative'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`order`: order by highest success proportion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`best`: 1 if it is part of the "highest performing group"—those groups that
    were not significantly different from the best group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p_best`: Bayesian posterior probability that this alternative is the best
    binomial bandit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data for the third month of monitoring returns the following results for
    the significance test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08d12858-2479-43d9-a992-1ff47143df8c.png)'
  prefs: []
  type: TYPE_IMG
- en: The results confirm that the fourth value that we have chosen as the price has
    produced non-significant results, so we can leave it out in subsequent analyses.
    The monitoring conducted so far has provided us with enough data. Let's go on
    to calculate the distribution of the improvement amounts that another arm could
    have on the current best arm.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we will calculate the value remaining as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used the `value_remaining()` function that returns the distribution
    of improvement amounts that another arm might have over the current best arm.
    Finally, we will calculate the potential value remaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we used the `quantile()` function. This function returns
    the quantiles of the indicated function (`ValueRemaining`) corresponding to the
    required value (0.95).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following result is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This value tells us that, compared to the price that seems to be winning ($306),
    any other value could beat it with a probability of up to 7.14%, which represents
    the 95% quantile of the remaining value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following section, we will tackle an optimization problem: we will try
    to evaluate the optimal configuration of a financial portfolio.'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing equity portfolios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The selection of an optimal portfolio is a typical decision problem, and as
    such, its solution consists of the following elements: the identification of a
    set of alternatives, using selection criteria to sort through the different possibilities,
    and the solution of the problem. To optimize a financial portfolio, we start by
    measuring the yield and risk of the products available. The risk-return variables
    can be considered two sides of the same coin since a certain level of risk will
    correspond to a given return. The return can be defined as the sum of the results
    produced by the investment concerning the capital employed, while the concept
    of risk can be translated into the degree of variability of returns associated
    with a given financial instrument. The preceding problem can be modeled as a MAB
    problem with financial products such as arms and product performance as a result.
    Before analyzing the code, we will define some concepts related to the world of
    financial investments.'
  prefs: []
  type: TYPE_NORMAL
- en: Exchange-traded fund portfolio optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The term **exchange-traded fund** (**ETF**) identifies a particular type of
    investment fund with two main characteristics: it is traded on the stock exchange
    as a share, and its sole investment objective is to replicate the index to which
    it reports (benchmark) through totally passive management.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An ETF summarizes the characteristics of a fund and an action, allowing investors
    to exploit the strengths of both instruments:'
  prefs: []
  type: TYPE_NORMAL
- en: Diversification and risk reduction of the funds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility and information transparency of real-time trading of shares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given its characteristics, the ETF lends itself to various modes of employment:
    medium/long-term investment, even intraday type trading and short selling to take
    a bearish position on the benchmark index. The possibility of easily diversifying
    the portfolio, the precision with which the benchmark index is replicated, and
    the low management costs mean that the ETF is particularly suitable for the construction
    of an accumulation plan through periodic payments—even small ones—that are made
    by individual investors. Let''s see how an ETF dataset is structured.'
  prefs: []
  type: TYPE_NORMAL
- en: ETF dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An ETF is, therefore, a collection of securities that draws an underlying index.
    The most well-known example is the SPDR S&P 500 (SPY) ETF, which replicates the
    S&P 500 index. In the example we are about to tackle, we will use a dataset containing
    the historical series of the following six ETFs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SPY**: SPDR S&P 500 ETF'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XLF**: Financial Select Sector SPDR Fund'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IWM**: iShares Russell 2000 ETF; IEF'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IEF**: iShares 7-10 Year Treasury Bond ETF'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GLD**: SPDRÂ Gold Shares'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VWO**: Vanguard FTSE Emerging Markets ETF'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These figures refer to the period from 1 January 2009 to 1 January 2019 and
    were downloaded from the Yahoo Finance website.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we will import the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The dataset contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**150 observations**: Monthly historical series'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**6 variables**: `EFTreturns`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This information is returned using the `str()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following list is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we can see the first 20 rows of the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99f114f6-5eb4-4545-81a2-776e87b1be97.png)'
  prefs: []
  type: TYPE_IMG
- en: 'More information can be obtained using the `summary()` function, which produces
    summaries of each variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following results are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb00f1f0-bd2a-419e-acf2-dda7bff1df9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this way, we have obtained a series of statistical descriptors that show
    us the distribution of the values assumed by the indices. To get an overview of
    the data, we can trace a boxplot. A boxplot describes the distribution of a dataset
    by simple dispersion and position indexes. A boxplot can be either horizontal
    or vertical and contains a rectangular partition divided by two segments. The
    rectangle (box) is delimited by the following features: first quartile (25^(th)
    percentile) and the third quartile (75^(th) percentile). The line inside the box
    represents the median (50^(th) percentile). Generally, the `boxplot()` function
    is used to plot a boxplot, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows the boxplot of the ETFs contained in the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0092954a-da47-4390-8fb7-0a1d61a8f88a.png)'
  prefs: []
  type: TYPE_IMG
- en: The `boxplot()` function can also be used to identify outlier values. Outliers
    are extreme values that are far from other available observations. These values
    tend to distort the results of the data analysis. For these reasons, the outliers
    must be previously identified in the data cleaning phase or processed in the subsequent
    data analysis phase. Analyzing the previous diagram, we can see that the XLF variable
    shows different anomalous values at the extremes.
  prefs: []
  type: TYPE_NORMAL
- en: Upper confidence bounds approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in Chapter 4, *Multi-Armed Bandit Models*, the game allows us
    to carry out exploitation and exploration together. At the beginning of the game,
    we don't know which arm is the best. Therefore, we cannot characterize any arm.
    Hence, the UCB algorithm employs that all arms have the same observed average
    value. So, a confidence limit for each arm will be created and an arm will be
    selected randomly.
  prefs: []
  type: TYPE_NORMAL
- en: In this context, each arm will give a reward or not. If the arm selected returns
    a mistake, the average that's observed by the arm will decrease, as well as the
    confidence limit. If the arm that's selected returns a reward, the observed average
    will increase, and the confidence limit will also increase. Taking advantage of
    the best, we are decreasing the confidence limit. Adding more and more rounds,
    the likelihood that other arms are doing well also increases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to select the stock that showed the maximum return for the highest
    number of observations. To do this, we transform our matrix with the monthly returns
    into a matrix in which, for each row, there will be some zeros, except for the
    maximum value, which will present a 1\. To do this, we will initialize a matrix
    of the same size as the starting dataset to zero. Then, we''ll enter a unit value
    at the maximum value of each row of the starting dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'From this moment on, we will work on this dataset. To start, we will set the
    number of observation and the number of arms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'After doing this, we will try to initialize a series of variables that will
    be useful in our calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The names of the variables are quite intuitive, but let''s verify their meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EFTSelected`: The EFT selected in the iterative cycle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NumSelections`: The number of selections made'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RewSum`: The sum of rewards for each arm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TotRew`: The total reward obtained'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point, we must use two iterative cycles to pass the entire matrix.
    The first cycle will allow us to cross all of the rows, while the second will
    work on the columns. Previously, we defined these as the number of `NumObs` rows
    and as the number of `NumArms` columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'For each line, we initialize two further variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can go through the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that, to perform an upper confidence bound at each round, two variables
    are computed: the sum of the rewards obtained by the lever *i* after *n* plays,
    and the number of times the lever *i* is played by the strategy in the first *n*
    plays. We calculate the average rewards obtained by the lever *i* after *n* plays
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We calculate the confidence interval after *n* plays using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we select the lever *i* that returns the maximum UCB, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'After doing this, we make some checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we update the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our analysis has been completed and we can view the results.
    To visualize the results, we need to draw a histogram. A histogram is a graph
    that shows the frequency that a given item appears in a specific range. A histogram
    is similar to a bar chart, but normally its area is used to graphically represent
    the frequency with which a given element appears. Histograms are used to represent
    a set of continuous data, such as time, a measurement, or a temperature. The main
    problem with histograms is the difficulty of comparing two sets of data and the
    impossibility of obtaining a precise reading of the values assumed by the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw a histogram, we will use the `hist()` function, which computes a histogram
    of the given data values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The following histogram is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14c98532-878c-4d02-a6b1-ff2c37228fef.png)'
  prefs: []
  type: TYPE_IMG
- en: From the analysis of the preceding diagram, it seems that stock (GLD) number
    6 is the one that's selected the most, by the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's see how we can deal with the problems of identifying fraud.
  prefs: []
  type: TYPE_NORMAL
- en: Fraud detection techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the banking sector, fraud prevention is essential. And here, too, the implementation
    of machine learning within consolidated algorithms is a clear success factor.
    Here, we will return to the predictive capacity of AI—a suspicious movement is
    not only anomalous in terms of the level of figures and perhaps of geographical
    location, but also that which deviates from a behavioral model of the client that
    the AI has clearly identified. In this way, in the face of obvious anomalies,
    the AI can set blocks or limitations without waiting for the fraud to manifest
    itself in all of its potential.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fraud detection problems have generally been addressed using supervised algorithms.
    In these algorithms, a series of labels guide the machine to the identification
    of system anomalies. Reinforcement learning is a very robust algorithm that allows
    an agent to receive states from an environment and then perform actions based
    on those states. Depending on these actions, it will be rewarded accordingly.
    As we saw in [Chapter 2](aed130c4-9d8b-42d1-826a-e26a4162ebcf.xhtml), *Building
    Blocks of Reinforcement Learning*, the three essential elements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to use this to tackle a classification problem, it is necessary
    to carefully define the three parameters we just mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to identify the fraudulent use of credit cards, which is one
    of the most common computer crimes. The available data provides us with some variables
    that propose the behavior of the user and then the binary class (1.0) that labels
    the operation. In this case, a correct formulation of the problem includes the
    following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`status`: These are all of the variables that summarize the user''s behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`action`: This is the binary value containing the operation label (0 = valid
    operation and 1 = fraudulent operation).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reward`: This provides feedback to the system. The reward is obtained through
    an evaluation of the action. You get a reward if the action = 0, or if the operation
    is valid. This will allow the reinforcement learning-based system to learn when
    an operation is valid and to discern it from fraudulent ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To improve the reward function, negative recompense can be envisaged in the
    case of fraudulent exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to solve financial problems using reinforcement
    learning techniques. After introducing the field of application, we studied some
    practical cases. For starters, we learned how to model credit risks such as Markov
    chains to perform credit scoring analysis. Then, we learned how to choose the
    best price for a new product to be launched on the market. Once we have chosen
    a range of prices to apply to the financial product, it is good practice to adopt
    an optimization procedure that evaluates the market reactions to the new product
    we want to launch. To do this, we modeled the system through an algorithm based
    on the multi-armed bandit approach. Finally, we learned how to optimize the choice
    of a stock market based on the returns that had been obtained in recent years.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use reinforcement learning in healthcare.
    First, we will learn how to choose the optimal policies from observational data
    and understand how to detect breast cancer using TD-learning. Finally, we will
    learn how to forecast thyroid disease using R.
  prefs: []
  type: TYPE_NORMAL
