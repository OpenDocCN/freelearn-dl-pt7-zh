["```py\nInitialize\n    arbitrary policy π\n    arbitrary state-value function\nRepeat\n    generate episode using π\n    for each state s in episode\n        the received reward R is added to the set of\n       reinforcers obtained so far\n        estimate the value function on the basis on the average\n        of the total sum of rewards obtained\n```", "```py\nHIT <- 1 \nSTICK <- 2\n```", "```py\nBJCard <- function()\n  return(sample(10,1))\n```", "```py\nStateInput <- function () {\n   return ( c(sample(10, 1), sample(10, 1), 0))\n}\n```", "```py\nStepFunc <- function (s, a) {\n if(s[3]==1)\n return(list(s, 0))\n\n NewState <- s\n BJReward <- 0\n```", "```py\n if(a==1) { \n     NewState[2] <- s[2] + BJCard() \n     if (NewState[2]>21 || NewState[2]<1) { \n         NewState[3] <- 1\n         BJReward <- -1\n     }\n}\n```", "```py\nelse { \n    NewState[3] <- 1\n     DealerWork <- FALSE\n     DealerSum <- s[1]\n     while(!DealerWork) { \n         DealerSum <- DealerSum + BJCard()\n         if (DealerSum>21) { \n             DealerWork <- TRUE\n             BJReward <- 1\n         } else if (DealerSum >= 17) { \n             DealerWork <- TRUE\n             if(DealerSum==s[2])\n                 BJReward <- 0\n             else \n                 BJReward <- 2*as.integer(DealerSum<s[2])-1\n             }\n         }\n     }\n return(list(NewState, BJReward))\n}\n```", "```py\nActionsEpsValGreedy <- function(s, QFunc, EpsVal) {\n if(runif(1)<EpsVal)\n return(sample(1:2, 1))\n else\n return(which.max(QFunc[s[1],s[2],])) \n}\n```", "```py\nlibrary(\"foreach\")\n```", "```py\nMontecarloFunc <- function(NumEpisode){\n  QFunc <- array(0, dim=c(10, 21, 2))\n  N <- array(0, c(10,21,2))\n  N0=100\n```", "```py\n policy <- function(s) {\n     ActionsEpsValGreedy(s, QFunc, N0/(sum(N[s[1], s[2],])+N0))\n }\n```", "```py\nforeach(i=1:NumEpisode) %do% {\n s <- StateInput()\n SumReturns <- 0\n N.episode <- array(0, c(10,21,2))\n```", "```py\nwhile(s[3]==0) {\n a <- policy(s)\n N.episode[s[1], s[2], a] <- N.episode[s[1], s[2], a] + 1\n StateReward <- StepFunc(s, a)\n s <- StateReward[[1]]\n SumReturns <- SumReturns + StateReward[[2]]\n}\n```", "```py\nIndexValue <- which(N.episode!=0)\n N[IndexValue] <- (N[IndexValue]+N.episode[IndexValue])\n QFunc[IndexValue] <- QFunc[IndexValue] + (SumReturns-QFunc[IndexValue]) / N[IndexValue]\n }\n```", "```py\nreturn(list(QFunc=QFunc, N=N))\n }\n```", "```py\nMCModel <- MontecarloFunc(NumEpisode=100000)\n```", "```py\nStateValueFunc <- apply(MCModel$QFunc, MARGIN=c(1,2), FUN=max)\n```", "```py\npersp(StateValueFunc, x=1:10, y=1:21, theta=50, phi=35, d=1.9, expand=0.3, border=NULL, ticktype=\"detailed\",\n shade=0.6, xlab=\"Dealer exposed card\", ylab=\"Player sum\", zlab=\"Value\", nticks=10)\n```"]