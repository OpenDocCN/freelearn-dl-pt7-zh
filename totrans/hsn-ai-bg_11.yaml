- en: Deep Learning for Finance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deep learning is one of the most exciting new technologies being used in the
    financial services industry, and when used correctly, can improve investment returns. While
    tasks such as computer vision and **natural language processing** (**NLP**) are
    well-researched areas, the use of **Artificial Intelligence** (**AI**) techniques
    in financial services is still growing. It's important to note that some of the
    most advanced, lucrative deep learning techniques in AI are not published, nor
    will they ever be. The lucrative nature of the financial services space necessitates
    guarding advanced algorithms and measures, and so in this chapter we will focus
    on principles.
  prefs: []
  type: TYPE_NORMAL
- en: The application of AI in the financial services industry is nuanced; ...
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, we will be utilizing Python 3 for our analysis. Python is an excellent
    choice for quantitative trading applications that have a frequency that's greater
    than a few seconds. For high-frequency applications, it is recommended that you
    use a mid-level language such as Java or C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be using finance-specific Python libraries on top
    of our standard deep learning stack:'
  prefs: []
  type: TYPE_NORMAL
- en: Zipline—An algorithmic trading library in Python. It is currently used as the
    backtesting package for the quantitative trading website Quantopian ([https://www.quantopian.com](https://www.quantopian.com)).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to AI in finance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite being one of the most computationally intensive fields, financial services
    is full of heuristics. The application of advanced AI techniques is tenuous at
    best; many firms simply don't engage in strategies that allow for easy adoption
    of AI. Talent wars for top quantitative talent with Silicon Valley has also made
    the problem worse. You may be saying to yourself *don't I need to have a finance
    background to work with this data? *It's worth noting that two of the world's
    top hedge funds were founded by teams that participated in the famous Netflix
    Machine Learning challenge. While there is incredible benefit in studying the
    techniques of algorithmic trading, you can get started with your knowledge of
    ANNs ...
  prefs: []
  type: TYPE_NORMAL
- en: Deep learning in trading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Trading** is the buying and selling of items in the financial market; in
    financial parlance, we call these items **derivatives**. Trades can be short-term
    (inter-day), medium-term (several days), or long-term (several weeks or more). According
    to experts at JP Morgan Chase, one of the largest banks in the world, AI applications
    are proven to be better suited than humans at short and medium-term trading strategies.
    In this section, we''ll explore some fundamental strategies for developing intelligent
    trading algorithms for short and medium- term trades. But first, let''s cover
    some basic concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: Trading strategies seek to exploit market inefficienciesin order to make profit. One
    of the core policies in algorithmic training is called **alpha**,which is a measure
    of performance. Alpha measures the active return on a specific investment by matching
    a stock against an index. The difference between the performance of an individual
    investment and its matched index is the investment's alpha. In building networks
    for trading strategies, we want our networks to spot market inefficiencies that
    generate the most alpha for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can generally break traditional stock analysis down into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fundamental analysis** looks at the underlying factors that could influence
    a financial derivative, such as the general financial health of a company'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technical analysis** looks at the actual performance of the financial derivative
    in a more mathematical sense, attempting to predict price movements based on patterns
    in the asset''s price movements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In both of these cases, analysis is typically done with human reasoning, whereas
    deep learning comes into the world of **quantitative analysis**, specifically
    in what is known as **algorithmic trading**. Broadly defined, algorithmic trading
    is just as it sounds: trading that is conducted by a coded algorithm and not a
    physical human. Algorithmic trading strategies are validated by a process called
    **backtesting**, which runs the algorithm on historical data to determine whether
    it will perform well in the market.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithmic trading is used in several different types of areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Buy**-**side firms**: Firms utilize algorithmic trading to manage their mid-to
    long-term portfolio investments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sell**-**side firms**: Firms use high-frequency algorithmic trading to take
    advantage of market opportunities and move markets themselves'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Systematic traders**: These individuals and firms try to match a long-term
    investment with a short-term investment of highly correlated financial derivatives'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's shared among all three of these market entities is that algorithmic trading
    provides a more stable and systematic approach to active investing, which is something
    that a human instinct could not provide.
  prefs: []
  type: TYPE_NORMAL
- en: Another strategy relies on technical indicators, which are mathematical calculations
    based on the historical analysis of data. Most trading algorithms are used in
    what is known as **high**-**frequency trading** (**HFT**), which attempts to exploit
    market inefficiencies by conducting large numbers of extremely fast trades across
    markets. Unless you have access to some seriously fast computer hardware, it's
    unlikely for an individual to compete in this arena. Instead, we're going to build
    some fundamental algorithms in TensorFlow for non-HFT algorithmic trading.
  prefs: []
  type: TYPE_NORMAL
- en: Building a trading platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into any particular strategies, let's get started with building
    the basis for our trading platform. In this section, we'll build out the code
    that will handle data ingestion and trading, and then we'll dive into two specific
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Basic trading functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the fundamental actions our platform could take on the market;
    we need it to be able to buy, sell, or hold stock:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s start with some imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To make things easier on us down the road, we''re going to wrap these functions
    inside a single class that we''ll call `TradingPosition`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's break the input variables down. The first variable that we are initializing
    is `code`, which we'll be using later as a status code for the action we are taking
    to buy, sell, or hold. We then create the variables for the price of the security,
    the amount of the security (that is, how much stock), and the current value of
    the security.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have our variables, we can start coding our trading actions. We''ll
    want to create a `status` function, which tracks the movement of prices in the
    market. For simplicity, we''ll call this function `TradeStatus`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create a function to `buy a stock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, our function takes a `buy price`, the `amount`, and the `next price`
    in the series. We calculate the `buy price`, update our trading volume, and return
    a `trade status`. Next, let''s move on to `sell a stock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of the buy function, we feed in the `sell price` and the volume, update
    the class''s internal variables, and return a status. Lastly, we''ll just create
    a simple function to hold a stock, which more or less gives us a status of what
    the current price of that stock is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's move on to creating a class that will represent our artificial trader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an artificial trader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While utilizing algorithms to inform trading decisions is the definition of
    algorithmic trading, this is not necessarily automated trading. For that, we need
    to create an artificial trading agent that will execute our strategies for us:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll call this class `Trader` and initialize all of the variables that we''ll
    need for the trader algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Managing market data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with any machine learning algorithm, selecting features for market prediction
    algorithms is critical, and can lead to the success or failure of the algorithm''s
    strategy. To reduce price curve data into its most fundamental parts, we can use
    a dimensionality reduction algorithm such as PCA, or even embed stock information
    to try to capture the most salient latent features. As we have learned, deep learning
    can help us overcome some of these selection issues, as ANNs implicitly conduct
    feature selection during the training process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll call our new class `MarketHandler` and initialize all of the parameters
    and data that will be needed to handle our different trading strategies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need to initialize a great deal of data handling processes to correctly
    manipulate our data for analysis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we initialize the `env_data()` method and call the `self` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let''s initialize the data handling function that we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's dive into building the models for our platform.
  prefs: []
  type: TYPE_NORMAL
- en: Price prediction utilizing LSTMs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by walking through a supervised learning example utilizing an
    LSTM to predict where the price of a given stock is going, based on its past performance.
    As we learned in previous chapters, LSTMs and **Recurrent Neural Networks **(**RNN**)
    in general are superior at modeling and prediction for series data. This model
    will utilize the trading platform structure that we created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with our imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a class that will contain all of the code needed to run the RNN,
    which we''ll call `TradingRNN`. We''ll also initialize the necessary variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Backtesting your algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backtesting is the process of testing your trading algorithm on bits of historical
    data in order to simulate its performance. While it's no guarantee that the algorithm
    will perform well in the wild, it gives us a good idea of how it will perform.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we can backtest our algorithms using a library called **Zipline**.
    Zipline was created by the online trading algorithms platform Quantopian as their
    backtesting platform, and it's been open sourced to the public on GitHub. It provides
    ten years of historical stock data and a realistic trading environment in which
    you can test algorithms, including transaction costs, order delays, and slippage**.**
    Slippage is the price difference that can occur between the expected price at
    which a trade happens and the actual price it's executed at. To get started with
    Zipline in Python, we simply need to run `pip install zipline` on the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any time we use Zipline, we must define two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`initialize(context)`: This is called by Zipline before it starts running your
    algorithm. The context variable contains all of the global variables needed in
    your algorithm. Initialize is very similar to how we initialize variables in TensorFlow
    before running them through a session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handle_data(context, data)`: This function does exactly what it says: it passes
    the open, high, low, and close stock market data to your algorithm, along with
    the necessary context variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-driven trading platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event-driven investing is an investing strategy that focuses on socioeconomic
    factors that might influence the stock market's movements, particularly right
    before a financial event such as an earnings call or merger. This strategy is
    typically used by larger funds, as they frequently have access to information
    not entirely open to the public and because it requires a large amount of expertise
    in analyzing these events correctly.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we'll extract events from raw text into tuples that describe the
    event. For instance, if we said that *Google* buys *Facebook*, the tuple would
    be (*Actor = Google, Action = buys, Object = Facebook, Time = January 1 2018*).
    These tuples can help us boil down events into their ...
  prefs: []
  type: TYPE_NORMAL
- en: Gathering stock price data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The majority of real-time market data comes though paid services; think Bloomberg
    terminals or a brokerage firm's website. Currently, the only non-paid real-time
    data API for financial markets is Alpha Vantage, which is maintained by a conglomerate
    of business and academic interests. You can install it by running `pip install
    alpha_vantage` on your command line. You can sign up for a free API key on Alpha
    Vantage's website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your key, you can easily query the `api` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Generating word embeddings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our embedding scheme, we are going to be using the implementation of GloVe
    from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Neural Tensor Networks for event embeddings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Neural Tensor Network** (**NTN**) is a new form of neural network that works
    like a standard feed-forward network, only it contains something known as a **tensor
    layer** instead of standard hidden layers. The network was originally developed
    as a means of completing knowledge bases by connecting unconnected entities. For
    instance, if we had the entities Google and YouTube, the network would help connect
    the two entities so that Google -> Owns -> YouTube. It passes different relationship
    pairs through the network instead of through a singular vector, and it does this
    by passing them as a tensor. Each slice of that tensor represents a different
    variation of a relationship that two entities can have.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the realm of event-driven trading, we''re interested in NTNs because of
    their ability to relate entities to each other. For us, that means learning the
    entity event pairs that we created in the first part of this section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by building our NTN with our core network, which we''ll contain
    in a function called `NTN`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Still within the `NTN` function, we''ll loop over our embeddings and start
    to generate relationship embeddings from them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we''ll run the relationship through a nonlinearity and output them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let''s return all of our relationships that are embedding `predictions`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s define our `loss` function for the network. We''ll manually build
    out our `loss` function from TensorFlow''s native operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll define a training algorithm that simply returns the minimized `loss`
    function utilizing TensorFlow''s built-in functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll create a short function to evaluate the performance of the
    network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll finish up our model by predicting price movements with a CNN.
  prefs: []
  type: TYPE_NORMAL
- en: Predicting events with a convolutional neural network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our embedding structure, it's time to predict off of that structure
    with a CNN. When you typically think of a CNN, and the work that we have completed
    on them, you're probably thinking of computer vision tasks such as recognizing
    an object in an image. Although this is what they were designed for, CNNs can
    also be great at detecting features in text.
  prefs: []
  type: TYPE_NORMAL
- en: When we use CNNs in NLP, we replace the standard input of pixels with word embeddings.
    While in typical computer vision tasks you utilize the CNNs filters over small
    patches of the image, for NLP tasks, we use the same sliding window over the rows
    of a matrix of embeddings. The width of the sliding window, therefore, becomes
    ...
  prefs: []
  type: TYPE_NORMAL
- en: Deep learning in asset management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In financial services, a portfolio is a range of investments that are held by
    a person or organization. To achieve the best return possible (as anyone would
    want to!), portfolios are optimized by deciding how much capital should be invested
    into certain financial assets. In portfolio optimization theory, the objective
    is to have an allocation of assets that minimize risk and maximize reward. We
    would therefore need to create an algorithm that predicts the expected risks and
    rewards for each asset so that we may find the best optimization. Traditionally,
    this work is done by a financial advisor, however, AI has been shown to outperform
    many traditional advisor-built portfolios.
  prefs: []
  type: TYPE_NORMAL
- en: Lately, there have been several attempts to develop deep learning models for
    asset allocations. Giving credence to the fact that many of these techniques are
    not published publicly, we are going to take a look at some fundamental methods
    that we as AI scientists may use for accomplishing this task.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal will be to train a model on an index of stocks, and see if we can outperform
    that index by at least 1%. We are going to effectively build an autoencoder to
    encode latent market information, and then use the decoder to construct an optimal
    portfolio. As we are dealing with series information, we'll use an RNN for both
    our encoder and decoder. Once we have an autoencoder trained on the data, we'll
    use it as the input for a simple feed-forward network that will predict our optimal
    portfolio allocations.
  prefs: []
  type: TYPE_NORMAL
- en: Let's walk through how we would do this in TensorFlow.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, let''s start with our imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s load up our stock data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s begin our modeling process by creating our `AutoEncoder`, which we will
    contain in an `AutoEncoder` class. We''ll start by initializing the primary network
    variables, like we did previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll create the `placeholders` for the input data, *x:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create our encoder. We''ll create a series of LSTM cells to encode
    the series data, but we will do it in a way we haven''t seen yet: by using a handy
    function from TensorFlow called `MultiRNNCell`. This function acts as a larger
    placeholder of RNNs that we can iterate inside of so that we may dynamically create
    the amount of layers based on whatever we decide the `num_layers` parameter is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create a layer to handle the hidden states that are generated
    by the encoder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create the `decoder` layer in the same fashion that we did with
    the encoder layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we''ll create the output layer for the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the actual model constructed, we can go ahead and set up the
    training process. We''ll use exponential decay for the learning rate, which helps
    stabilize the training process by slowly decreasing the value of the learning
    rate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run the training process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: After we autoencode our stock index, we'll look at the difference between each
    different stock and its corresponding autoencoder version. We'll then rank the
    stocks by how well they have been autoencoded. As the algorithm learns the most
    important information about each of the stocks, the proximity of a stock to its
    version that has been run through the autoencoder provides a measure for that
    stock against the entire potential portfolio.
  prefs: []
  type: TYPE_NORMAL
- en: 'As there is no benefit in having multiple stocks contributing to the latent
    information, we will limit the selected stocks to the top ten of these stocks
    that are close to their autoencoded version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can take a look at how the autoencoder is working as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: While we still have to choose between the available stock, our picking decisions
    are now based on the out of sample performance of these stocks, making our market
    autoencoder a novel, data-driven approach.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to apply our deep learning knowledge to the
    financial services sector. We learned the principles of trading systems, and then
    designed a trading system of our own in TensorFlow. We then looked at how we can
    create a different type of trading system, one that utilizes events surrounding
    a company to predict its stock prices. Lastly, we explored a novel technique for
    embedding the stock market and utilizing those embeddings to predict price movement.
  prefs: []
  type: TYPE_NORMAL
- en: Financial markets can be tricky to model due to their properties, but the techniques
    that we have covered in this chapter will give you the basis to build further
    models. Remember to always backtest your algorithm before deploying it in a real-time
    environment! ...
  prefs: []
  type: TYPE_NORMAL
