- en: Understanding the Breadth-First Search Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **breadth-first search** (**BFS**) algorithm is a traversing algorithm where
    you start at a selected node (the source or starting node) and traverse the graph
    layer-wise, exploring the neighboring nodes (nodes that are directly connected
    to the source node). You then move towards the neighboring nodes in the next level.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about BFS while developing LinkedIn's connection
    feature. You will learn how second-degree connections can be computed by using
    the BFS algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the LinkedIn connection feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queue data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The BFS algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DFS versus BFS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the LinkedIn connection feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you know, LinkedIn is a social network, and users are connected to one another
    through first- or second-degree connections. In order to better understand this
    concept, use the following diagram as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9d1c864-52d8-40ab-9b41-b62fa17a5c7d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that I want to find an acquaintance named **Jill **and connect with
    her. When I go to her profile, I find that she is a second-degree connection,
    which means that we have a mutual colleague. Let''s look at how this degree is
    computed. To do so, we will create a connection tree:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the profile node, **Dev**, and add it to the connection tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/05a0cb02-1efe-4b1c-a906-0561b07010d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I will find my colleagues and add them beneath my node. So, I add **Ali**
    and **Tom** beneath the **Dev** node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7a569634-9366-42e6-aa28-95a997a6c16f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for both **Ali** and **Tom**, I find their colleagues and add them beneath
    their nodes. So, under **Ali, **I add **Dev**, **Seth**, and **Ram**, and under
    **Tom,** I add **Dev**, **Seth**, **Kai**, and **Jill**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/624c3eaa-ebbc-46e9-8199-d7dc39417e90.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for each of these nodes, we find their connections and add those as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a7bd3a9e-f2f4-4ece-a11d-74a8955c5625.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, the connections to **Dev** have been added (due to
    space constraints, this is not shown). For **Seth**, we find his connections (**Ali**,
    **Tom**, and **Harry**) and add them underneath his name. For **Ram**, we add
    **Ali** and **Jill**. Similarly, due to space constraints, we are not showing
    the connections for **Dev** and **Seth**, as they are already shown in the diagram.
    Under **Kai**, we add his connection, **Tom**. Finally, when we come to the node
    for **Jill (**to add her connections), we find that this node has the goal state,
    so we end our search.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that **Jill** appears as a connection to **Ram** at the
    bottom of the tree; but, if you consider the bottom node, then the connection
    degree is **3**, which is not the least value. However, because a BFS search processes
    the search tree level by level, we're able to find the least path solution. We
    can also see that there are people that appear multiple times in this connection
    tree. For example, **Dev**, **Ali**, and **Tom** appear three times each, while
    **Seth** and **Jill** each appear twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we''ll keep the first entry of the node in the connection tree, and we
    will remove the other instances; the following diagram shows how the search tree
    should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/989bb140-e37c-4877-8bfb-7f9c2584edec.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6
  prefs: []
  type: TYPE_NORMAL
- en: When we add the node to the search tree, we should check whether it already
    exists in the search tree.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](50419d40-ab0f-4d63-9447-295dc802574c.xhtml), *Understanding the
    Depth-First Search Algorithm,* you learned that the `State` class indicates the
    condition of the search process. You also learned that the `State` class has to
    be changed for every application, even though the search algorithm is the same.
    Now, let's look at the changes that we need to make to the `State` class for this
    application.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need a property to track the condition of the search. In this case,
    the property is the person under consideration. Then, we have the same four methods—`constructor()`,
    `getInitialState()`, `successorFunction()`, and `checkGoalState()`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at each of these three ingredients in detail. To find the initial
    state, we should ask ourselves the question, *where do we start searching from?*
    In this application, we start searching from my profile. To find the successor
    function, we should ask ourselves, *how do we explore from the current state?*
    In this application, the function should return the people connected to the person
    under consideration. So, for **Ali **it should return all of his colleagues. Finally,
    to find the goal function, we should ask the question, *how will we know when
    we have found the solution?* The goal function should return true if the person
    is `Jill`. So, if the current person is Harry, the function should return false,
    and if the current person is `Jill`, it should return true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `State` class code for this application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, in this module, `State.py`, we are importing
    all of the variables from `GraphData`. The purpose of `GraphData` will be explained
    in the *Graph data structure* section. In the constructor, the `name` argument is
    passed. If the argument `name` is `None`, then the initial state is created, and
    if the name is provided, that name is assigned to the name property. The `initialState` property
    holds the value `Dev`, and the `successorFunction` method returns all of the people
    connected to the current person. To get the people connected to the person, we
    use connections from GraphData:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `checkGoalState` function returns if the current person's name is `Jill`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should understand how the degree of connection is computed and how
    the `State` class has changed for this application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at how to represent social network data as a
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: Graph data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **graph** is a non-linear data structure containing a set of points known
    as **nodes** (or vertices) and a set of links known as **edges**, as illustrated
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4a7c5fa-9513-4a4c-8d90-45f222707e44.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7
  prefs: []
  type: TYPE_NORMAL
- en: An edge that connects to the same node is called a **cycle**. As shown in the
    preceding diagram, nodes **a** and **b** are connected by two paths; one is through
    edge **a-b**, and the other is through edges **a-d** and **d-b**. A **tree** is
    a special type of graph, in which there are no cycles, and two nodes are connected
    by one path.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we can use a dictionary structure to represent a graph. A **dictionary**
    is a data structure where many keys are mapped to values. For a dictionary that
    represents a graph, the keys are the nodes, and the values of those nodes are
    the nodes that they are connected to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1dbe59aa-ca3f-420c-83d2-aa88e455b6dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, we can see that the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For key a**, the values are **b** and **c**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For key b**, the values are **c** and **a**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For key c**, the values are **a** and **b**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s create a dictionary to show the graph structure of the social network
    that we saw in the previous topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Python module `GraphData.py`, we have created a dictionary called `connections`.
    The keys are the people in the social network, and the corresponding values are
    the people that they are connected to. Now, the `connections` dictionary is used
    in `State.py`. It is used in the  `successorFunction` function, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can get the people that the person is connected to by using the `connections`
    dictionary, with the person's name as the key. We can get the people that are
    connected to that person by using the `connections` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how to traverse this graph data structure, in order to
    create a search tree:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start with my profile in the graph, and add the **Dev** node to the
    search tree and the visited nodes list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From my node in the graph, we can find the connected people, **Ali** and **Tom**;
    we add these nodes to the search tree and the visited nodes list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Ali** and **Tom**, we find who they're connected to by using the graph
    data structure, and we add these nodes to the search tree and the visited nodes
    list, if they have not been visited before. **Ali** is connected to **Dev**, **Seth**,
    and **Ram**. **Dev** has already been visited, so we ignore this node. **Seth**
    and **Ram** have not been visited before, so we add these nodes to the search
    tree and the visited nodes list. **Tom** is connected to **Dev**, **Seth**, **Kai**,
    and **Jill**. **Dev** and **Seth** have already been visited, so we ignore these
    nodes, and we add the nodes **Kai** and **Jill** to the list, because they have
    not been visited before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We repeat the process of adding the children to the search tree and the visited
    nodes list (if they have not been visited before). **Seth** is connected to **Ali**,
    **Tom**, and **Harry**. **Ali** and **Tom** have already been visited, so we ignore
    them, and we add **Harry** to the search tree and the visited nodes list. **Ram**
    is connected to **Ali** and **Jill**, and both of them have been visited before.
    Moving forward, **Kai** is connected to **Tom**, and he's already been visited,
    as well. When we process the **Jill** node, we find that it has the goal state,
    and we end our search.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You have now learned how to use a list of visited nodes to explore a graph
    as a tree, which will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e97fd7e7-f8ae-4bf3-98dc-53c3e001cfa7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you'll learn about the queue data structure, which forms
    the basis of node reversal, just like a stack in the DFS method.
  prefs: []
  type: TYPE_NORMAL
- en: Queue data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **queue** is a sequence of people or objects waiting to be attended to. Some
    examples include a queue of people waiting at a counter, a queue of swimmers that
    are ready to dive in to a pool, and a queue of songs in a playlist:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e7fa6ab-615b-44e4-92bf-e084c5e9204e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in a stack, there are two types of operations—one for inserting items
    into a queue, and one for removing items from a queue. When a person joins a queue,
    he or she must stand behind the last person. The operation of adding an item to
    a queue is called **enqueue**. The first person to be attended to in a queue is
    the person standing in the front. The operation to remove an item from a queue
    is called **dequeue**. Queue operations can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7681900b-ad36-463c-a701-fa4a225ed277.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the first object inserted is the first one to be removed, this data structure
    is called **first in first out** (**FIFO**). In Python, we can use the `deque`
    class to create `queue` objects. The `deque` class provides two methods—one method,
    `append`, for inserting items, and a method called `popleft` for removing items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have created an empty queue, to which we will add
    the items `1`, `2`, `3`, and `4`; later, we will delete these items from the queue
    one by one. Upon successful execution of the code, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8484ed2f-aece-4384-8dd1-6da565c1e9e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, we initially have an empty queue, and,
    after adding items `1`, `2`, `3`, and `4`, you can see that the items are in the
    queue, with `1` at the front and `4` at the back. When we remove an item from
    the queue, the first one to be removed is `1`, because it is at the front, and
    then `2`, `3`, and `4` are removed. At the end, we have an empty queue.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how a queue works, we'll look at the steps in a BFS
    algorithm and how the graph and queue data structures are used.
  prefs: []
  type: TYPE_NORMAL
- en: The BFS algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at the flow of the BFS algorithm, how a queue is
    used, and how graph data affects the algorithm. The flow of the BFS algorithm
    is similar to that of DFS, but instead of using a stack data structure, a queue
    data structure is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'A flowchart of the BFS algorithm can be illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b4087b1-79bb-4692-a691-d0131dbc9b2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13
  prefs: []
  type: TYPE_NORMAL
- en: We initially create a root node with an initial state, and add it to a queue
    and tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A node is dequeued from the queue, and we check whether it has the goal state.
    If it does, we end our search. If it doesn't, we find the child nodes of the dequeued
    node and add them to the queue entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This process is repeated until we either find the goal state or have exhausted
    all of the nodes in our search tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since our connection data is in a graph structure, we have to check whether
    each node has been visited before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, we add the root node to a list of visited nodes, and the child node is added
    to the queue, tree, and visited list (if the child node has not been visited previously).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at these steps in detail by implementing them in our graph diagram,
    which we covered in the *Understanding the LinkedIn connection feature* section:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by adding my profile node to the search tree, queue, and visited nodes
    list. We dequeue the **Dev** node from the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the **Ali** node has not been visited, we add this node to the search
    tree, queue, and visited nodes list. Similarly, since **Tom** has not been visited,
    we add this node to the search tree, queue, and visited nodes list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We dequeue the **Ali **node from the queue, and, since it doesn''t have the
    goal state, we find its child nodes: **Dev**, **Seth,** and **Ram**. The **Dev**
    node has been visited, so we ignore that node. The **Seth** node has not been
    visited, so we add that node to the search tree, queue, and visited nodes list.
    Similarly, we add **Ram** to the search tree, queue, and visited nodes list.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We dequeue the **Tom** node from the queue, and we find its children nodes: **Dev**,
    **Seth**, **Kai,** and **Jill**. The **Dev** node has been visited, so we ignore
    that node, and the same goes for the **Seth** node. The **Kai** node has not been
    visited, so we add that node to the search tree, queue, and visited nodes list;
    the same goes for the **Jill** node. We dequeue the **Seth** node from the queue,
    and we find its child nodes: **Ali**, **Tom**, and **Harry**. The **Ali** and
    **Tom** nodes have been visited, so we ignore these nodes. We add the node **Harry**
    to the search tree, queue, and visited nodes list.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We dequeue the **Ram **node from the queue, and we find its child nodes, **Ali**
    and **Jill**, which have both been visited; so, we carry on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We dequeue the **Kai **node, and we find its child node, **Tom**, which has
    been visited; so, we carry on again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We dequeue the **Jill** node from the queue, and we find that it has the goal
    state, so we end our search.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we have completed the preceding steps, we will have the following tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/888f7612-2134-4edf-95ea-36aea1f073c2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the preceding algorithm with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Python module `QueueBFS.py`, we have created a method called `performQueueBFS`,
    in which we have an empty queue that will hold the nodes and a list of visited
    nodes. We create the root node with `initialState`, and we add this root node
    to the queue, along with a list of visited nodes. One by one, we dequeue elements
    from the queue; we call the dequeued node the `currentNode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We print the name of the current node and check whether it has the goal state.
    If it does, we print the path from the root node to the current node and break
    the loop. If it doesn't have the goal state, we find the child states of the current
    state, and for each higher state, we construct the child node and check whether
    that node has been visited.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of visited nodes now holds the names of the nodes. So, in the following
    code, we have added the name of the root node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We have done the same in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we check whether the name of the node has not been visited.
    Because we're checking for unique names, if the node has not been visited, we
    add the name of the child node to the list of visited nodes, and we add the child
    node to the search tree and the queue. Finally, we print the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the code and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4b02ccc-942e-4e42-b23e-79c553aaf212.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see the order in which the nodes are processed.
    We start off with the `Dev` node, and then we process the connections, `Ali` and `Tom`,
    and then the connections of `Ali`, `Ram`, and `Seth`, and the connections of `Tom`, `Kai`
    and `Jill`. When we process the `Jill` node, we find that we have reached the
    goal state and we end our search.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see the path printed from the initial state
    to the goal state through the `Tom` node . From this, we can see that `Jill` is
    a second-level connection. We can also see the search tree that has been constructed
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are aware of the steps involved in BFS, we'll compare the BFS and
    DFS algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: BFS versus DFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at the differences between the DFS and BFS algorithms.
    We will compare these differences in terms of various factors.
  prefs: []
  type: TYPE_NORMAL
- en: Order of traversal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In DFS, preference is given to child nodes, which means that after node **a** and
    node **b** are explored, and after node **b** and node **c** are explored, we
    hit a dead end and we backtrack to the previous level. This means that we go back
    to node **b,** and then to its next child, which is node **c**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In BFS, the nodes are covered level by level, and preference is given to siblings.
    This means that after node **a**, nodes **b** and **e** are explored, and after
    that, nodes **c**, **d**, and **f** are explored, as indicated by the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48b567e6-fc7c-457b-86a8-39a1bb338a01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16
  prefs: []
  type: TYPE_NORMAL
- en: Data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In DFS, a stack data structure is used, while in BFS, a queue is used, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92e48e65-c300-4948-bf75-3c159d62630e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17
  prefs: []
  type: TYPE_NORMAL
- en: Memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When recursive DFS is called on node **c**, the implicit stack stores two entries—one
    for node **e**, and one for nodes **c** and **d**. So, the memory used is in the
    order of **d**, where **d** is the depth of the search tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the BFS method is called on node **c**, the queue contains four entries—nodes
    **c**, **d**, **f**, and **g**. So, the memory used is in the order of *b^d*,
    where **b** is the branching factor and **d** is the depth of the search tree.
    Here, the branching factor is **2**, because each internal node has two children:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc83fa38-2bdb-4941-a803-d1b53100c105.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18
  prefs: []
  type: TYPE_NORMAL
- en: Optimal solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose that there are two possible solutions—nodes **d** and **e**. In this
    case, **e** is the optimal solution, because it has the shortest path from root
    node **a**. Here, DFS finds the sub-optimal solution, **d**, before it finds the
    optimal solution, **e**. BFS finds the optimal solution, **e,** before it encounters
    node **d**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c62bb3fa-1473-4c2f-a281-9dc4773ce14c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19
  prefs: []
  type: TYPE_NORMAL
- en: We already saw that DFS uses less memory than BFS, and BFS finds the optimal
    solution. So, the choice of algorithm depends on how big the search space is (in
    this case, you will go for DFS), and whether finding the optimal solution is important
    (in this case, BFS is preferred).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at an application that you can try to develop yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Do it yourself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we discussed the differences between the DFS and BFS
    algorithms. In this section, we'll look at an application that you can try to
    develop yourself. We'll go over the application that you'll try to develop, and
    the changes that are required for the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your aim will be to develop a university navigation application, as shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff8166a6-adaa-4993-8633-24baefbd0683.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that this is the layout of the university, and people can travel along
    horizontal or vertical lines. In this application, the user has to enter the source
    and destination places. For this specific case, we'll assume that a new student
    wants to find his way from the **Bus Stop** to the **AI Lab**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can refer to the classes that we developed for the LinkedIn connection
    feature, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c8c3593-77a2-44f7-ba14-16cef6cbfddb.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21
  prefs: []
  type: TYPE_NORMAL
- en: 'To adapt that code for this application, we need to change the `State` class
    and the graph data. In the `State` class, the `name` property is replaced with
    the `place` property, and `NavigationData` contains the connections between places:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e415b6cb-1a0c-41a9-bb3b-38742ec27c74.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 22
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the three ingredients of the search in detail. To get the answer
    for the initial state, we can ask ourselves the question, *where do we start searching
    from?* In this case, it's the **Bus Stop**. So, `successorFunction` should return
    all of the connected places. For example, if the current place is **Car Park**,
    then this function should return the **Library**, the **Store**, and the **Maths
    Building**. To get the answer for the goal function, we should ask ourselves the
    question, *how will we know when we have found the solution?* For this application,
    the function should return true if the place is the **AI Lab**; for example, if
    the current place is the **Canteen**, then it should return false, and if the
    current place is the **AI Lab**, then it should return true.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and try it out for yourself!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, to help you understand the BFS algorithm, we revisited the
    concepts of state and node. You learned about the graph and queue data structures,
    and we discussed the differences between the DFS and BFS algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll be learning about the heuristic search algorithm.
    Instead of giving preference to child or sibling nodes, this method gives preference
    to the nodes that are closest to the goal state; the term **heuristic** refers
    to the measure of how close the nodes are to the goal state.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the link [https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf](https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf) for
    the colored images of this chapter.
  prefs: []
  type: TYPE_NORMAL
