- en: Understanding the Depth-First Search Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Search algorithms have various applications in industrial and research-based
    AI solutions, related to computer vision, machine learning, and robotics. As we
    progress through the chapters in this book, we will teach you how to use AI in
    search applications. Searching is something that we do every day, whether we are
    searching for a song in our filesystem, searching for a friend or colleague on
    a social network, or finding the best route to a destination. In this chapter,
    you will learn about the **Depth-First Search **(**DFS**) algorithm and develop
    a file search application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and setting up libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing file search applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formulation of the search problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building search trees with nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacks and DFS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursive DFS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and setting up libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get into the basic concepts of searching, we will take a look at
    the following libraries that have to be installed and how to install them in Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**: You can download and install Python libraries from [https://www.python.org/downloads/](https://www.python.org/downloads/),
    depending on your operating system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graphviz**: This open source graph visualization software can be downloaded
    from [http://graphviz.org/download/](http://graphviz.org/download/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pip**: The tools for installing Python packages are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pydot**: A Python interface to Graphviz''s DOT language'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matplotlib**: This is a Python 2D plotting library'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the steps in the following section to install the preceding libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for setting up Python are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For the applications in this book, we'll be using Python 2.7.6, which we can
    download from [https://www.python.org/downloads/](https://www.python.org/downloads/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once an appropriate installer has been downloaded, double-click on it and go
    ahead with the default options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Based on your operating system, select the Python installer to download, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a69f6903-1c5b-4389-8ab6-7a57d3fd8060.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the location where Python will be installed;
    make a note of this location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d654d4e8-ce32-49b9-8ccd-376ea8c70543.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2
  prefs: []
  type: TYPE_NORMAL
- en: Now, Python will be installed.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to add Python's path to the Path environment variable. In the System
    Properties | Advanced tab, click on the Environment Variables... button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Environment Variables… window, go to System variables | Path and add
    the Python location that you made a note of in step 4 (which is `C:\Python27` in
    our case).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, to check whether Python works, open the Command Prompt and type in the
    `python -- version` command. You will get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a3add63b-bf93-4f72-b373-1d1d30dd67d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3
  prefs: []
  type: TYPE_NORMAL
- en: The output shown in the preceding screenshot confirms that Python has been installed
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your OS, Python might already be installed.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Graphviz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps describe how to set up Graphviz:'
  prefs: []
  type: TYPE_NORMAL
- en: We can download the graph visualization software from [https://graphviz.gitlab.io/download/](https://graphviz.gitlab.io/download/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we are using Windows, we select the option that says Stable 2.38 Windows
    install packages, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22dc30da-0297-4cc3-ae22-084a6b1ea628.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the `.msi` downloadable file, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3024418-040a-4e8a-b209-048d6ebc6b3d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Graphviz executable has downloaded, go ahead and install the file
    with the default options; again, make a note of the path, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ae569a58-5e7c-4210-b63d-317742b8a89f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add Graphviz''s `bin` folder to the path variable, as we did when
    installing Python in the previous section. Then, copy the location where Graphviz
    is installed and append `\bin`, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/808cf99e-6ab7-4f65-bfe7-ee2656286d14.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate whether this library has been installed properly, open a new Command
    Prompt window and type the `dot -V` command, and you will get the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f2250773-1e65-431f-b114-355718b635fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8
  prefs: []
  type: TYPE_NORMAL
- en: The output shown in the preceding screenshot confirms that Graphviz has been
    installed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Installing pip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for installing `pip` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To install `pip`, you need to download the `get-pip.py` file from [https://bootstrap.pypa.io/get-pip.py](https://bootstrap.pypa.io/get-pip.py),
    and make a note of the path where the file is located. In my case, the file is
    located at `Documents\ai\softwares`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Command Prompt and go to the `Documents\ai\softwares` folder by using
    the `cd` command, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2243f76b-e104-4999-81f8-fb565ef2309f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `dir` command to take a look at the contents of this folder, where
    you will see `get-pip.py`, shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/836efaf0-29f1-4d98-9a4a-d7db0d3d16fd.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll run the `python get-pip.py` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's add Python's `scripts` folder to the Path environment variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open another Command Prompt window and test the installation of `pip` by typing
    the `pip --version` command. Upon successful installation, you will get the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9bf3bf4a-7a5c-4267-913f-aa551af882a4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `pip` has installed, you can install `pydot` by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, install `matplotlib` by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check whether the libraries have been installed properly by using the
    `import` command in Python''s interpreter, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4a0338f6-f0f9-4095-9aa5-5150ca6cd333.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're done installing the libraries that we will need in Windows for this
    book . In the next topic, we will look at how we can go about developing a file
    search application.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to file searching applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In file managers, file searching is used to find files with specific names.
    In IDEs, file searching is used to find program files with specific code text.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this topic, we''ll develop the first example in order to find a file named
    `f211.txt`. The folder structure is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed824895-a7c2-4a7c-85c4-3f8515362903.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13
  prefs: []
  type: TYPE_NORMAL
- en: 'This folder structure can be represented as a tree, as shown in the following
    diagram; the file that we''re trying to find is shown with a green border:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccfcc91d-f6a5-4b22-b0aa-2851f5f318c5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and look at how file searching will work to find this file:'
  prefs: []
  type: TYPE_NORMAL
- en: File searching starts in the **current directory**; it opens the first folder
    inside of that (**d1**) and opens the first folder in **d1** (**d11**). Inside
    of **d11,** it compares all of the filenames.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since there's no more content inside of **d11**, the algorithm gets out of **d11**,
    goes inside of **d1**, and goes for the next folder, which is **d12**, comparing
    all of its files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, it moves outside of **d12** and goes for the next folder inside of **d1** (**f11**),
    and then the next folder (**f12**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the search algorithm has covered all of the contents inside of the **d1**
    folder. So, it gets out of **d1 **and goes for the next folder inside of the **current
    directory**, which is **d2**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside of **d2**, it opens the first folder (**d21**). Inside of **d21**, it
    compares all of the files, and we find the **f211** file that we're looking for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you refer to the preceding folder structure, you will see that there's a
    pattern that is being repeated. When we reached **f111**, the algorithm had explored
    the leftmost part of the tree, upto its maximum depth. Once the maximum depth
    was reached, the algorithm backtracked to the previous level and went for the
    next subtree to the right. Again, in this case, the leftmost part of the subtree
    is explored, and, when we reach the maximum depth, the algorithm goes for the
    next subtree. This process is repeated until the file that we are searching for
    is found.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how the search algorithm functions logically, in the
    next topic, we will go through the main ingredients of searching, which are used
    for performing searching in this application.
  prefs: []
  type: TYPE_NORMAL
- en: Basic search concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand the functionality of search algorithms, we first need to understand
    basic searching concepts, such as the state, the ingredients of a search, and
    the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**State**: The state is defined as the space where the search process takes
    place. It basically answers the question—*what are we searching for?* For example,
    in a navigation application, a state is a place. In our search application, a
    state is a file or folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ingredients of a search**: There are three main ingredients in a search algorithm.
    These ingredients are as follows, using the example of a treasure hunt:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Initial state**: This answers the question—*where do we begin our search?*
    In our example, the initial state would be the location where we begin our treasure
    hunt.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Successor function**: This answers the question—*how do we explore from the
    initial state?* In our example, the successor function should return all of the
    paths from the location where we began our treasure hunt.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Goal function**: This answers the question—*how will we know when we''ve
    found the solution?* In our example, the goal function returns true if you''ve
    found the place marked as the treasure.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The search ingredients are illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52509359-a71b-4cda-bfe1-39100207b526.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15
  prefs: []
  type: TYPE_NORMAL
- en: '**Node**: A node is the basic unit of a tree. It may consist of data or links
    to other nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formulating the search problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a file searching application, we start searching from the current directory,
    so our initial state is the current directory. Now, let''s write the code for
    the state and the initial state, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c442b940-76bb-45e9-9208-82e45997e897.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we have created two Python modules, `State.py`
    and `StateTest.py`. The `State.py` module will contain the code for the three
    search ingredients mentioned in the previous section. The `StateTest` module is
    a file where we can test these ingredients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create a constructor and a function that returns an initial
    state, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the following apply:'
  prefs: []
  type: TYPE_NORMAL
- en: We have the constructor (the constructor name) and we have created a property
    called `path`, which stores the actual path of the state. In the preceding code
    example, we can see that the constructor takes `path` as an argument. The `if...else`
    block suggests that if the path is not provided, it will initialize the state
    as the initial state, and if the path is provided, it will create a state with
    that particular path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getInitialState()` function returns the current working directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s go ahead and create some sample states, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have created the following three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`initialState`, which points to the current directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interState`, which is the intermediate function that points to the `d21` folder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`goalState`, which points to the `f211.txt` folder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will look at the `successor` function. If we''re in a particular folder,
    the `successor` function should return the folders and files inside of that folder,
    and, if you''re currently looking at a file, it should return an empty array. Considering
    the following diagram, if the current state is `d2`, it should return paths to
    the `d21` and `d22` folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f23a39a5-3c83-4357-92f0-0dd93bc88518.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the preceding function with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding  function checks whether the current path is a directory. If it
    is a directory, it gets a sorted list of all of the folders and files inside it,
    and prepends the current path to them. If it is a file, it returns an empty array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s test this function with some input. Open the `StateTest` module
    and take a look at the successors to the initial state and intermediate state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, the successors to the current directory (or
    the initial state) are the LiClipse project files and the folders `d1`, `d2`,
    and `d3`, and the successor of the intermediate state is the `f211.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of running the preceding code is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8e41019-2d22-46c1-ac85-9392e155af13.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will look at the goal function. So, how do we know that we have
    found the target file, `f211.txt`? Our goal function should return `False` for
    the `d21`  folder, and `True` for the `f211.txt` file . Let''s look at how to
    implement this function in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, the function `checkGoalState()` is our goal
    function; this checks whether the current path is a directory. Now, since we are
    looking for a file, this returns `False` if it's a directory. If it is a file,
    it extracts the filename from the path. The filename is the substring of the path
    from the last occurrence of a slash to the end of the string. So, we extract the
    filename and compare it with `f211.txt`. If they match, we return `True`; otherwise,
    we return `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, let''s test this function for the states that we''ve created. To do
    so, open the `StateTest` module, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7987435d-366a-4c80-9456-cee0ed4dcf01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the function returns `False` for the current directory, it returns
    `False` for the `d21` folder, and it returns `True` for the `f211.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the three ingredients in search algorithms, in the next
    section, we will look at building search trees with nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Building trees with nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this topic, you'll be learning how to create a search tree with nodes. We
    will look at the concepts of states and nodes and the properties and methods of
    the node class, and we will show you how to create a tree with node objects. In
    our application, while the state is the path of the file or folder we are processing
    (for example, the current directory), the node is a node in the search tree (for
    example, the current directory node).
  prefs: []
  type: TYPE_NORMAL
- en: 'A node has many properties, and one of them is the state. The other properties
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Depth**: This is the level of the node in the tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference to the parent node**: This consists of links to the parent node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**References to the child nodes**: This consists of links to the child nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at a few examples, in order to understand these concepts more clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of these concepts in the **current directory** node is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Depth**: 0'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference to parent node**: None'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**References to children nodes**: d1, d2, d3'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/b022eb2a-8994-490d-aa23-ed2490d9fc43.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of these concepts in node **d3** is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Depth**: 1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference to parent node**: Current directory node'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference to children nodes**: f31'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/49246848-b68a-416b-bbc4-f52529a620ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the concepts for these file node **f111** is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Depth**: 3'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference to parent node**: d11'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference to children node**: []'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/a36b6308-e459-4f2b-ad3b-dca28765cdca.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 22
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a class called `Node`, which includes the four properties that
    we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, we have created a class called `Node`, and
    this class has a constructor that takes `state` as an argument. The `state` argument
    is assigned to the `state` property of this node, and the other properties are
    initialized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The depth is set to `0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reference to children is set to a blank array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reference to parent nodes is set to `None`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This constructor creates a blank node for the search tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from the constructor, we need to create the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addChild()`:  This method adds a child node under a parent node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`printTree()`: This method prints a tree structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code for the `addChild()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `addChild()` method takes the child node as an argument; the child node
    is added to the children array, and the parent of the child node is assigned as
    its parent node. The depth of the child node is the parent node plus one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this in the form of a block diagram for a clearer understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fa34ee8-15ae-447b-a6c7-b4c80f899674.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that we're adding node **f31** under node **d3**. So, **f31**
    will be added to the `children` property of **d3**, and the parent property of
    **f31** will be assigned as **d3**. In addition to that, the depth of the child
    node will be one more than the parent node. Here, the depth of node **d3** is
    **1**, so the depth of **f31** is **2**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `printTree` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, this function prints the depth and the state of the current node; then,
    it looks through all of its children and calls the `printTree` method for each
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to create the search tree shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3f71cb8-67c0-40fc-b0c4-da5cf715a657.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding diagram, as a root node we have the **Current directory**
    node; under that node, we have nodes **d1**, **d2**, and **d3**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a `NodeTest` module, which will create the sample search tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, we created an initial state by creating a `State`
    object with no arguments, and then we passed this initial state to the `Node`
    class constructor, which creates a root node. To get the folders `d1`, `d2`, and
    `d3`, we called the `successorFunction` method on the initial state and we looped
    each of the child states (to create a node from each of them); we added each child
    node under the root node.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we execute the preceding code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dda8ba44-3175-4f65-b077-43ce41ce39cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the current directory has a depth of `0`, and all of its
    contents have a depth `1`, including `d1`, `d2`, and `d3`.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have successfully built a sample search tree using the `Node`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, you'll be learning about the stack data structure, which
    will help us to create the DFS algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Stack data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **stack** is a pile of objects placed one atop another (for example, a stack
    of books, a stack of clothes, or a stack of papers). There are two stacking operations:
    one for adding items to a stack, and one for removing items from a stack.'
  prefs: []
  type: TYPE_NORMAL
- en: The operation used for adding items to a stack is called **push**, while the
    operation used for removing items is called as **pop**. Items are popped in the
    reverse order to push; that is why this data structure is called **last-in first-out**
    (**LIFO**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s experiment with the stack data structure in Python. We''ll be using
    the list data structure as a stack in Python. We''ll use the `append()` method
    to push items to the stack and the `pop()` method to pop them out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, we have created an empty stack and we are printing
    it out. One by one, we are adding the numbers `1`, `2`, `3`, and `4` to the stack
    and printing them out. Then, one by one, we are popping the items and printing
    them out; finally, we are printing the remaining stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute the preceding code, `Stack.py`, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bb18db6-a7fe-4142-a56f-fb41715ed011.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 26
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we have an empty stack, and when items `1`, `2`, `3`, and `4` are
    pushed to the stack, we have `4` at the top of the stack. Now, when you pop the
    items out, the first one to come out is `4`, then `3`, then `2`, and then `1`;
    this is the reverse of the order of entry. Then, finally, we have an empty stack.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are clear on how stacks work, let's use these concepts to actually
    create a DFS algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The DFS algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand the basic concepts of searching, we'll look at how DFS
    works by using the three basic ingredients of search algorithms—the initial state,
    the successor function, and the goal function. We will use the stack data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first represent the DFS algorithm in the form of a flowchart, to offer
    a better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0aac8c3-b1e3-4226-aece-bc2a3276b23d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 27
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps in the preceding flowchart are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a root node using the initial state, and we add this to our stack
    and tree
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pop a node from the stack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We check whether it has the goal state; if it has the goal state, we stop our
    search here
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the answer to the condition in step 3 is **No**, then we find the child nodes
    of the pop node, and add them to the tree and stack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We repeat steps 2 to 4 until we either find the goal state or exhaust all of
    the nodes in the search tree
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s apply the preceding algorithm to our filesystem, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e9203c1-f883-4946-b17f-aed016d7cd96.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 28
  prefs: []
  type: TYPE_NORMAL
- en: We create our root node, add it to the search tree, and add it to the stack.
    We pop a node from the stack, which is the **current directory** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **current directory** node doesn't have the goal state, so we find its child
    nodes and add them to the tree and stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we add nodes to the stack, they have to be added in reverse order, so that
    the node on the top of the stack is on the leftmost side of the search tree.
  prefs: []
  type: TYPE_NORMAL
- en: We pop a node from the stack (**d1**); it doesn't have the goal state, so we
    find its child nodes and add it to the tree and stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pop a node from the stack (**d11**); it doesn't have the goal state, so we
    find its child node, add it to the tree and stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pop a node (**f111**); it doesn't have the goal state, and it also doesn't
    have child nodes, so we carry on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pop the next node, **d12**; we find its child nodes and add them to the tree
    and stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pop the next node, **f121**, and it doesn't have any child nodes, so we carry
    on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pop the next node, **f122**, and it doesn't have any child nodes, so we carry
    on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pop the next node, **f11**, and we encounter the same case (where we have
    no child nodes), so we carry on; the same goes for **f12**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pop the next node, **d2**, and we find its child nodes and add them to the
    tree and stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pop the next node, **d21**, and we find its child node and add it to the
    tree and stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pop the next node, **f211**, and we find that it has the goal state, so we
    end our search here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s try to implement these steps in code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have created a Python module called `StackDFS.py`, and it has a method called
    `performStackDFS()`. In this method, we have created an empty stack, which will
    hold all of our nodes, the `initialState`, a root node containing the `initialState`,
    and finally we have added this root node to the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that in `Stack.py`, we wrote a `while` loop to process all of the
    items in the stack. So, in the same way, in this case we will write a `while`
    loop to process all of the nodes in the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, we pop the node from the top of the stack and
    call it `currentNode()`, and then we print it so that we can see the order in
    which the nodes are processed. We check whether the current node has the goal
    state, and if it does, we end our execution here. If it doesn't have the goal
    state, we find its child nodes and add it under `currentNode`, just like we did
    in `NodeTest.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also add these child nodes to the stack, but in reverse order, using
    the following `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when we exit the `while` loop, we print the tree. Upon successful
    execution of the code, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa4c4d6e-6443-4809-9330-f3643fa353f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 29
  prefs: []
  type: TYPE_NORMAL
- en: 'The output displays the order in which the nodes are processed, and we can
    see the first node of the tree. Finally, we encounter our goal state, and our
    search stops:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1bf82a9-481d-46e1-95bd-d597c1f2ef6d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 30
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot displays the search tree. Note that the preceding output
    and the one before it are almost the same. The only difference is that in the
    preceding screenshot, we can find two nodes, `d22` and `d3`, because their parent
    nodes were explored.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive DFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a function calls itself, we say that the function is a **recursive** function.
    Let''s look at the example of the Fibonacci series. It is defined as follows: `f(1)`
    is equal to `1`, `f(2)` is equal to `1`, and for `n` greater than `2`, `f(n)`
    is equal to `f(n-1) + f(n-2)`. Let''s look at the implementation of this function
    in code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have created our function, `fibonacci`, which takes
    a number, `n`, as input. If `n` is less than or equal to `2`, it returns `1`;
    otherwise, it returns `fibonacci(n-1) + fibonacci(n-2)`. Toward the end of the
    code, we have calculated the value of `fibonacci(5)`, which is `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of running the preceding code is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8028501a-a5ef-4830-9278-60900c68c837.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 31
  prefs: []
  type: TYPE_NORMAL
- en: If we want to visualize the recursion tree of the `fibonacci` function, we can
    go to [https://visualgo.net/en/recursion](https://visualgo.net/en/recursion).
    This website has visualizations of various data structures and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The visualization of a recursion tree is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7042a331-bc4a-43a9-9946-7e0d617e9f73.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 32
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, the output that we get here is the same
    as the output we got with the code, and the order in which the nodes were explored
    is similar to DFS.
  prefs: []
  type: TYPE_NORMAL
- en: So, *what happens when function 1 calls function 2?* The program adds a stack
    frame to the program stack. A stack frame contains the local variables in function
    1, the arguments passed to function 1, and the return addresses of function 2
    and function 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the example of the Fibonacci sequence again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c469c95e-871a-4864-891c-063b617ba61c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 33
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the Fibonacci code has been modified for the sake of clarity.
    Suppose that the program is executing the line in bold, **val2 = fibonacci(n-2)**.
    Then, the stack frame created will contain the following values—local variables
    is equal to **val1**, arguments passed is equal to **n**, and return address is
    the address of the code in bold.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the return address points to the unprocessed curve. Because
    in recursion the program stack keeps a stack of unprocessed calls, instead of
    storing nodes in the stack, we will call DFS recursively on the child nodes, so
    that the stack is indirectly maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the steps of recursive DFS in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c4cd97a-bc72-4994-9b8b-24b26481219a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 34
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps in the preceding diagram are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create an initial state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a root node with this initial state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add the root node to the search tree and call DFS on the root node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Recursive DFS is defined as follows: check whether the node has a goal state.
    If yes, then it returns the path; if no, then DFS finds the children node, and
    for each child node DFS adds the node to the tree, finally calling itself on the
    child node.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we will apply the preceding algorithm to our filesystem, the steps for
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ea9aa73-f110-4a16-991e-f669760d0f94.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35
  prefs: []
  type: TYPE_NORMAL
- en: We create the root node and add it to the search tree, and we call DFS on this
    root node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we call DFS on this root node, the function checks whether this node has
    the goal state, and it doesn't, so it finds its children nodes (**d1**, **d2**,
    and **d3**). It takes the first node, **d1**, adds it to the search tree, and
    calls DFS on the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When it calls DFS on **d1**, the function creates a program. When DFS is called
    on **d1**, then the program creates a stack frame and adds it to the program stack.
    In this case, we'll show the remaining nodes to be processed in the `for` loop.
    Here, we're adding **d2** and **d3** in the program stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When DFS is called on **d1**, it finds the children nodes **d11**, **d12**,
    **f11**, and **f12**, and adds **d11** to the search tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It calls DFS on **d11**, and when it does so, it creates an entry in the program
    stack with the unprocessed nodes. Now, when DFS is called on **d11**, it finds
    the child node **f111**, adds **f111** to the search tree, and calls DFS on the
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When DFS is called on **f111,** it has no children nodes, so it returns back;
    when this happens, the program stack is unwounded, which means that the program
    returns execution and processes the last unprocessed nodes in the stack. In this
    case, it starts processing node **d12**. So, the program adds node **d12** to
    the search tree, and calls DFS on **d1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When DFS is called on **d12**, it finds the children nodes **f121** and **f122**.
    It adds node **f121** to the search tree, and calls DFS on it. When DFS is called
    on **f121**, it adds the unprocessed node **f122** to the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When DFS is called on **f121,** it has no children nodes, so again the stack
    is unwounded. So, we process node **f122**. This node is added to the search tree
    and DFS is called on it. So, we continue processing the last node, **f11**, add
    it to the search tree, and call DFS on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we call DFS on **f11,** it has no children nodes, so again the stack is
    unwounded. We continue processing node **f12**, it is added to the search tree,
    and DFS is called on **f12**. We encounter this case, and we continue processing
    node **d2**. We add it to the search tree, and we call DFS on **d2**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we call DFS on **d2,** we find that is has children nodes: **d21** and
    **d22**. We add **d21** to the search tree, and we call DFS on **d21**; when we
    call DFS on **d21,** it creates an entry for **d22**. In the program stack, when
    DFS is called on **d21,** we find that it has a child, **f211**. This node is
    added to the search tree and DFS is called on **f211**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When DFS is called an **f211**, we realize that it has the goal state, and we
    end our search process here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at how we can implement recursive DFS, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, we have created a Python module called `RecursiveDFS.py`.
    It has a class called `RecursiveDFS`, and, in the constructor, it has a property
    called `found`, which indicates whether the solution has been found. We'll look
    at the significance of the `found` variable later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a method called `search`, in which we are creating the `initialState`,
    and the `rootNode` we''re calling the DFS function on the `rootNode`. Finally,
    we print the tree after we perform the DFS search, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DFS` function can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the solution has not been found, then the node that is being processed is
    printed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We check whether the node has the goal state, and if it does, we print that
    the goal state has been reached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it doesn't have the goal state, we find the child states; next, we create
    the child node for each child state, we add them to the tree, and we call `DFS`
    on each of the child nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s execute the program; we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17689949-b959-4be7-b181-6193c705ce0b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 36
  prefs: []
  type: TYPE_NORMAL
- en: 'When we processed `f211`, we reached the goal state, but here we have three
    extra lines; this is because these nodes have been added to the program stack.
    To remove these lines, we have created a variable called `found`, so that when
    the goal state is found, the variable will be set to `True`. Once we encounter
    `f211`, the remaining nodes in the program stack will not be processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ed5768f-f868-4d3b-9929-514e6a724a7f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 37
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run this code again and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3096f63-5186-404a-bb0a-790a9bb10ec0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 38
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, once we've processed `f211` and reached the goal state, the
    node processing stops. The output of the `printTree` function is the same as what
    we store in `StackDFS.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how DFS can be made into a recursive function, in the
    next topic we will look at an application that you can develop by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Do it yourself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at an application that you can develop by yourself.
    We will take a look at a new application and discuss the changes that are required.
    In the *Introduction to file search applications* section, we discussed two applications
    of file searching; now, we will develop the second type of example. Our aim is
    to develop a search application that is able to find program files containing
    specific program text.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code for recursive DFS, we mainly used three classes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**State**: This has the three main ingredients of the search process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node**: This is used to build search trees'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recursive** **DFS**: This has the actual algorithm implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose that we want to adapt this code or file search application to new application.
    We will need to change three methods: `getInitialState`, `successorFunction`,
    and `checkGoalState`. For the new application of program searching, you will need
    to change just one method: `checkGoalState`.'
  prefs: []
  type: TYPE_NORMAL
- en: In your new `checkGoalState` function, you will need to open the file, read
    the contents of the file line by line, and perform a substring check or regular
    expression check. Lastly, based on the results of the check, you will return true
    or false.
  prefs: []
  type: TYPE_NORMAL
- en: So, go ahead and try it out for yourself!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we looked at four basic concepts related to searching: the
    state, which is the condition of our search process; the node, which is used for
    building a search tree; the stack, which helps to traverse the search tree and
    decides the order in which the nodes are traversed; and recursion, which eliminates
    the need for an explicit stack. You also learned about DFS, which explores the
    search tree in a depth-first order.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about **breadth-first search** (**BFS**),
    which explores a search tree in a breadth-first order. See you there!
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the link [https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf](https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf) for
    the colored images of this chapter.
  prefs: []
  type: TYPE_NORMAL
