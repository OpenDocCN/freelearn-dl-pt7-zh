<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Data Access and Distributed Processing for IoT</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">Data is everywhere: images, speech, text, weather information, the speed of your car, your last EMI, changing stock prices. </span><span class="koboSpan" id="kobo.2.2">With the integration of </span><strong><span class="koboSpan" id="kobo.3.1">Internet of Things</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">IoT</span></strong><span class="koboSpan" id="kobo.6.1">) systems, the amount of data produced has increased many-fold; </span><span><span class="koboSpan" id="kobo.7.1">an example is sensor readings, which could be taken for room temperature, soil alkalinity, and more</span></span><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">This data is stored and made available in various formats. </span><span><span class="koboSpan" id="kobo.9.1">In this chapter, we will learn how to read, save, and process data in some popular formats. </span><span class="koboSpan" id="kobo.9.2">Specifically, you will do the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">Access data in TXT format</span></li>
<li><span class="koboSpan" id="kobo.11.1">Read and write csv-formatted data via the CSV, pandas, and NumPy modules</span></li>
<li><span class="koboSpan" id="kobo.12.1">Access JSON data using JSON and pandas</span></li>
<li><span class="koboSpan" id="kobo.13.1">Learn to work with the HDF5 format using PyTables, pandas, and h5py</span></li>
<li><span class="koboSpan" id="kobo.14.1">Handle SQL databases using SQLite and MySQL</span></li>
<li><span class="koboSpan" id="kobo.15.1">Handle NoSQL using MongoDB</span></li>
<li><span class="koboSpan" id="kobo.16.1">Work with Hadoop's Distributed File System</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">TXT format</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">One of the simplest and common formats for storing data is the TXT format; many IoT sensors log sensor readings with different timestamps in the simple </span><kbd><span class="koboSpan" id="kobo.3.1">.txt</span></kbd><span class="koboSpan" id="kobo.4.1"> file format. </span><span class="koboSpan" id="kobo.4.2">Python provides built-in functions for creating, reading, and writing into TXT files. </span></p>
<p><span><span class="koboSpan" id="kobo.5.1"> We can access TXT files in Python itself without using any module; the data, in this case, is of the string type, and you will need to transform it to other types to use it. </span><span class="koboSpan" id="kobo.5.2">Alternatively, we can use NumPy or pandas.</span></span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using TXT files in Python</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Python has built-in functions that read and write into TXT files. </span><span class="koboSpan" id="kobo.2.2">The complete functionality is provided using four sets of functions: </span><kbd><span class="koboSpan" id="kobo.3.1">open()</span></kbd><span class="koboSpan" id="kobo.4.1">, </span><kbd><span class="koboSpan" id="kobo.5.1">read()</span></kbd><span class="koboSpan" id="kobo.6.1">, </span><kbd><span class="koboSpan" id="kobo.7.1">write()</span></kbd><span class="koboSpan" id="kobo.8.1">, and </span><kbd><span class="koboSpan" id="kobo.9.1">close()</span></kbd><span class="koboSpan" id="kobo.10.1">. </span><span class="koboSpan" id="kobo.10.2">As the names suggest, they are used to open a file, read from a file, write into a file, and finally close it. </span><span class="koboSpan" id="kobo.10.3">If you are dealing with string data (text), this is the best choice. </span><span class="koboSpan" id="kobo.10.4">In this section, we will use </span><kbd><span class="koboSpan" id="kobo.11.1">Shakespeare</span></kbd><span class="koboSpan" id="kobo.12.1"> plays in TXT form; the file can be downloaded from </span><span><span class="koboSpan" id="kobo.13.1">the </span></span><span class="koboSpan" id="kobo.14.1">MIT site: </span><a href="https://ocw.mit.edu/ans7870/6/6.006/s08/lecturenotes/files/t8.shakespeare.txt"><span class="koboSpan" id="kobo.15.1">https://ocw.mit.edu/ans7870/6/6.006/s08/lecturenotes/files/t8.shakespeare.txt</span></a><span class="koboSpan" id="kobo.16.1">. </span></p>
<p><span class="koboSpan" id="kobo.17.1">We define the following variables to access the data:</span></p>
<pre><span class="koboSpan" id="kobo.18.1">data_folder = '../../data/Shakespeare'</span><br/><span class="koboSpan" id="kobo.19.1">data_file = 'alllines.txt'</span></pre>
<p><span class="koboSpan" id="kobo.20.1">The first step here is to open the file:</span></p>
<pre><span class="koboSpan" id="kobo.21.1">f = open(data_file)</span></pre>
<p><span class="koboSpan" id="kobo.22.1">Next, we read the whole file; we can use the </span><kbd><span class="koboSpan" id="kobo.23.1">read </span></kbd><span class="koboSpan" id="kobo.24.1">function, which will read the whole file as one single string:</span></p>
<pre><span class="koboSpan" id="kobo.25.1">contents = f.read()</span></pre>
<p><span class="koboSpan" id="kobo.26.1">This reads the whole file (consisting of 4,583,798 characters) into the </span><kbd><span class="koboSpan" id="kobo.27.1">contents</span></kbd> <span><span class="koboSpan" id="kobo.28.1">variable. </span></span><span class="koboSpan" id="kobo.29.1">Let's explore the contents of the </span><kbd><span><span class="koboSpan" id="kobo.30.1">contents</span></span></kbd><span class="koboSpan" id="kobo.31.1"> variable; the following command will print the first </span><kbd><span class="koboSpan" id="kobo.32.1">1000</span></kbd><span class="koboSpan" id="kobo.33.1"> characters:</span></p>
<pre><span class="koboSpan" id="kobo.34.1">print(contents[:1000])</span></pre>
<p><span class="koboSpan" id="kobo.35.1">The preceding code will print the output as follows:</span></p>
<pre><span class="koboSpan" id="kobo.36.1">"ACT I"</span><br/><span class="koboSpan" id="kobo.37.1">"SCENE I. </span><span class="koboSpan" id="kobo.37.2">London. </span><span class="koboSpan" id="kobo.37.3">The palace."</span><br/><span class="koboSpan" id="kobo.38.1">"Enter KING HENRY, LORD JOHN OF LANCASTER, the EARL of WESTMORELAND, SIR WALTER BLUNT, and others"</span><br/><span class="koboSpan" id="kobo.39.1">"So shaken as we are, so wan with care,"</span><br/><span class="koboSpan" id="kobo.40.1">"Find we a time for frighted peace to pant,"</span><br/><span class="koboSpan" id="kobo.41.1">"And breathe short-winded accents of new broils"</span><br/><span class="koboSpan" id="kobo.42.1">"To be commenced in strands afar remote."</span><br/><span class="koboSpan" id="kobo.43.1">"No more the thirsty entrance of this soil"</span><br/><span class="koboSpan" id="kobo.44.1">"will daub her lips with her own children's blood,"</span><br/><span class="koboSpan" id="kobo.45.1">"Nor more will trenching war channel her fields,"</span><br/><span class="koboSpan" id="kobo.46.1">"Nor bruise her flowerets with the armed hoofs"</span><br/><span class="koboSpan" id="kobo.47.1">"Of hostile paces: those opposed eyes,"</span><br/><span class="koboSpan" id="kobo.48.1">"Which, like the meteors of a troubled heaven,"</span><br/><span class="koboSpan" id="kobo.49.1">"All of one nature, of one substance bred,"</span><br/><span class="koboSpan" id="kobo.50.1">"Did lately meet in the intestine shock"</span><br/><span class="koboSpan" id="kobo.51.1">"And furious close of civil butchery"</span><br/><span class="koboSpan" id="kobo.52.1">"will now, in mutual well-beseeming ranks,"</span><br/><span class="koboSpan" id="kobo.53.1">"March all one way and be no more opposed"</span><br/><span class="koboSpan" id="kobo.54.1">"Against acquaintance, kindred and allies:"</span><br/><span class="koboSpan" id="kobo.55.1">"The edge of war, like an ill-sheathed knife,"</span><br/><span class="koboSpan" id="kobo.56.1">"No more will cut his master. </span><span class="koboSpan" id="kobo.56.2">Therefore, friends,"</span><br/><span class="koboSpan" id="kobo.57.1">"As far as to the sepulchre of Christ,"</span><br/><span class="koboSpan" id="kobo.58.1">"Whose</span></pre>
<p><span><span class="koboSpan" id="kobo.59.1">If the TXT files contain numeric data, it is better to use NumPy; if data is mixed, pandas is the best choice.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">CSV format</span></h1>
                </header>
            
            <article>
                
<p><strong><span class="koboSpan" id="kobo.2.1">C</span></strong><strong><span class="koboSpan" id="kobo.3.1">omma-separated value</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">CSV</span></strong><span class="koboSpan" id="kobo.6.1">) files are the most popular formats for storing tabular data generated by IoT systems. </span><span class="koboSpan" id="kobo.6.2">In a </span><kbd><span class="koboSpan" id="kobo.7.1">.csv </span></kbd><span class="koboSpan" id="kobo.8.1">file, the values of the records are stored in plain-text rows, with each row containing the values of the fields separated by a separator. </span><span class="koboSpan" id="kobo.8.2">The separator is a comma by default but can be configured to be any other character. </span><span class="koboSpan" id="kobo.8.3">In this section, we will learn how to use data from CSV files with Python's </span><kbd><span class="koboSpan" id="kobo.9.1">csv</span></kbd><span class="koboSpan" id="kobo.10.1">, </span><kbd><span class="koboSpan" id="kobo.11.1">numpy</span></kbd><span class="koboSpan" id="kobo.12.1">, and </span><kbd><span class="koboSpan" id="kobo.13.1">pandas</span></kbd><span class="koboSpan" id="kobo.14.1"> modules. </span><span class="koboSpan" id="kobo.14.2">We will use the </span><kbd><span class="koboSpan" id="kobo.15.1">household_power_consumption</span></kbd><span class="koboSpan" id="kobo.16.1"> data file. </span><span class="koboSpan" id="kobo.16.2">The file can be downloaded from the following GitHub link: </span><a href="https://github.com/ahanse/machlearning/blob/master/household_power_consumption.csv"><span class="koboSpan" id="kobo.17.1">https://github.com/ahanse/machlearning/blob/master/household_power_consumption.csv</span></a><span class="koboSpan" id="kobo.18.1">. </span><span class="koboSpan" id="kobo.18.2">To access the data files, we define the following variables:</span></p>
<pre><span class="koboSpan" id="kobo.19.1">data_folder = '../../data/household_power_consumption' </span><br/><span class="koboSpan" id="kobo.20.1">data_file = 'household_power_consumption.csv'</span></pre>
<p><span class="koboSpan" id="kobo.21.1">Generally, to quickly read the data from CSV files, use the Python </span><kbd><span class="koboSpan" id="kobo.22.1">csv</span></kbd><span class="koboSpan" id="kobo.23.1"> module; however, if the data needs to be interpreted as a mix of date, and numeric data fields, it's better to use the pandas package. </span><span class="koboSpan" id="kobo.23.2">If the data is only numeric, NumPy is the most appropriate package.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Working with CSV files with the csv module</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In Python, the </span><kbd><span class="koboSpan" id="kobo.3.1">csv</span></kbd><span class="koboSpan" id="kobo.4.1"> module provides classes and methods for reading and writing CSV files. </span><span class="koboSpan" id="kobo.4.2">The </span><kbd><span class="koboSpan" id="kobo.5.1">csv.reader</span></kbd><span class="koboSpan" id="kobo.6.1"> </span><span><span class="koboSpan" id="kobo.7.1">method</span></span><span><span class="koboSpan" id="kobo.8.1"> </span></span><span><span class="koboSpan" id="kobo.9.1">creates a reader object from which rows can be read iteratively. </span><span class="koboSpan" id="kobo.9.2">Each time a row is read from the file, the reader object returns a list of fields. </span><span class="koboSpan" id="kobo.9.3">For example, the following code demonstrates reading the data file and printing rows:</span></span></p>
<pre><span class="koboSpan" id="kobo.10.1">import csv</span><br/><span class="koboSpan" id="kobo.11.1">import os</span><br/><br/><span class="koboSpan" id="kobo.12.1">with open(os.path.join(data_folder,data_file),newline='') as csvfile:</span><br/><span class="koboSpan" id="kobo.13.1">   csvreader = csv.reader(csvfile)</span><br/><span class="koboSpan" id="kobo.14.1">   for row in csvreader:</span><br/><span class="koboSpan" id="kobo.15.1">     print(row)</span></pre>
<p><span class="koboSpan" id="kobo.16.1">The rows are printed as a list of field values:</span></p>
<pre><span class="koboSpan" id="kobo.17.1">['date', 'time', 'global_active_power', 'global_reactive_power', 'voltage', 'global_intensity', 'sub_metering_1', 'sub_metering_2', 'sub_metering_3'] ['0007-01-01', '00:00:00', '2.58', '0.136', '241.97', '10.6', '0', '0', '0'] ['0007-01-01', '00:01:00', '2.552', '0.1', '241.75', '10.4', '0', '0', '0'] ['0007-01-01', '00:02:00', '2.55', '0.1', '241.64', '10.4', '0', '0', '0']</span></pre>
<p><span class="koboSpan" id="kobo.18.1">The </span><kbd><span class="koboSpan" id="kobo.19.1">csv.writer</span></kbd><span class="koboSpan" id="kobo.20.1"> </span><span><span class="koboSpan" id="kobo.21.1">method</span></span><span><span class="koboSpan" id="kobo.22.1"> </span></span><span><span class="koboSpan" id="kobo.23.1">returns an object that can be used to write rows to a file. </span><span class="koboSpan" id="kobo.23.2">As an example, the following code writes the first 10 rows of the file to a temporary file and then prints it:</span></span></p>
<pre><span class="koboSpan" id="kobo.24.1"># read the file and write first ten rows</span><br/><span class="koboSpan" id="kobo.25.1">with open(os.path.join(data_folder, data_file), newline='') as csvfile, \</span><br/><span class="koboSpan" id="kobo.26.1">        open(os.path.join(data_folder, 'temp.csv'), 'w', newline='') as tempfile:</span><br/><span class="koboSpan" id="kobo.27.1">    csvreader = csv.reader(csvfile)</span><br/><span class="koboSpan" id="kobo.28.1">    csvwriter = csv.writer(tempfile)</span><br/><span class="koboSpan" id="kobo.29.1">    for row, i in zip(csvreader, range(10)):</span><br/><span class="koboSpan" id="kobo.30.1">        csvwriter.writerow(row)</span><br/>        <br/><span class="koboSpan" id="kobo.31.1"># read and print the newly written file</span><br/><span class="koboSpan" id="kobo.32.1">with open(os.path.join(data_folder, 'temp.csv'), newline='') as tempfile:</span><br/><span class="koboSpan" id="kobo.33.1">    csvreader = csv.reader(tempfile)</span><br/><span class="koboSpan" id="kobo.34.1">    for row in csvreader:</span><br/><span class="koboSpan" id="kobo.35.1">        print(row)</span></pre>
<p><span class="koboSpan" id="kobo.36.1">The </span><kbd><span class="koboSpan" id="kobo.37.1">delimiter</span></kbd><span class="koboSpan" id="kobo.38.1"> field and the </span><kbd><span class="koboSpan" id="kobo.39.1">quoting </span></kbd><span class="koboSpan" id="kobo.40.1">field characters are important attributes that you can set while creating </span><kbd><span class="koboSpan" id="kobo.41.1">reader</span></kbd><span class="koboSpan" id="kobo.42.1"> and </span><kbd><span class="koboSpan" id="kobo.43.1">writer</span></kbd><span class="koboSpan" id="kobo.44.1"> objects.</span></p>
<p><span class="koboSpan" id="kobo.45.1">By default, the </span><kbd><span class="koboSpan" id="kobo.46.1">delimiter</span></kbd><span class="koboSpan" id="kobo.47.1"> field is </span><kbd><span class="koboSpan" id="kobo.48.1">,</span></kbd><span class="koboSpan" id="kobo.49.1"> and the other delimiters are specified with the </span><kbd><span class="koboSpan" id="kobo.50.1">delimiter</span></kbd><span class="koboSpan" id="kobo.51.1"> </span><span><span class="koboSpan" id="kobo.52.1">argument</span></span><span><span class="koboSpan" id="kobo.53.1"> </span></span><span><span class="koboSpan" id="kobo.54.1">to the</span></span> <kbd><span class="koboSpan" id="kobo.55.1">reader</span></kbd> <span><span class="koboSpan" id="kobo.56.1">or</span></span> <kbd><span class="koboSpan" id="kobo.57.1">writer</span></kbd> <span><span class="koboSpan" id="kobo.58.1">functions. </span><span class="koboSpan" id="kobo.58.2">For example, the following code saves the file with</span></span> <kbd><span class="koboSpan" id="kobo.59.1">|</span></kbd><span><span class="koboSpan" id="kobo.60.1"> as</span></span> <kbd><span class="koboSpan" id="kobo.61.1">delimiter</span></kbd><span><span class="koboSpan" id="kobo.62.1">:</span></span></p>
<pre><span class="koboSpan" id="kobo.63.1">    # read the file and write first ten rows with '|' delimiter</span><br/><span class="koboSpan" id="kobo.64.1">with open(os.path.join(data_folder, data_file), newline='') as csvfile, \</span><br/><span class="koboSpan" id="kobo.65.1">        open(os.path.join(data_folder, 'temp.csv'), 'w', newline='') as tempfile:</span><br/><span class="koboSpan" id="kobo.66.1">    csvreader = csv.reader(csvfile)</span><br/><span class="koboSpan" id="kobo.67.1">    csvwriter = csv.writer(tempfile, delimiter='|')</span><br/><span class="koboSpan" id="kobo.68.1">    for row, i in zip(csvreader, range(10)):</span><br/><span class="koboSpan" id="kobo.69.1">        csvwriter.writerow(row)</span><br/>        <br/><span class="koboSpan" id="kobo.70.1"># read and print the newly written file</span><br/><span class="koboSpan" id="kobo.71.1">with open(os.path.join(data_folder, 'temp.csv'), newline='') as tempfile:</span><br/><span class="koboSpan" id="kobo.72.1">    csvreader = csv.reader(tempfile, delimiter='|')</span><br/><span class="koboSpan" id="kobo.73.1">    for row in csvreader:</span><br/><span class="koboSpan" id="kobo.74.1">        print(row)</span></pre>
<p><span class="koboSpan" id="kobo.75.1">If you do not specify a </span><kbd><span class="koboSpan" id="kobo.76.1">delimiter</span></kbd><span class="koboSpan" id="kobo.77.1"> character when the file is read, the rows will be read as one field and printed as follows:</span></p>
<pre><span class="koboSpan" id="kobo.78.1">['0007-01-01|00:00:00|2.58|0.136|241.97|10.6|0|0|0']</span></pre>
<p><kbd><span class="koboSpan" id="kobo.79.1">quotechar</span></kbd><span class="koboSpan" id="kobo.80.1"> specifies a character with which to surround fields. </span><span class="koboSpan" id="kobo.80.2">The </span><kbd><span class="koboSpan" id="kobo.81.1">quoting</span></kbd><span class="koboSpan" id="kobo.82.1"> argument specifies what kind of fields can be surrounded with </span><kbd><span class="koboSpan" id="kobo.83.1">quotechar</span></kbd><span class="koboSpan" id="kobo.84.1">. </span><span class="koboSpan" id="kobo.84.2">The </span><kbd><span class="koboSpan" id="kobo.85.1">quoting</span></kbd><span class="koboSpan" id="kobo.86.1"> argument can have one of the following values:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.87.1">csv.QUOTE_ALL</span></kbd><span class="koboSpan" id="kobo.88.1">: All the fields are quoted</span></li>
<li><kbd><span class="koboSpan" id="kobo.89.1">csv.QUOTE_MINIMAL</span></kbd><span class="koboSpan" id="kobo.90.1">: Only fields containing special characters are quoted</span></li>
<li><kbd><span class="koboSpan" id="kobo.91.1">csv.QUOTE_NONNUMERIC</span></kbd><span class="koboSpan" id="kobo.92.1">: All non-numeric fields are quoted</span></li>
<li><kbd><span class="koboSpan" id="kobo.93.1">csv.QUOTE_NONE</span></kbd><span class="koboSpan" id="kobo.94.1">: None of the fields are quoted</span></li>
</ul>
<p><span class="koboSpan" id="kobo.95.1">As an example, let's print the temp file first:</span></p>
<pre><span class="koboSpan" id="kobo.96.1">0007-01-01|00:00:00|2.58|0.136|241.97|10.6|0|0|0
0007-01-01|00:01:00|2.552|0.1|241.75|10.4|0|0|0
0007-01-01|00:02:00|2.55|0.1|241.64|10.4|0|0|0
0007-01-01|00:03:00|2.55|0.1|241.71|10.4|0|0|0
0007-01-01|00:04:00|2.554|0.1|241.98|10.4|0|0|0
0007-01-01|00:05:00|2.55|0.1|241.83|10.4|0|0|0
0007-01-01|00:06:00|2.534|0.096|241.07|10.4|0|0|0
0007-01-01|00:07:00|2.484|0|241.29|10.2|0|0|0
0007-01-01|00:08:00|2.468|0|241.23|10.2|0|0|0</span></pre>
<p><span class="koboSpan" id="kobo.97.1">Now let's save it with all fields quoted:</span></p>
<pre><span class="koboSpan" id="kobo.98.1"># read the file and write first ten rows with '|' delimiter, all quoting and * as a quote charachetr.</span><br/><span class="koboSpan" id="kobo.99.1">with open(os.path.join(data_folder, data_file), newline='') as csvfile, \</span><br/><span class="koboSpan" id="kobo.100.1">        open('temp.csv', 'w', newline='') as tempfile:</span><br/><span class="koboSpan" id="kobo.101.1">    csvreader = csv.reader(csvfile)</span><br/><span class="koboSpan" id="kobo.102.1">    csvwriter = csv.writer(tempfile, delimiter='|', quotechar='*',quoting=csv.QUOTE_ALL)</span><br/><span class="koboSpan" id="kobo.103.1">    for row, i in zip(csvreader, range(10)):</span><br/><span class="koboSpan" id="kobo.104.1">        csvwriter.writerow(row)</span></pre>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.105.1">The file gets saved with the specified quote character:</span></p>
<pre><span class="koboSpan" id="kobo.106.1">*0007-01-01*|*00:00:00*|*2.58*|*0.136*|*241.97*|*10.6*|*0*|*0*|*0*
*0007-01-01*|*00:01:00*|*2.552*|*0.1*|*241.75*|*10.4*|*0*|*0*|*0*
*0007-01-01*|*00:02:00*|*2.55*|*0.1*|*241.64*|*10.4*|*0*|*0*|*0*
*0007-01-01*|*00:03:00*|*2.55*|*0.1*|*241.71*|*10.4*|*0*|*0*|*0*
*0007-01-01*|*00:04:00*|*2.554*|*0.1*|*241.98*|*10.4*|*0*|*0*|*0*
*0007-01-01*|*00:05:00*|*2.55*|*0.1*|*241.83*|*10.4*|*0*|*0*|*0*
*0007-01-01*|*00:06:00*|*2.534*|*0.096*|*241.07*|*10.4*|*0*|*0*|*0*
*0007-01-01*|*00:07:00*|*2.484*|*0*|*241.29*|*10.2*|*0*|*0*|*0*
*0007-01-01*|*00:08:00*|*2.468*|*0*|*241.23*|*10.2*|*0*|*0*|*0*</span></pre>
<p><span class="koboSpan" id="kobo.107.1">Remember to read the file with the same arguments; otherwise, the </span><kbd><span class="koboSpan" id="kobo.108.1">*</span></kbd><span class="koboSpan" id="kobo.109.1"> quote character will be treated as part of the field values and printed as follows:</span></p>
<pre><span class="koboSpan" id="kobo.110.1">['*0007-01-01*', '*00:00:00*', '*2.58*', '*0.136*', '*241.97*', '*10.6*', '*0*', '*0*', '*0*']</span></pre>
<p><span class="koboSpan" id="kobo.111.1">Using the correct arguments with the </span><kbd><span class="koboSpan" id="kobo.112.1">reader</span></kbd><span class="koboSpan" id="kobo.113.1"> object prints the following:</span></p>
<pre><span class="koboSpan" id="kobo.114.1">['0007-01-01', '00:00:00', '2.58', '0.136', '241.97', '10.6', '0', '0', '0']</span></pre>
<p><span class="koboSpan" id="kobo.115.1">Now let's see how we can read CSV files with pandas, another popular Python library.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Working with CSV files with the pandas module</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In pandas, the </span><kbd><span class="koboSpan" id="kobo.3.1">read_csv()</span></kbd><span class="koboSpan" id="kobo.4.1"> function returns a DataFrame after reading the CSV file:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">df = pd.read_csv('temp.csv')</span><br/><span class="koboSpan" id="kobo.6.1">print(df)</span></pre>
<p><span class="koboSpan" id="kobo.7.1">The DataFrame is printed as follows:</span></p>
<pre><span class="koboSpan" id="kobo.8.1">         date      time  global_active_power  global_reactive_power  voltage  \
0  0007-01-01  00:00:00                2.580                  0.136   241.97   
1  0007-01-01  00:01:00                2.552                  0.100   241.75   
2  0007-01-01  00:02:00                2.550                  0.100   241.64   
3  0007-01-01  00:03:00                2.550                  0.100   241.71   
4  0007-01-01  00:04:00                2.554                  0.100   241.98   
5  0007-01-01  00:05:00                2.550                  0.100   241.83   
6  0007-01-01  00:06:00                2.534                  0.096   241.07   
7  0007-01-01  00:07:00                2.484                  0.000   241.29   
8  0007-01-01  00:08:00                2.468                  0.000   241.23   

   global_intensity  sub_metering_1  sub_metering_2  sub_metering_3  
0              10.6               0               0               0  
1              10.4               0               0               0  
2              10.4               0               0               0  
3              10.4               0               0               0  
4              10.4               0               0               0  
5              10.4               0               0               0  
6              10.4               0               0               0  
7              10.2               0               0               0  
8              10.2               0               0               0  </span></pre>
<p><span class="koboSpan" id="kobo.9.1">We see in the preceding output that pandas automatically interpreted the </span><kbd><span class="koboSpan" id="kobo.10.1">date</span></kbd><span class="koboSpan" id="kobo.11.1"> and </span><kbd><span class="koboSpan" id="kobo.12.1">time</span></kbd><span class="koboSpan" id="kobo.13.1"> columns as their respective data types. </span><span class="koboSpan" id="kobo.13.2">The pandas DataFrame can be saved to a CSV file with the </span><kbd><span class="koboSpan" id="kobo.14.1">to_csv()</span></kbd><span class="koboSpan" id="kobo.15.1"> function:</span></p>
<pre><span class="koboSpan" id="kobo.16.1">df.to_csv('temp1.cvs')</span></pre>
<p><span class="koboSpan" id="kobo.17.1">pandas, when it comes to reading and writing CSV files, offers plenty of arguments. </span><span class="koboSpan" id="kobo.17.2">Some of these are as follows, complete with how they're used:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.18.1">header</span></kbd><span class="koboSpan" id="kobo.19.1">: Defines the row number to be used as a header, or none if the file does not contain any headers.</span></li>
<li><kbd><span class="koboSpan" id="kobo.20.1">sep</span></kbd><span class="koboSpan" id="kobo.21.1">: </span><span><span class="koboSpan" id="kobo.22.1">Defines</span></span><span class="koboSpan" id="kobo.23.1"> the character that separates fields in rows. </span><span class="koboSpan" id="kobo.23.2">By default, the value of </span><kbd><span class="koboSpan" id="kobo.24.1">sep</span></kbd><span class="koboSpan" id="kobo.25.1"> is set to </span><kbd><span class="koboSpan" id="kobo.26.1">,</span></kbd><span class="koboSpan" id="kobo.27.1">.</span></li>
<li><kbd><span class="koboSpan" id="kobo.28.1">names</span></kbd><span class="koboSpan" id="kobo.29.1">: </span><span><span class="koboSpan" id="kobo.30.1">Defines</span></span><span class="koboSpan" id="kobo.31.1"> column names for each column in the file.</span></li>
<li><kbd><span class="koboSpan" id="kobo.32.1">usecols</span></kbd><span class="koboSpan" id="kobo.33.1">: </span><span><span class="koboSpan" id="kobo.34.1">Defines</span></span><span class="koboSpan" id="kobo.35.1"> columns that need to be extracted from the CSV file. </span><span class="koboSpan" id="kobo.35.2">Columns that are not mentioned in this argument are not read.</span></li>
<li><kbd><span class="koboSpan" id="kobo.36.1">dtype</span></kbd><span class="koboSpan" id="kobo.37.1">: </span><span><span class="koboSpan" id="kobo.38.1">Defines</span></span><span class="koboSpan" id="kobo.39.1"> the data types for columns in the DataFrame.</span></li>
</ul>
<div class="packt_infobox"><span class="koboSpan" id="kobo.40.1">Many other available options are documented at the following links: </span><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html"><span class="koboSpan" id="kobo.41.1">https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html</span></a><span class="koboSpan" id="kobo.42.1"> and </span><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_csv.html"><span class="koboSpan" id="kobo.43.1">https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_csv.html</span></a><span class="koboSpan" id="kobo.44.1">.</span></div>
<p><span class="koboSpan" id="kobo.45.1">Now let's see how to read data from CSV files with the NumPy module.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Working with CSV files with the NumPy module</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The NumPy module provides two functions for reading values from CSV files: </span><kbd><span class="koboSpan" id="kobo.3.1">np.loadtxt()</span></kbd><span class="koboSpan" id="kobo.4.1"> and </span><kbd><span class="koboSpan" id="kobo.5.1">np.genfromtxt()</span></kbd><span class="koboSpan" id="kobo.6.1">.</span></p>
<p><span class="koboSpan" id="kobo.7.1">An example of </span><kbd><span class="koboSpan" id="kobo.8.1">np.loadtxt</span></kbd><span class="koboSpan" id="kobo.9.1"> is as follows:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">arr = np.loadtxt('temp.csv', skiprows=1, usecols=(2,3), delimiter=',')</span><br/><span class="koboSpan" id="kobo.11.1">arr</span></pre>
<p><span class="koboSpan" id="kobo.12.1">The preceding code reads columns </span><kbd><span class="koboSpan" id="kobo.13.1">3</span></kbd><span class="koboSpan" id="kobo.14.1"> and </span><kbd><span class="koboSpan" id="kobo.15.1">4</span></kbd><span class="koboSpan" id="kobo.16.1"> from the file that we created earlier, and saves them in a 9 × 2 array as follows:</span></p>
<div class="cell code_cell rendered selected">
<div class="output_wrapper">
<div class="output">
<div class="output_area">
<div class="output_subarea output_text output_result">
<pre><span class="koboSpan" id="kobo.17.1">array([[2.58 , 0.136],
       [2.552, 0.1  ],
       [2.55 , 0.1  ],
       [2.55 , 0.1  ],
       [2.554, 0.1  ],
       [2.55 , 0.1  ],
       [2.534, 0.096],
       [2.484, 0.   </span><span class="koboSpan" id="kobo.17.2">],
       [2.468, 0.   </span><span class="koboSpan" id="kobo.17.3">]])</span></pre></div>
</div>
</div>
</div>
</div>
<p><span class="koboSpan" id="kobo.18.1">The </span><kbd><span class="koboSpan" id="kobo.19.1">np.loadtxt()</span></kbd><span class="koboSpan" id="kobo.20.1"> </span><span><span class="koboSpan" id="kobo.21.1">function</span></span><span><span class="koboSpan" id="kobo.22.1"> </span></span><span><span class="koboSpan" id="kobo.23.1">cannot handle CSV files with missing data. </span><span class="koboSpan" id="kobo.23.2">For instances where data is missing,</span></span> <kbd><span class="koboSpan" id="kobo.24.1">np.genfromtxt()</span></kbd> <span><span class="koboSpan" id="kobo.25.1">can be used. </span><span class="koboSpan" id="kobo.25.2">Both of these functions offer many more arguments; details can be found in the NumPy documentation. </span><span class="koboSpan" id="kobo.25.3">The preceding code can be written using</span></span> <kbd><span class="koboSpan" id="kobo.26.1">np.genfromtxt()</span></kbd> <span><span class="koboSpan" id="kobo.27.1">as follows:</span></span></p>
<pre><span class="koboSpan" id="kobo.28.1">arr = np.genfromtxt('temp.csv', skip_header=1, usecols=(2,3), delimiter=',')</span></pre>
<p><span class="koboSpan" id="kobo.29.1">NumPy arrays produced as a result of applying AI to IoT data can be saved with </span><kbd><span class="koboSpan" id="kobo.30.1">np.savetxt()</span></kbd><span class="koboSpan" id="kobo.31.1">. </span><span class="koboSpan" id="kobo.31.2">For example, the array we loaded previously can be saved as follows:</span></p>
<pre><span class="koboSpan" id="kobo.32.1">np.savetxt('temp.csv', arr, delimiter=',')</span></pre>
<p><span class="koboSpan" id="kobo.33.1">The </span><kbd><span class="koboSpan" id="kobo.34.1">np.savetxt()</span></kbd><span class="koboSpan" id="kobo.35.1"> function also accepts various other useful arguments, such as the format for saved fields and headers. </span><span class="koboSpan" id="kobo.35.2">Check the NumPy documentation for more details on this function.</span></p>
<p><span class="koboSpan" id="kobo.36.1">CSV is the most popular data format on IoT platforms and devices. </span><span class="koboSpan" id="kobo.36.2">In this section, we learned how to read CSV data using three different packages in Python. </span><span class="koboSpan" id="kobo.36.3">Let's learn about XLSX, another popular format, in the next section.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">XLSX format</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Excel, a component of the Microsoft Office pack, is one of the popular formats in which data is stored and visualized. </span><span class="koboSpan" id="kobo.2.2">Since 2010, Office has supported the </span><kbd><span class="koboSpan" id="kobo.3.1">.xlsx</span></kbd><span class="koboSpan" id="kobo.4.1"> format. </span><span class="koboSpan" id="kobo.4.2">We can read XLSX files using the OpenPyXl and pandas functions.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using OpenPyXl for XLSX files</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">OpenPyXl is a Python library for reading and writing Excel files. </span><span class="koboSpan" id="kobo.2.2">It is an open source project. </span><span class="koboSpan" id="kobo.2.3">A new </span><kbd><span class="koboSpan" id="kobo.3.1">workbook</span></kbd><span class="koboSpan" id="kobo.4.1"> is created using the following command:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">wb = Workbook()</span></pre>
<p><span class="koboSpan" id="kobo.6.1">We can access the currently </span><kbd><span class="koboSpan" id="kobo.7.1">active</span></kbd><span class="koboSpan" id="kobo.8.1"> sheet by using the following command:</span></p>
<pre><span class="koboSpan" id="kobo.9.1">ws = wb.active()</span></pre>
<p><span class="koboSpan" id="kobo.10.1">To change the sheet name, use the </span><kbd><span class="koboSpan" id="kobo.11.1">title</span></kbd><span class="koboSpan" id="kobo.12.1"> command:</span></p>
<pre><span class="koboSpan" id="kobo.13.1">ws.title = "Demo Name"</span></pre>
<p><span class="koboSpan" id="kobo.14.1">A single row can be added to the sheet using the </span><kbd><span class="koboSpan" id="kobo.15.1">append</span></kbd><span class="koboSpan" id="kobo.16.1"> method:</span></p>
<pre><span class="koboSpan" id="kobo.17.1">ws.append()</span></pre>
<p><span class="koboSpan" id="kobo.18.1">A new sheet can be created using the </span><kbd><span class="koboSpan" id="kobo.19.1">create_sheet()</span></kbd><span class="koboSpan" id="kobo.20.1"> method. </span><span class="koboSpan" id="kobo.20.2">An individual cell in the active sheet can be created using the </span><kbd><span class="koboSpan" id="kobo.21.1">column</span></kbd><span class="koboSpan" id="kobo.22.1"> and </span><kbd><span class="koboSpan" id="kobo.23.1">row</span></kbd><span class="koboSpan" id="kobo.24.1"> values:</span></p>
<pre><span><span class="koboSpan" id="kobo.25.1"># Assigns the cell corresponding to </span><br/><span class="koboSpan" id="kobo.26.1"># column A and row 10 a value of 5</span><br/></span><span class="koboSpan" id="kobo.27.1">ws.['A10'] = 5  </span><br/><span class="koboSpan" id="kobo.28.1">#or</span><br/><span class="koboSpan" id="kobo.29.1">ws.cell(column=1, row=10, value=5)</span></pre>
<p><span class="koboSpan" id="kobo.30.1">A workbook can be saved using the </span><kbd><span class="koboSpan" id="kobo.31.1">save</span></kbd><span class="koboSpan" id="kobo.32.1"> method. </span><span class="koboSpan" id="kobo.32.2">To load an existing workbook, we can use the </span><kbd><span class="koboSpan" id="kobo.33.1">load_workbook</span></kbd><span class="koboSpan" id="kobo.34.1"> method. </span><span class="koboSpan" id="kobo.34.2">The names of the different sheets in an Excel workbook can be accessed using </span><kbd><span class="koboSpan" id="kobo.35.1">get_sheet_names()</span></kbd><span class="koboSpan" id="kobo.36.1">. </span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.37.1">The following code creates an Excel workbook with three sheets and saves it; later, it loads the sheet and accesses a cell. </span><span class="koboSpan" id="kobo.37.2">The code can be accessed from GitHub at </span><kbd><span class="koboSpan" id="kobo.38.1">OpenPyXl_example.ipynb</span></kbd><span class="koboSpan" id="kobo.39.1">:</span></p>
<pre><span class="koboSpan" id="kobo.40.1"># Creating and writing into xlsx file</span><br/><span class="koboSpan" id="kobo.41.1">from openpyxl import Workbook</span><br/><span class="koboSpan" id="kobo.42.1">from openpyxl.compat import range</span><br/><span class="koboSpan" id="kobo.43.1">from openpyxl.utils import get_column_letter</span><br/><span class="koboSpan" id="kobo.44.1">wb = Workbook()</span><br/><span class="koboSpan" id="kobo.45.1">dest_filename = 'empty_book.xlsx'</span><br/><span class="koboSpan" id="kobo.46.1">ws1 = wb.active</span><br/><span class="koboSpan" id="kobo.47.1">ws1.title = "range names"</span><br/><span class="koboSpan" id="kobo.48.1">for row in range(1, 40):</span><br/><span class="koboSpan" id="kobo.49.1"> ws1.append(range(0,100,5))</span><br/><span class="koboSpan" id="kobo.50.1">ws2 = wb.create_sheet(title="Pi")</span><br/><span class="koboSpan" id="kobo.51.1">ws2['F5'] = 2 * 3.14</span><br/><span class="koboSpan" id="kobo.52.1">ws2.cell(column=1, row=5, value= 3.14)</span><br/><span class="koboSpan" id="kobo.53.1">ws3 = wb.create_sheet(title="Data")</span><br/><span class="koboSpan" id="kobo.54.1">for row in range(1, 20):</span><br/><span class="koboSpan" id="kobo.55.1"> for col in range(1, 15):</span><br/><span class="koboSpan" id="kobo.56.1"> _ = ws3.cell(column=col, row=row, value="\</span><br/><span class="koboSpan" id="kobo.57.1"> {0}".format(get_column_letter(col)))</span><br/><span class="koboSpan" id="kobo.58.1">print(ws3['A10'].value)</span><br/><span class="koboSpan" id="kobo.59.1">wb.save(filename = dest_filename)</span><br/><br/><span class="koboSpan" id="kobo.60.1"># Reading from xlsx file</span><br/><span class="koboSpan" id="kobo.61.1">from openpyxl import load_workbook</span><br/><span class="koboSpan" id="kobo.62.1">wb = load_workbook(filename = 'empty_book.xlsx')</span><br/><span class="koboSpan" id="kobo.63.1">sheet_ranges = wb['range names']</span><br/><span class="koboSpan" id="kobo.64.1">print(wb.get_sheet_names())</span><br/><span class="koboSpan" id="kobo.65.1">print(sheet_ranges['D18'].value)</span></pre>
<div class="packt_infobox"><span class="koboSpan" id="kobo.66.1">You can learn more about OpenPyXL from its documentation, available at </span><a href="https://openpyxl.readthedocs.io/en/stable/"><span class="koboSpan" id="kobo.67.1">https://openpyxl.readthedocs.io/en/stable/</span></a><span class="koboSpan" id="kobo.68.1">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using pandas with XLSX files</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We can load existing </span><kbd><span class="koboSpan" id="kobo.3.1">.xlsx</span></kbd><span class="koboSpan" id="kobo.4.1"> files with the help of pandas. </span><span class="koboSpan" id="kobo.4.2">The </span><kbd><span class="koboSpan" id="kobo.5.1">read_excel</span></kbd> <span><span class="koboSpan" id="kobo.6.1">method </span></span><span class="koboSpan" id="kobo.7.1">is used to read Excel files as a DataFrame. </span><span class="koboSpan" id="kobo.7.2">This method uses an argument, </span><kbd><span class="koboSpan" id="kobo.8.1">sheet_name</span></kbd><span class="koboSpan" id="kobo.9.1">, which is used to specify the sheet we want to load. </span><span class="koboSpan" id="kobo.9.2">The sheet name can be specified either as a string or number starting from 0. </span><span class="koboSpan" id="kobo.9.3">The </span><kbd><span class="koboSpan" id="kobo.10.1">to_excel</span></kbd><span class="koboSpan" id="kobo.11.1"> </span><span><span class="koboSpan" id="kobo.12.1">method</span></span><span><span class="koboSpan" id="kobo.13.1"> </span></span><span><span class="koboSpan" id="kobo.14.1">can be used to write into an Excel file.</span></span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.15.1">The following </span><span><span class="koboSpan" id="kobo.16.1">code</span></span><span><span class="koboSpan" id="kobo.17.1"> </span></span><span><span class="koboSpan" id="kobo.18.1">reads an Excel file, manipulates it, and saves it.</span></span> <span><span class="koboSpan" id="kobo.19.1">The code c</span></span><span><span class="koboSpan" id="kobo.20.1">an be accessed from GitHub at</span></span> <kbd><span class="koboSpan" id="kobo.21.1">Pandas_xlsx_example.ipynb</span></kbd><span><span class="koboSpan" id="kobo.22.1">:</span></span></p>
<pre><span class="koboSpan" id="kobo.23.1">import pandas as pd</span><br/><span class="koboSpan" id="kobo.24.1">df = pd.read_excel("empty_book.xlsx", sheet_name=0)</span><br/><span class="koboSpan" id="kobo.25.1">df.describe()</span><br/><span class="koboSpan" id="kobo.26.1">result = df * 2</span><br/><span class="koboSpan" id="kobo.27.1">result.describe()</span><br/><span class="koboSpan" id="kobo.28.1">result.to_excel("empty_book_modified.xlsx")</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Working with the JSON format</span></h1>
                </header>
            
            <article>
                
<p><strong><span class="koboSpan" id="kobo.2.1">JavaScript</span></strong> <strong><span class="koboSpan" id="kobo.3.1">Object</span></strong> <strong><span class="koboSpan" id="kobo.4.1">Notation </span></strong><span class="koboSpan" id="kobo.5.1">(</span><strong><span class="koboSpan" id="kobo.6.1">JSON</span></strong><span class="koboSpan" id="kobo.7.1">) is another popular data format in IoT systems. </span><span><span class="koboSpan" id="kobo.8.1">In this section, we will learn how to read JSON data with Python's JSON, NumPy, and pandas packages.</span></span></p>
<p><span><span class="koboSpan" id="kobo.9.1">For this section, we will use the </span><kbd><span class="koboSpan" id="kobo.10.1">zips.json</span></kbd><span class="koboSpan" id="kobo.11.1"> file, which contains US ZIP codes with city codes, geolocation details, and state codes. </span><span class="koboSpan" id="kobo.11.2">The file has JSON objects recorded in the following format:</span></span></p>
<pre><span class="koboSpan" id="kobo.12.1">{ "_id" : "01001", "city" : "AGAWAM", "loc" : [ -72.622739, 42.070206 ], "pop" : 15338, "state" : "MA" }</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using JSON files with the JSON module</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To load and decode JSON data, use the </span><kbd><span class="koboSpan" id="kobo.3.1">json.load()</span></kbd><span class="koboSpan" id="kobo.4.1"> or </span><kbd><span class="koboSpan" id="kobo.5.1">json.loads() </span></kbd><span><span class="koboSpan" id="kobo.6.1">functions</span></span><span><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">As an example, the following code reads the first 10 lines from the</span></span> <kbd><span class="koboSpan" id="kobo.8.1">zips.json</span></kbd> <span><span class="koboSpan" id="kobo.9.1">file and prints them nicely:</span></span></p>
<pre><span><span class="koboSpan" id="kobo.10.1">import os</span></span><br/><span><span class="koboSpan" id="kobo.11.1">import json</span></span><br/><span><span class="koboSpan" id="kobo.12.1">from pprint import pprint</span></span><br/><br/><span class="koboSpan" id="kobo.13.1">with open(os.path.join(data_folder,data_file)) as json_file:</span><br/><span class="koboSpan" id="kobo.14.1">    for line,i in zip(json_file,range(10)):</span><br/><span class="koboSpan" id="kobo.15.1">        json_data = json.loads(line)</span><br/><span class="koboSpan" id="kobo.16.1">        pprint(json_data)</span></pre>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.17.1">The objects are printed as follows:</span></p>
<pre><span class="koboSpan" id="kobo.18.1">{'_id': '01001',
 'city': 'AGAWAM',
 'loc': [-72.622739, 42.070206],
 'pop': 15338,
 'state': 'MA'}</span></pre>
<p><span class="koboSpan" id="kobo.19.1">The </span><kbd><span class="koboSpan" id="kobo.20.1">json.loads()</span></kbd><span class="koboSpan" id="kobo.21.1"> </span><span><span class="koboSpan" id="kobo.22.1">function </span></span><span><span class="koboSpan" id="kobo.23.1">takes string objects as input while the</span></span> <kbd><span class="koboSpan" id="kobo.24.1">json.load()</span></kbd><span><span class="koboSpan" id="kobo.25.1"> </span></span><span><span class="koboSpan" id="kobo.26.1">function</span></span><span><span class="koboSpan" id="kobo.27.1"> </span></span><span><span class="koboSpan" id="kobo.28.1">takes file objects as input. </span><span class="koboSpan" id="kobo.28.2">Both functions decode the JSON object and load it in the</span></span> <kbd><span class="koboSpan" id="kobo.29.1">json_data</span></kbd><span><span class="koboSpan" id="kobo.30.1"> file as a Python dictionary object.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">The </span><kbd><span class="koboSpan" id="kobo.32.1">json.dumps()</span></kbd> <span><span class="koboSpan" id="kobo.33.1">function </span></span><span class="koboSpan" id="kobo.34.1">takes an object and produces a JSON string, and the </span><kbd><span class="koboSpan" id="kobo.35.1">json.dump()</span></kbd> <span><span class="koboSpan" id="kobo.36.1">function </span></span><span class="koboSpan" id="kobo.37.1">takes an object and writes the JSON string to the file. </span><span class="koboSpan" id="kobo.37.2">Thus, both these function do the opposite of the </span><kbd><span class="koboSpan" id="kobo.38.1">json.loads()</span></kbd><span class="koboSpan" id="kobo.39.1"> and </span><kbd><span class="koboSpan" id="kobo.40.1">json.load()</span></kbd><span class="koboSpan" id="kobo.41.1"> functions.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">JSON files with the pandas module</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">JSON strings or files can be read with the </span><kbd><span class="koboSpan" id="kobo.3.1">pandas.read_json()</span></kbd><span class="koboSpan" id="kobo.4.1"> </span><span><span class="koboSpan" id="kobo.5.1">function, which</span></span><span><span class="koboSpan" id="kobo.6.1"> returns a DataFrame or series object. </span><span class="koboSpan" id="kobo.6.2">For example, the following code reads the</span></span> <kbd><span class="koboSpan" id="kobo.7.1">zips.json</span></kbd> <span><span class="koboSpan" id="kobo.8.1">file:</span></span></p>
<pre><span class="koboSpan" id="kobo.9.1">df = pd.read_json(os.path.join(data_folder,data_file), lines=True)</span><br/><span class="koboSpan" id="kobo.10.1">print(df)</span></pre>
<p><span class="koboSpan" id="kobo.11.1">We set </span><kbd><span class="koboSpan" id="kobo.12.1">lines=True</span></kbd><span class="koboSpan" id="kobo.13.1"> because each line contains a separate object in JSON format. </span><span class="koboSpan" id="kobo.13.2">Without this argument being set to </span><kbd><span class="koboSpan" id="kobo.14.1">True</span></kbd><span class="koboSpan" id="kobo.15.1">, pandas will raise </span><kbd><span class="koboSpan" id="kobo.16.1">ValueError</span></kbd><span class="koboSpan" id="kobo.17.1">. </span><span class="koboSpan" id="kobo.17.2">The DataFrame is printed as follows:</span></p>
<pre><span class="koboSpan" id="kobo.18.1">         _id             city                               loc    pop state
0       1001           AGAWAM           [-72.622739, 42.070206]  15338    MA
1       1002          CUSHMAN            [-72.51565, 42.377017]  36963    MA
...      </span><span class="koboSpan" id="kobo.18.2">...              </span><span class="koboSpan" id="kobo.18.3">...                               </span><span class="koboSpan" id="kobo.18.4">...    </span><span class="koboSpan" id="kobo.18.5">...   </span><span class="koboSpan" id="kobo.18.6">...
</span><span class="koboSpan" id="kobo.18.7">29351  99929         WRANGELL          [-132.352918, 56.433524]   2573    AK
29352  99950        KETCHIKAN           [-133.18479, 55.942471]    422    AK

[29353 rows x 5 columns]</span></pre>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.19.1">To save the pandas DataFrame or series object to a JSON file or string, use the </span><kbd><span class="koboSpan" id="kobo.20.1">Dataframe.to_json() </span></kbd><span><span class="koboSpan" id="kobo.21.1">function</span></span><span><span class="koboSpan" id="kobo.22.1">.</span></span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.23.1">More information for both of these functions can be found at these links: </span><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_json.html"><span class="koboSpan" id="kobo.24.1">https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_json.html</span></a><span class="koboSpan" id="kobo.25.1"> and </span><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_json.html"><span class="koboSpan" id="kobo.26.1">https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_json.html</span></a><span class="koboSpan" id="kobo.27.1">.</span></div>
<p><span class="koboSpan" id="kobo.28.1">While CSV and JSON remain the most popular data formats for IoT data, due to its large size, it is often necessary to distribute data. </span><span class="koboSpan" id="kobo.28.2">There are two popular distributed mechanisms for data storage and access: HDF5 and HDFS. </span><span class="koboSpan" id="kobo.28.3">Let's first learn about the HDF5 format.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">HDF5 format</span></h1>
                </header>
            
            <article>
                
<p><strong><span class="koboSpan" id="kobo.2.1">Hierarchical Data Format</span></strong><span class="koboSpan" id="kobo.3.1"> (</span><strong><span class="koboSpan" id="kobo.4.1">HDF</span></strong><span class="koboSpan" id="kobo.5.1">) is a specification put together by the HDF Group, a consortium of academic and industry organizations (</span><a href="https://support.hdfgroup.org/HDF5/"><span class="koboSpan" id="kobo.6.1">https://support.hdfgroup.org/HDF5/</span></a><span class="koboSpan" id="kobo.7.1">). </span><span class="koboSpan" id="kobo.7.2">In HDF5 files, data is organized into groups and datasets. </span><span class="koboSpan" id="kobo.7.3">A group is a collection of </span><strong><span class="koboSpan" id="kobo.8.1">groups</span></strong><span class="koboSpan" id="kobo.9.1"> or </span><strong><span class="koboSpan" id="kobo.10.1">datasets</span></strong><span class="koboSpan" id="kobo.11.1">. </span><span class="koboSpan" id="kobo.11.2">A dataset is a multidimensional homogeneous array.</span></p>
<p><span class="koboSpan" id="kobo.12.1">In Python, PyTables and h5py are two major libraries for handling HDF5 files. </span><span class="koboSpan" id="kobo.12.2">Both these libraries require HDF5 to be installed. </span><span class="koboSpan" id="kobo.12.3">For the parallel version of HDF5, a version of MPI is also required to be installed. </span><span class="koboSpan" id="kobo.12.4">Installation of HDF5 and MPI is beyond the scope of this book. </span><span class="koboSpan" id="kobo.12.5">Installation instructions for parallel HDF5 can be found at the following link: </span><a href="https://support.hdfgroup.org/ftp/HDF5/current/src/unpacked/release_docs/INSTALL_parallel"><span class="koboSpan" id="kobo.13.1">https://support.hdfgroup.org/ftp/HDF5/current/src/unpacked/release_docs/INSTALL_parallel</span></a><span class="koboSpan" id="kobo.14.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using HDF5 with PyTables</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's first create an HDF5 file from the numeric data we have in the </span><kbd><span class="koboSpan" id="kobo.3.1">temp.csv</span></kbd><span class="koboSpan" id="kobo.4.1"> file with the following steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.5.1">Get the numeric data:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.6.1">import numpy as np</span><br/><span class="koboSpan" id="kobo.7.1">arr = np.loadtxt('temp.csv', skiprows=1, usecols=(2,3), delimiter=',')</span></pre>
<p class="mce-root"/>
<ol start="2">
<li><span class="koboSpan" id="kobo.8.1">Open the HDF5 file:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.9.1">import tables</span><br/><span class="koboSpan" id="kobo.10.1">h5filename = 'pytable_demo.hdf5'</span><br/><span class="koboSpan" id="kobo.11.1">with tables.open_file(h5filename,mode='w') as h5file:</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.12.1"> Get the </span><kbd><span class="koboSpan" id="kobo.13.1">root</span></kbd><span class="koboSpan" id="kobo.14.1"> node:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.15.1">    root = h5file.root</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.16.1">Create a group with </span><kbd><span class="koboSpan" id="kobo.17.1">create_group()</span></kbd><span class="koboSpan" id="kobo.18.1"> or a dataset with </span><kbd><span class="koboSpan" id="kobo.19.1">create_array()</span></kbd><span class="koboSpan" id="kobo.20.1">, and repeat this until all the data is stored:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.21.1">    h5file.create_array(root,'global_power',arr)</span></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.22.1">Close the file:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.23.1">    h5file.close()</span></pre>
<p><span class="koboSpan" id="kobo.24.1">Let's read the file and print the dataset to make sure it is properly written:</span></p>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.25.1">with tables.open_file(h5filename,mode='r') as h5file:</span><br/><span class="koboSpan" id="kobo.26.1">    root = h5file.root</span><br/><span class="koboSpan" id="kobo.27.1">    for node in h5file.root:</span><br/><span class="koboSpan" id="kobo.28.1">        ds = node.read()</span><br/><span class="koboSpan" id="kobo.29.1">        print(type(ds),ds.shape)</span><br/><span class="koboSpan" id="kobo.30.1">        print(ds)</span></pre>
<p><span class="koboSpan" id="kobo.31.1">We get the NumPy array back.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using HDF5 with pandas</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We can also read and write HDF5 files with pandas. </span><span class="koboSpan" id="kobo.2.2">To read HDF5 files with pandas, they must first be created with it. </span><span class="koboSpan" id="kobo.2.3">For example, let's use pandas to create a HDF5 file containing global power values:</span></p>
<pre><span class="koboSpan" id="kobo.3.1">import pandas as pd</span><br/><span class="koboSpan" id="kobo.4.1">import numpy as np</span><br/><span class="koboSpan" id="kobo.5.1">arr = np.loadtxt('temp.csv', skiprows=1, usecols=(2,3), delimiter=',')</span><br/><span class="koboSpan" id="kobo.6.1">import pandas as pd</span><br/><span class="koboSpan" id="kobo.7.1">store=pd.HDFStore('hdfstore_demo.hdf5')</span><br/><span class="koboSpan" id="kobo.8.1">print(store)</span><br/><span class="koboSpan" id="kobo.9.1">store['global_power']=pd.DataFrame(arr)</span><br/><span class="koboSpan" id="kobo.10.1">store.close()</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.11.1">Now let's read the HDF5 file that we created and print the array back:</span></p>
<pre><span class="koboSpan" id="kobo.12.1">import pandas as pd</span><br/><span class="koboSpan" id="kobo.13.1">store=pd.HDFStore('hdfstore_demo.hdf5')</span><br/><span class="koboSpan" id="kobo.14.1">print(store)</span><br/><span class="koboSpan" id="kobo.15.1">print(store['global_power'])</span><br/><span class="koboSpan" id="kobo.16.1">store.close()</span></pre>
<p><span class="koboSpan" id="kobo.17.1">The values of the DataFrame can be read in three different ways:</span></p>
<ul>
<li><kbd><span><span class="koboSpan" id="kobo.18.1">store['global_power']</span></span></kbd></li>
<li><kbd><span><span class="koboSpan" id="kobo.19.1">store.get('global_power')</span></span></kbd></li>
<li><kbd><span><span class="koboSpan" id="kobo.20.1">store.global_power</span></span></kbd></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1">pandas also provides the high-level </span><kbd><span class="koboSpan" id="kobo.22.1">read_hdf()</span></kbd><span class="koboSpan" id="kobo.23.1"> function and the </span><kbd><span class="koboSpan" id="kobo.24.1">to_hdf()</span></kbd><span class="koboSpan" id="kobo.25.1"> DataFrame method for reading and writing HDF5 files.</span></p>
<p><span class="koboSpan" id="kobo.26.1">More documentation on HDF5 in pandas is available at the following link: </span><a href="http://pandas.pydata.org/pandas-docs/stable/io.html#io-hdf5"><span class="koboSpan" id="kobo.27.1">http://pandas.pydata.org/pandas-docs/stable/io.html#io-hdf5</span></a><span class="koboSpan" id="kobo.28.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using HDF5 with h5py</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">h5py</span></kbd><span class="koboSpan" id="kobo.4.1"> module is the most popular way to handle HDF5 files in Python. </span><span class="koboSpan" id="kobo.4.2">A new or existing HDF5 file can be opened with the </span><kbd><span class="koboSpan" id="kobo.5.1">h5py.File()</span></kbd><span class="koboSpan" id="kobo.6.1"> function. </span><span class="koboSpan" id="kobo.6.2">After the file is open, its groups can simply be accessed by subscripting the file object as if it was a dictionary object. </span><span class="koboSpan" id="kobo.6.3">For example, the following code opens an HDF5 file with </span><kbd><span class="koboSpan" id="kobo.7.1">h5py</span></kbd><span class="koboSpan" id="kobo.8.1"> and then prints the array stored in the </span><kbd><span class="koboSpan" id="kobo.9.1">/global_power </span></kbd><span><span class="koboSpan" id="kobo.10.1">group</span></span><span><span class="koboSpan" id="kobo.11.1">:</span></span></p>
<pre><span class="koboSpan" id="kobo.12.1">import h5py</span><br/><span class="koboSpan" id="kobo.13.1">hdf5file = h5py.File('pytable_demo.hdf5')</span><br/><span class="koboSpan" id="kobo.14.1">ds=hdf5file['/global_power']</span><br/><span class="koboSpan" id="kobo.15.1">print(ds)</span><br/><span class="koboSpan" id="kobo.16.1">for i in range(len(ds)):</span><br/><span class="koboSpan" id="kobo.17.1">    print(arr[i])</span><br/><span class="koboSpan" id="kobo.18.1">hdf5file.close()</span></pre>
<p><span class="koboSpan" id="kobo.19.1">The </span><kbd><span class="koboSpan" id="kobo.20.1">arr</span></kbd><span class="koboSpan" id="kobo.21.1"> </span><span><span class="koboSpan" id="kobo.22.1">variable </span></span><span class="koboSpan" id="kobo.23.1">prints an </span><kbd><span class="koboSpan" id="kobo.24.1">HDF5 dataset</span></kbd><span class="koboSpan" id="kobo.25.1"> type:</span></p>
<pre><span class="koboSpan" id="kobo.26.1">&lt;HDF5 dataset "global_power": shape (9, 2), type "&lt;f8"&gt;
[2.58  0.136]
[2.552 0.1  ]
[2.55 0.1 ]
[2.55 0.1 ]
[2.554 0.1  ]
[2.55 0.1 ]
[2.534 0.096]
[2.484 0.   </span><span class="koboSpan" id="kobo.26.2">]
[2.468 0.   </span><span class="koboSpan" id="kobo.26.3">]</span></pre>
<p><span class="koboSpan" id="kobo.27.1">For a new </span><kbd><span class="koboSpan" id="kobo.28.1">hdf5file</span></kbd><span class="koboSpan" id="kobo.29.1">, datasets and groups can be created by using the </span><span><kbd><span class="koboSpan" id="kobo.30.1">hdf5file.create_dataset()</span></kbd><span class="koboSpan" id="kobo.31.1"> function, returning the dataset object, and </span></span><span class="koboSpan" id="kobo.32.1">the </span><kbd><span class="koboSpan" id="kobo.33.1">hdf5file.create_group()</span></kbd><span class="koboSpan" id="kobo.34.1"> function, returning the folder object. </span><span class="koboSpan" id="kobo.34.2">The </span><kbd><span class="koboSpan" id="kobo.35.1">hdf5file</span></kbd><span class="koboSpan" id="kobo.36.1"> </span><span><span class="koboSpan" id="kobo.37.1">file object </span></span><span><span class="koboSpan" id="kobo.38.1">is also a folder object representing</span></span> <kbd><span class="koboSpan" id="kobo.39.1">/</span></kbd><span><span class="koboSpan" id="kobo.40.1">, the root folder. </span><span class="koboSpan" id="kobo.40.2">Dataset objects support array style slicing and dicing to set or read values from them. </span><span class="koboSpan" id="kobo.40.3">For example, the following code creates an HDF5 file and stores one dataset:</span></span></p>
<pre><span class="koboSpan" id="kobo.41.1">import numpy as np</span><br/><span class="koboSpan" id="kobo.42.1">arr = np.loadtxt('temp.csv', skiprows=1, usecols=(2,3), delimiter=',')</span><br/><br/><span class="koboSpan" id="kobo.43.1">import h5py</span><br/><span class="koboSpan" id="kobo.44.1">hdf5file = h5py.File('h5py_demo.hdf5')</span><br/><span class="koboSpan" id="kobo.45.1">dataset1 = hdf5file.create_dataset('global_power',data=arr)</span><br/><span class="koboSpan" id="kobo.46.1">hdf5file.close()</span></pre>
<p><kbd><span class="koboSpan" id="kobo.47.1">h5py</span></kbd><span class="koboSpan" id="kobo.48.1"> provides an </span><kbd><span class="koboSpan" id="kobo.49.1">attrs</span></kbd><span class="koboSpan" id="kobo.50.1"> proxy object with a dictionary-like interface to store and retrieve metadata about the file, folders, and datasets. </span><span class="koboSpan" id="kobo.50.2">For example, the following code sets and then prints the dataset and file </span><span><span class="koboSpan" id="kobo.51.1">attribute</span></span><span><span class="koboSpan" id="kobo.52.1">:</span></span></p>
<pre><span class="koboSpan" id="kobo.53.1">dataset1.attrs['owner']='City Corp.'</span><br/><span class="koboSpan" id="kobo.54.1">print(dataset1.attrs['owner'])</span><br/><br/><span class="koboSpan" id="kobo.55.1">hdf5file.attrs['security_level']='public'</span><br/><span class="koboSpan" id="kobo.56.1">print(hdf5file.attrs['security_level'])</span></pre>
<p><span class="koboSpan" id="kobo.57.1">For more information about the </span><kbd><span class="koboSpan" id="kobo.58.1">h5py</span></kbd><span class="koboSpan" id="kobo.59.1"> library, refer to the documentation at the following link: </span><a href="http://docs.h5py.org/en/latest/index.html"><span class="koboSpan" id="kobo.60.1">http://docs.h5py.org/en/latest/index.html</span></a><span class="koboSpan" id="kobo.61.1">.</span></p>
<p><span class="koboSpan" id="kobo.62.1">So far, we have learned about different data formats. </span><span class="koboSpan" id="kobo.62.2">Often, large data is stored commercially in databases, therefore we will explore how to access both SQL and NoSQL databases next.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">SQL data</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Most databases are organized using relational models. </span><span class="koboSpan" id="kobo.2.2">A relational database consists of one or more related tables of information, and the relationship between information in different tables is described using keys. </span><span class="koboSpan" id="kobo.2.3">Conventionally, these databases are managed using the </span><strong><span class="koboSpan" id="kobo.3.1">Database Management System</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">DBMS</span></strong><span class="koboSpan" id="kobo.6.1">), software which interacts with end users, different applications, and the database itself to capture and analyze data. </span><span class="koboSpan" id="kobo.6.2">Commercially available DBMSes use </span><strong><span class="koboSpan" id="kobo.7.1">Structured Query Language</span></strong><span class="koboSpan" id="kobo.8.1"> (</span><strong><span class="koboSpan" id="kobo.9.1">SQL</span></strong><span class="koboSpan" id="kobo.10.1">) to access and manipulate databases. </span><span class="koboSpan" id="kobo.10.2">We can also use Python to access relational databases. </span><span class="koboSpan" id="kobo.10.3">In this section, we will explore SQLite and MySQL, two very popular database engines that work with Python.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The SQLite database engine</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">According to the SQLite home page (</span><a href="https://sqlite.org/index.html"><span class="koboSpan" id="kobo.3.1">https://sqlite.org/index.html</span></a><span class="koboSpan" id="kobo.4.1">), </span><em><span class="koboSpan" id="kobo.5.1">SQLite is a self-contained, high-reliability, embedded, full-featured, public-domain SQL database engine</span></em><span class="koboSpan" id="kobo.6.1">.</span></p>
<p><span class="koboSpan" id="kobo.7.1">SQLite is optimized for use in embedded applications. </span><span class="koboSpan" id="kobo.7.2">It is simple to use and quite fast. </span><span class="koboSpan" id="kobo.7.3">We need to use the </span><kbd><span class="koboSpan" id="kobo.8.1">sqlite3</span></kbd> <span><span class="koboSpan" id="kobo.9.1">Python module </span></span><span class="koboSpan" id="kobo.10.1">to integrate SQLite with Python. </span><span class="koboSpan" id="kobo.10.2">The </span><kbd><span class="koboSpan" id="kobo.11.1">sqlite3</span></kbd><span class="koboSpan" id="kobo.12.1"> module is bundled with Python 3, so there is no need to install it. </span></p>
<p><span class="koboSpan" id="kobo.13.1">We will use the data from the European Soccer Database (</span><a href="https://github.com/hugomathien/football-data-collection"><span class="koboSpan" id="kobo.14.1">https://github.com/hugomathien/football-data-collection</span></a><span class="koboSpan" id="kobo.15.1">) for demonstrative purposes. </span><span class="koboSpan" id="kobo.15.2">We assume that you already have a SQL server installed and started:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.16.1">The first step after importing </span><kbd><span class="koboSpan" id="kobo.17.1">sqlite3</span></kbd><span class="koboSpan" id="kobo.18.1"> is to create a connection to the database using the </span><kbd><span class="koboSpan" id="kobo.19.1">connect</span></kbd><span class="koboSpan" id="kobo.20.1"> method:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.21.1">import sqlite3 </span><br/><span class="koboSpan" id="kobo.22.1">import pandas as pd</span><br/><span class="koboSpan" id="kobo.23.1">connection = sqlite3.connect('database.sqlite')</span><br/><span class="koboSpan" id="kobo.24.1">print("Database opened successfully")</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.25.1">The European Soccer Database consists of eight tables. </span><span class="koboSpan" id="kobo.25.2">We can use </span><kbd><span class="koboSpan" id="kobo.26.1">read_sql</span></kbd><span class="koboSpan" id="kobo.27.1"> to read the database table or SQL query into the DataFrame. </span><span class="koboSpan" id="kobo.27.2">This prints a list of all the tables in the database:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.28.1">tables = pd.read_sql("SELECT * FROM sqlite_master WHERE </span><br/><span class="koboSpan" id="kobo.29.1">        type='table';", connection)</span><br/><span class="koboSpan" id="kobo.30.1">print(tables)</span></pre>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.31.1"><img src="assets/94e3fff5-08d7-4fe5-ae06-5be6fdd7816a.png" style="width:38.58em;height:23.42em;"/></span></p>
<ol start="3">
<li><span class="koboSpan" id="kobo.32.1">Let's read data from the </span><kbd><span class="koboSpan" id="kobo.33.1">Country</span></kbd><span class="koboSpan" id="kobo.34.1"> table:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.35.1">countries = pd.read_sql("SELECT * FROM Country;", connection)</span><br/><span class="koboSpan" id="kobo.36.1">countries.head()</span></pre>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.37.1"><img src="assets/5836ebd8-3242-4d4e-9db5-f0ac1f3b2a3b.png" style="width:11.83em;height:13.75em;"/></span></p>
<p class="mce-root"/>
<ol start="4">
<li><span class="koboSpan" id="kobo.38.1">We can use SQL queries on tables. </span><span class="koboSpan" id="kobo.38.2">In the following example, we select players whose height is greater than or equal to </span><kbd><span class="koboSpan" id="kobo.39.1">180</span></kbd><span class="koboSpan" id="kobo.40.1"> and whose weight is greater than or equal to </span><kbd><span class="koboSpan" id="kobo.41.1">170</span></kbd><span class="koboSpan" id="kobo.42.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.43.1">selected_players = pd.read_sql_query("SELECT * FROM Player WHERE</span><br/><span class="koboSpan" id="kobo.44.1">         height &gt;= 180 AND weight &gt;= 170 ", connection)</span><br/><span class="koboSpan" id="kobo.45.1">print(selected_players)</span></pre>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.46.1"><img src="assets/4f0a7a4b-6b6f-4a6a-b613-aa60f23e8ca8.png" style="width:49.33em;height:15.25em;"/></span></p>
<ol start="5">
<li><span class="koboSpan" id="kobo.47.1">Finally, do not forget to close the connection using the </span><kbd><span class="koboSpan" id="kobo.48.1">close</span></kbd><span class="koboSpan" id="kobo.49.1"> method:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.50.1">connection.close()</span></pre>
<p><span class="koboSpan" id="kobo.51.1">If you made any changes in the database, you will need to use the </span><kbd><span class="koboSpan" id="kobo.52.1">commit()</span></kbd><span class="koboSpan" id="kobo.53.1"> method.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The MySQL database engine</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Though we can use SQLite </span><span><span class="koboSpan" id="kobo.3.1">for</span></span><span><span class="koboSpan" id="kobo.4.1"> </span></span><span><span class="koboSpan" id="kobo.5.1">large databases, MySQL is generally preferred. </span><span class="koboSpan" id="kobo.5.2">In addition to being scalable for large databases, MySQL is also useful where data security is paramount. </span><span class="koboSpan" id="kobo.5.3">Before using MySQL, you will need to install the Python MySQL connector. </span><span class="koboSpan" id="kobo.5.4">There are many possible Python MySQL connectors such as, MySQLdb, PyMySQL, and MySQL; we will use</span></span> <kbd><span class="koboSpan" id="kobo.6.1">mysql-connector-python</span></kbd><span><span class="koboSpan" id="kobo.7.1">.</span></span></p>
<p><span><span class="koboSpan" id="kobo.8.1">In all three, after making a connection using the</span></span> <kbd><span class="koboSpan" id="kobo.9.1">connect</span></kbd> <span><span class="koboSpan" id="kobo.10.1">method, we define the</span></span> <kbd><span class="koboSpan" id="kobo.11.1">cursor</span></kbd> <span><span class="koboSpan" id="kobo.12.1">element and use</span><span><span class="koboSpan" id="kobo.13.1"> the</span></span></span> <kbd><span class="koboSpan" id="kobo.14.1">execute</span></kbd> <span><span class="koboSpan" id="kobo.15.1">method to run different SQL queries. </span><span class="koboSpan" id="kobo.15.2">To install MySQL, we use the following:</span></span></p>
<pre><span class="koboSpan" id="kobo.16.1">pip install mysql-connector-python </span></pre>
<ol>
<li><span class="koboSpan" id="kobo.17.1">Now that</span><span><span class="koboSpan" id="kobo.18.1"> the</span></span><span class="koboSpan" id="kobo.19.1"> Python MySQL connector is installed, we can start a connection with the SQL server. </span><span class="koboSpan" id="kobo.19.2">Replace the </span><kbd><span class="koboSpan" id="kobo.20.1">host</span></kbd><span class="koboSpan" id="kobo.21.1">, </span><kbd><span class="koboSpan" id="kobo.22.1">user</span></kbd><span class="koboSpan" id="kobo.23.1">, and </span><kbd><span class="koboSpan" id="kobo.24.1">password</span></kbd><span class="koboSpan" id="kobo.25.1"> configurations with your SQL server configuration:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.26.1">import mysql.connector </span><br/><span class="koboSpan" id="kobo.27.1">connection = mysql.connector.connect(host="127.0.0.1", # your host </span><br/><span class="koboSpan" id="kobo.28.1">        user="root", # username</span><br/><span class="koboSpan" id="kobo.29.1">        password="**********" ) # password</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.30.1">Let's check existing databases in the server and list them. </span><span class="koboSpan" id="kobo.30.2">To do this, we use the </span><kbd><span class="koboSpan" id="kobo.31.1">cursor</span></kbd><span class="koboSpan" id="kobo.32.1"> method:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.33.1">mycursor = connection.cursor()</span><br/><span class="koboSpan" id="kobo.34.1">mycursor.execute("SHOW DATABASES")</span><br/><span class="koboSpan" id="kobo.35.1">for x in mycursor:</span><br/><span class="koboSpan" id="kobo.36.1">    print(x)</span></pre>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.37.1"><img src="assets/303fb99e-29d7-48b9-9ef8-00eecf6b76de.png"/></span></p>
<ol start="3">
<li><span class="koboSpan" id="kobo.38.1">We can access one of the existing databases. </span><span class="koboSpan" id="kobo.38.2">Let's list the tables in one of the databases:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.39.1">connection = mysql.connector.connect(host="127.0.0.1", # your host </span><br/><span class="koboSpan" id="kobo.40.1">user="root", # username</span><br/><span class="koboSpan" id="kobo.41.1">password="**********" ,  #replace with your password</span><br/><span class="koboSpan" id="kobo.42.1">database = 'mysql')</span><br/><span class="koboSpan" id="kobo.43.1">mycursor = connection.cursor()</span><br/><span class="koboSpan" id="kobo.44.1">mycursor.execute("SHOW TABLES")</span><br/><span class="koboSpan" id="kobo.45.1">for x in mycursor:</span><br/><span class="koboSpan" id="kobo.46.1">    print(x)</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">NoSQL data</span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">The </span><strong><span class="koboSpan" id="kobo.3.1">Not Only Structured Query Language</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">NoSQL</span></strong><span class="koboSpan" id="kobo.6.1">) database is not a relational database; instead, data can be stored in </span></span><span class="koboSpan" id="kobo.7.1">key-value, JSON, document, columnar, or graph formats. </span><span class="koboSpan" id="kobo.7.2">They are frequently used in big data and real-time applications. </span><span class="koboSpan" id="kobo.7.3">We will learn here how to access NoSQL data using MongoDB, and we assume you have the MongoDB server configured properly and on:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.8.1">We will need to establish a connection with the Mongo daemon using the </span><kbd><span class="koboSpan" id="kobo.9.1">MongoClient</span></kbd><span class="koboSpan" id="kobo.10.1"> object. </span><span class="koboSpan" id="kobo.10.2">The </span><span><span class="koboSpan" id="kobo.11.1">following </span></span><span class="koboSpan" id="kobo.12.1">code establishes the connection to the default host, </span><kbd><span class="koboSpan" id="kobo.13.1">localhost</span></kbd><span class="koboSpan" id="kobo.14.1"> , and port (</span><kbd><span class="koboSpan" id="kobo.15.1">27017</span></kbd><span class="koboSpan" id="kobo.16.1">). </span><span class="koboSpan" id="kobo.16.2">And it gives us access to the database:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.17.1">from pymongo import MongoClient</span><br/><span class="koboSpan" id="kobo.18.1">client = MongoClient()</span><br/><span class="koboSpan" id="kobo.19.1">db = client.test</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.20.1">In this example, we try to load the </span><kbd><span class="koboSpan" id="kobo.21.1">cancer</span></kbd><span class="koboSpan" id="kobo.22.1"> dataset available in scikit-learn to the Mongo database. </span><span class="koboSpan" id="kobo.22.2">So, we first get the breast cancer dataset and convert it to a pandas DataFrame:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.23.1">from sklearn.datasets import load_breast_cancer</span><br/><span class="koboSpan" id="kobo.24.1">import pandas as pd</span><br/><br/><span class="koboSpan" id="kobo.25.1">cancer = load_breast_cancer()</span><br/><span class="koboSpan" id="kobo.26.1">data = pd.DataFrame(cancer.data, columns=[cancer.feature_names])</span><br/><br/><span class="koboSpan" id="kobo.27.1">data.head()</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.28.1">Next, we convert this into</span><span><span class="koboSpan" id="kobo.29.1"> the</span></span><span class="koboSpan" id="kobo.30.1"> JSON format, use the </span><kbd><span class="koboSpan" id="kobo.31.1">json.loads()</span></kbd><span class="koboSpan" id="kobo.32.1"> function to decode it, and insert the decoded data into the open database:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.33.1">import json</span><br/><span class="koboSpan" id="kobo.34.1">data_in_json = data.to_json(orient='split')</span><br/><span class="koboSpan" id="kobo.35.1">rows = json.loads(data_in_json)</span><br/><span class="koboSpan" id="kobo.36.1">db.cancer_data.insert(rows)</span></pre>
<p class="mce-root"/>
<ol start="4">
<li><span class="koboSpan" id="kobo.37.1">This will create a collection named </span><kbd><span class="koboSpan" id="kobo.38.1">cancer_data</span></kbd><span class="koboSpan" id="kobo.39.1"> that contains the data. We can query the document we just created, using the </span><kbd><span class="koboSpan" id="kobo.40.1">cursor</span></kbd><span class="koboSpan" id="kobo.41.1"> object:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.42.1">cursor = db['cancer_data'].find({})</span><br/><span class="koboSpan" id="kobo.43.1">df = pd.DataFrame(list(cursor))</span><br/><span class="koboSpan" id="kobo.44.1">print(df)</span></pre>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.45.1"><img src="assets/cc5f0782-9f58-4952-b32a-fb0a42de7824.png" style="width:38.33em;height:14.08em;"/></span></p>
<p><span><span class="koboSpan" id="kobo.46.1">When it comes to distributed data on the IoT, </span><strong><span class="koboSpan" id="kobo.47.1">Hadoop Distributed File System </span></strong><span class="koboSpan" id="kobo.48.1">(</span><strong><span class="koboSpan" id="kobo.49.1">HDFS</span></strong><span class="koboSpan" id="kobo.50.1">) is another popular method for providing distributed data storage and access in IoT systems. </span><span class="koboSpan" id="kobo.50.2">In the next section, we study how to access and store data in HDFS.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">HDFS</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">HDFS is a popular storage and access method for storing and retrieving data files for IoT solutions. </span><span class="koboSpan" id="kobo.2.2">The HDFS format can hold large amounts of data in a reliable and scalable manner. </span><span class="koboSpan" id="kobo.2.3">Its design is based on the </span><strong><span class="koboSpan" id="kobo.3.1">Google File System</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><a href="https://ai.google/research/pubs/pub51"><span class="koboSpan" id="kobo.5.1">https://ai.google/research/pubs/pub51</span></a><span class="koboSpan" id="kobo.6.1">). </span><span class="koboSpan" id="kobo.6.2">HDFS splits individual files into fixed-size blocks that are stored on machines across the cluster. </span><span class="koboSpan" id="kobo.6.3">To ensure reliability, it replicates the file blocks and distributes them across the cluster; by default, the replication factor is 3. </span><span class="koboSpan" id="kobo.6.4">HDFS has two main architecture components:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">The first, </span><strong><span class="koboSpan" id="kobo.8.1">NodeName</span></strong><span class="koboSpan" id="kobo.9.1">, stores the metadata for the entire filesystem, such as filenames, their permissions, and the location of each block of each file. </span></li>
<li><span class="koboSpan" id="kobo.10.1">The second, </span><strong><span class="koboSpan" id="kobo.11.1">DataNode</span></strong><span class="koboSpan" id="kobo.12.1"> (one or more), is where file blocks are stored. </span><span class="koboSpan" id="kobo.12.2">It performs </span><span><strong><span class="koboSpan" id="kobo.13.1">Remote Procedure Calls</span></strong><span class="koboSpan" id="kobo.14.1"> (</span><strong><span class="koboSpan" id="kobo.15.1">RPCs</span></strong><span class="koboSpan" id="kobo.16.1">) using protobufs.</span></span></li>
</ul>
<p class="mce-root"/>
<div class="packt_infobox">
<p><strong><span class="koboSpan" id="kobo.17.1">RPC</span></strong><span class="koboSpan" id="kobo.18.1"> is a protocol that one program can use to request a service from a program located on another computer on a network without having to know the network's details. </span><span class="koboSpan" id="kobo.18.2">A procedure call is also sometimes known as a </span><strong><span class="koboSpan" id="kobo.19.1">function call</span></strong><span class="koboSpan" id="kobo.20.1"> or a </span><strong><span class="koboSpan" id="kobo.21.1">subroutine call</span></strong><span class="koboSpan" id="kobo.22.1">.</span></p>
</div>
<p><span class="koboSpan" id="kobo.23.1">There are many options for programmatically accessing HDFS in Python, such as </span><kbd><span class="koboSpan" id="kobo.24.1">snakebite</span></kbd><span class="koboSpan" id="kobo.25.1">, </span><kbd><span class="koboSpan" id="kobo.26.1">pyarrow</span></kbd><span class="koboSpan" id="kobo.27.1">, </span><kbd><span class="koboSpan" id="kobo.28.1">hdfs3</span></kbd><span class="koboSpan" id="kobo.29.1">, </span><kbd><span class="koboSpan" id="kobo.30.1">pywebhdfs</span></kbd><span class="koboSpan" id="kobo.31.1">, </span><kbd><span class="koboSpan" id="kobo.32.1">hdfscli</span></kbd><span class="koboSpan" id="kobo.33.1">, and so on. </span><span class="koboSpan" id="kobo.33.2">In this section, we will focus mainly on libraries that provide native RPC client interfaces and work with Python 3.</span></p>
<div class="packt_infobox"><span><span class="koboSpan" id="kobo.34.1">Snakebite is a pure Python module and CLI that allows you to access HDFS from Python programs.</span></span><span class="koboSpan" id="kobo.35.1"> </span><span><span class="koboSpan" id="kobo.36.1">At present, it only works with Python 2; Python 3 is not supported. </span><span class="koboSpan" id="kobo.36.2">Moreover, i</span></span><span><span class="koboSpan" id="kobo.37.1">t does not yet support write operations, and so we are not including it in the book. </span><span class="koboSpan" id="kobo.37.2">However, if you are interested in knowing more about this, you can refer to Spotify's GitHub: </span><a href="https://github.com/spotify/snakebite"><span class="koboSpan" id="kobo.38.1">https://github.com/spotify/snakebite</span></a><span class="koboSpan" id="kobo.39.1">.</span></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using hdfs3 with HDFS</span></h1>
                </header>
            
            <article>
                
<p><kbd><span class="koboSpan" id="kobo.2.1">hdfs3</span></kbd><span class="koboSpan" id="kobo.3.1"> is a lightweight Python wrapper around the C/C++ </span><kbd><span class="koboSpan" id="kobo.4.1">libhdfs3</span></kbd><span class="koboSpan" id="kobo.5.1"> library. </span><span class="koboSpan" id="kobo.5.2">It allows us to use HDFS natively from Python. </span><span class="koboSpan" id="kobo.5.3">To start, we first need to connect with the HDFS NameNode; this is done using the </span><kbd><span class="koboSpan" id="kobo.6.1">HDFileSystem</span></kbd><span class="koboSpan" id="kobo.7.1"> class:</span></p>
<pre><span class="koboSpan" id="kobo.8.1">from hdfs3 import HDFileSystem</span><br/><span class="koboSpan" id="kobo.9.1">hdfs = HDFileSystem(host = 'localhost', port=8020)</span></pre>
<p><span class="koboSpan" id="kobo.10.1">This automatically establishes a connection with the NameNode. </span><span class="koboSpan" id="kobo.10.2">Now, we can access a directory listing using the following:</span></p>
<pre><span class="koboSpan" id="kobo.11.1">print(hdfs.ls('/tmp')) </span></pre>
<p><span class="koboSpan" id="kobo.12.1">This will list all the files and directories in the </span><kbd><span class="koboSpan" id="kobo.13.1">tmp</span></kbd><span class="koboSpan" id="kobo.14.1"> folder. </span><span class="koboSpan" id="kobo.14.2">You can use functions such as </span><kbd><span class="koboSpan" id="kobo.15.1">mkdir</span></kbd><span class="koboSpan" id="kobo.16.1"> to make a directory and </span><kbd><span class="koboSpan" id="kobo.17.1">cp</span></kbd><span class="koboSpan" id="kobo.18.1"> to copy a file from one location to another. </span><span class="koboSpan" id="kobo.18.2">To write into a file, we open it first using the </span><kbd><span class="koboSpan" id="kobo.19.1">open</span></kbd><span class="koboSpan" id="kobo.20.1"> method and use </span><kbd><span class="koboSpan" id="kobo.21.1">write</span></kbd><span class="koboSpan" id="kobo.22.1">:</span></p>
<pre><span class="koboSpan" id="kobo.23.1">with hdfs.open('/tmp/file1.txt','wb') as f:</span><br/><span class="koboSpan" id="kobo.24.1">    f.write(b'You are Awesome!')</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.25.1">Data can be read from the file:</span></p>
<pre><span class="koboSpan" id="kobo.26.1">with hdfs.open('/tmp/file1.txt') as f:</span><br/><span class="koboSpan" id="kobo.27.1">    print(f.read())</span></pre>
<p><span class="koboSpan" id="kobo.28.1">You can learn more about </span><kbd><span class="koboSpan" id="kobo.29.1">hdfs3</span></kbd><span class="koboSpan" id="kobo.30.1"> from its documentation: </span><a href="https://media.readthedocs.org/pdf/hdfs3/latest/hdfs3.pdf"><span class="koboSpan" id="kobo.31.1">https://media.readthedocs.org/pdf/hdfs3/latest/hdfs3.pdf</span></a><span class="koboSpan" id="kobo.32.1">. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using PyArrow's filesystem interface for HDFS</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">PyArrow has a C++-based interface for HDFS. </span><span class="koboSpan" id="kobo.2.2">By default, it uses </span><kbd><span class="koboSpan" id="kobo.3.1">libhdfs</span></kbd><span class="koboSpan" id="kobo.4.1">, a JNI-based interface, for the Java Hadoop client. </span><span class="koboSpan" id="kobo.4.2">Alternatively, we can also use </span><kbd><span class="koboSpan" id="kobo.5.1">libhdfs3</span></kbd><span class="koboSpan" id="kobo.6.1">, a C++ library for HDFS. </span><span class="koboSpan" id="kobo.6.2">We connect to the NameNode using </span><kbd><span class="koboSpan" id="kobo.7.1">hdfs.connect</span></kbd><span class="koboSpan" id="kobo.8.1">:</span></p>
<pre><span class="koboSpan" id="kobo.9.1">import pyarrow as pa</span><br/><span class="koboSpan" id="kobo.10.1">hdfs = pa.hdfs.connect(host='hostname', port=8020, driver='libhdfs')</span></pre>
<p><span class="koboSpan" id="kobo.11.1">If we change the driver to </span><kbd><span class="koboSpan" id="kobo.12.1">libhdfs3</span></kbd><span class="koboSpan" id="kobo.13.1">, we will be using the C++ library for HDFS from Pivotal Labs. </span><span class="koboSpan" id="kobo.13.2">Once the connection to the NameNode is made, the filesystem is accessed using the same methods as for hdfs3. </span></p>
<p><span class="koboSpan" id="kobo.14.1">HDFS is preferred when the data is extremely large. </span><span class="koboSpan" id="kobo.14.2">It allows us to read and write data in chunks; this is helpful for accessing and processing streaming data. </span><span class="koboSpan" id="kobo.14.3">A nice comparison of the three native RPC client interfaces is presented in the following blog post: </span><a href="http://wesmckinney.com/blog/python-hdfs-interfaces/"><span class="koboSpan" id="kobo.15.1">http://wesmckinney.com/blog/python-hdfs-interfaces/</span></a><span class="koboSpan" id="kobo.16.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This chapter dealt with many different data formats, and, in the process, many different datasets. </span><span class="koboSpan" id="kobo.2.2">We started with the simplest TXT data and accessed the </span><kbd><span class="koboSpan" id="kobo.3.1">Shakespeare</span></kbd><span class="koboSpan" id="kobo.4.1"> play data. </span><span class="koboSpan" id="kobo.4.2">We learned how to read data from CSV files using the </span><kbd><span class="koboSpan" id="kobo.5.1">csv</span></kbd><span class="koboSpan" id="kobo.6.1">, </span><kbd><span class="koboSpan" id="kobo.7.1">numpy</span></kbd><span class="koboSpan" id="kobo.8.1">, and </span><kbd><span class="koboSpan" id="kobo.9.1">pandas</span></kbd><span class="koboSpan" id="kobo.10.1"> modules. </span><span class="koboSpan" id="kobo.10.2">We moved on to the JSON format; we used Python's JSON and pandas modules to access JSON data. </span><span class="koboSpan" id="kobo.10.3">From data formats, we progressed to accessing databases and covered both SQL and NoSQL databases. </span><span class="koboSpan" id="kobo.10.4">Next, we learned how to work with the Hadoop File System in Python.</span></p>
<p><span class="koboSpan" id="kobo.11.1">Accessing data is the first step. </span><span class="koboSpan" id="kobo.11.2">In the next chapter, we will learn about machine learning tools that will help us to design, model, and make informed predictions on data. </span></p>


            </article>

            
        </section>
    </body></html>