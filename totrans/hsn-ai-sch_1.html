<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Understanding the Depth-First Search Algorithm</h1>
                </header>
            
            <article>
                
<p>Search algorithms have various applications in industrial and research-based AI solutions, related to computer vision, machine learning, and robotics. As we progress through the chapters in this book, we will teach you how to use AI in search applications. Searching is something that we do every day, whether we are searching for a song in our filesystem, searching for a friend or colleague on a social network, or finding the best route to a destination. In this chapter, you will learn about the <strong>Depth-First Search </strong>(<strong>DFS</strong>) algorithm and develop a file search application.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Installing and setting up libraries</li>
<li>Introducing file search applications</li>
<li>Formulation of the search problem</li>
<li>Building search trees with nodes</li>
<li>Stacks and DFS</li>
<li>Recursive DFS</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing and setting up libraries</h1>
                </header>
            
            <article>
                
<p>Before we get into the basic concepts of searching, we will take a look at the following libraries that have to be installed and how to install them in Windows:</p>
<ul>
<li><strong>Python</strong>: You can download and install Python libraries from <a href="https://www.python.org/downloads/" target="_blank"><span class="URLPACKT">https://www.python.org/downloads/</span></a><span class="URLPACKT">,</span> depending on your operating system</li>
<li><strong>Graphviz</strong>: This open source graph visualization software can be downloaded from <a href="http://graphviz.org/download/" target="_blank"><span class="URLPACKT">http://graphviz.org/download/</span></a></li>
</ul>
<ul>
<li><strong>Pip</strong>: The tools for installing Python packages are as follows:
<ul>
<li><strong>Pydot</strong>: A Python interface to Graphviz's DOT language</li>
<li><strong>Matplotlib</strong>: This is a Python 2D plotting library</li>
</ul>
</li>
</ul>
<p>Execute the steps in the following section to install the preceding libraries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up Python</h1>
                </header>
            
            <article>
                
<p>The steps for setting up Python are as follows:</p>
<ol>
<li>For the applications in this book, we'll be using Python 2.7.6, which we can download from <span class="URLPACKT"><a href="https://www.python.org/downloads/" target="_blank">https://www.python.org/downloads/</a>. <a href="https://www.python.org/downloads/" target="_blank"/></span><a href="https://www.python.org/downloads/" target="_blank"/></li>
<li>Once an appropriate installer has been downloaded, double-click on it and go ahead with the default options.</li>
<li>Based on your operating system, select the Python installer to download, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a69f6903-1c5b-4389-8ab6-7a57d3fd8060.png" style="width:38.33em;height:24.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1</div>
<ol start="4">
<li>The following screenshot shows the location where Python will be installed; make a note of this location:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d654d4e8-ce32-49b9-8ccd-376ea8c70543.png" style="width:33.00em;height:28.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 2</span></div>
<p style="padding-left: 60px">   Now, Python will be installed. </p>
<ol start="5">
<li>The next step is to add Python's path to the <span class="packt_screen">Path</span> environment variable. In the <span class="packt_screen">System Properties</span> | <span class="packt_screen">Advanced</span> tab, click on the <span class="packt_screen">Environment Variables...</span> button.</li>
<li>In the <span class="packt_screen">Environment Variables…</span> window, go to <span class="packt_screen">System variables</span> | <span class="packt_screen">Path</span> and add the Python location that you made a note of in step 4 (which is <kbd>C:\Python27</kbd> <span>in our case).</span></li>
</ol>
<ol start="7">
<li>Now, to check whether Python works, open the Command Prompt and type in the <kbd>python -- version</kbd> command. You will get the following output:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a3add63b-bf93-4f72-b373-1d1d30dd67d4.png" style="width:40.08em;height:11.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 3</span></div>
<p style="padding-left: 60px">The output shown in the preceding screenshot confirms that Python has been installed successfully.</p>
<div class="packt_tip">Depending on your OS, Python might already be installed.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up Graphviz</h1>
                </header>
            
            <article>
                
<p>The following steps describe how to set up Graphviz:</p>
<ol>
<li>We can download the graph visualization software from <span class="URLPACKT"><span class="URLPACKT"><span class="URLPACKT"><a href="https://graphviz.gitlab.io/download/" target="_blank">https://graphviz.gitlab.io/download/</a>.</span></span></span></li>
<li>Since we are using Windows, we select the option that says <span class="packt_screen">Stable 2.38 Windows install packages</span>, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-312 image-border" src="assets/22dc30da-0297-4cc3-ae22-084a6b1ea628.png" style="width:35.75em;height:15.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 4</span></div>
<p style="padding-left: 90px">Select the <kbd>.msi</kbd> downloadable file, shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a3024418-040a-4e8a-b209-048d6ebc6b3d.png" style="width:38.83em;height:29.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span><span>Figure 5</span></span></div>
<ol start="3">
<li>Once the Graphviz executable has downloaded, go ahead and install the file with the default options; again, make a note of the path, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ae569a58-5e7c-4210-b63d-317742b8a89f.png" style="width:34.17em;height:27.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 6</span></div>
<ol start="4">
<li>Now, we will add Graphviz's <kbd>bin</kbd> folder to the path variable, as we did when installing Python in the previous section. Then, copy the location where Graphviz is installed and append <kbd>\bin</kbd>, <span><span>as shown in the following screenshot:</span></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/808cf99e-6ab7-4f65-bfe7-ee2656286d14.png" style="width:29.92em;height:28.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 7</span></div>
<ol start="5">
<li>To validate whether this library has been installed properly, open a new Command Prompt window and type the <kbd>dot -V</kbd> command, and you will get the following result:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f2250773-1e65-431f-b114-355718b635fa.png" style="width:31.00em;height:10.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 8</span></div>
<p style="padding-left: 60px">The output shown in the preceding screenshot confirms that Graphviz has been installed successfully.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing pip</h1>
                </header>
            
            <article>
                
<p>The steps for installing <kbd>pip</kbd> are as follows:</p>
<ol>
<li>To install <kbd>pip</kbd>, you need to download the <kbd>get-pip.py</kbd> file from <a href="https://bootstrap.pypa.io/get-pip.py" target="_blank"><span class="URLPACKT">https://bootstrap.pypa.io/get-pip.py</span></a>, and make a note of the path where the file is located. In my case, the file is located at <kbd>Documents\ai\softwares</kbd>.</li>
<li>Open the Command Prompt and go to the <kbd>Documents\ai\softwares</kbd> folder by using the <kbd>cd</kbd> command, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2243f76b-e104-4999-81f8-fb565ef2309f.png" style="width:31.00em;height:12.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 9</span></div>
<ol start="3">
<li>Use the <kbd>dir</kbd> command to take a look at the contents of this folder, where you will see <kbd>get-pip.py</kbd>, shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/836efaf0-29f1-4d98-9a4a-d7db0d3d16fd.png" style="width:31.75em;height:20.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 10</span></div>
<ol start="4">
<li> Next, we'll run the <kbd>python get-pip.py</kbd> command. </li>
<li>Now, let's add Python's <kbd>scripts</kbd> folder to the <span class="packt_screen">Path</span> environment variable.</li>
<li>Open another Command Prompt window and test the installation of <kbd>pip</kbd> by typing the <kbd>pip --version</kbd> <span>command</span>. Upon successful installation, you will get the following output:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9bf3bf4a-7a5c-4267-913f-aa551af882a4.png" style="width:42.67em;height:11.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 11</span></div>
<ol start="7">
<li>Once <kbd>pip</kbd> has installed, you can install <kbd>pydot</kbd> by running the following command:</li>
</ol>
<pre style="padding-left: 90px"><strong>pip install pydot</strong> </pre>
<ol start="8">
<li>Finally, install <kbd>matplotlib</kbd> by executing the following command:</li>
</ol>
<pre style="padding-left: 90px"><strong>pip install matplotlib</strong>  </pre>
<ol start="9">
<li>We can check whether the libraries have been installed properly by using the <kbd>import</kbd> command in Python's interpreter, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4a0338f6-f0f9-4095-9aa5-5150ca6cd333.png" style="width:47.42em;height:14.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 12</span></div>
<p>Now, we're done installing the libraries that we will need in Windows <span>for this book </span>. In the next topic, we will look at how we can go about developing a file search application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to file searching applications</h1>
                </header>
            
            <article>
                
<p>In file managers, file searching is used to find files with specific names. In IDEs, file searching is used to find program files with specific code text.</p>
<p>In this topic, we'll develop the first example in order to find a file named <kbd>f211.txt</kbd>. The folder structure is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-313 image-border" src="assets/ed824895-a7c2-4a7c-85c4-3f8515362903.png" style="width:13.83em;height:28.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 13</span></div>
<p>This folder structure can be represented as a tree, as shown in the following diagram; the file that we're trying to find is shown with a green border:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ccfcc91d-f6a5-4b22-b0aa-2851f5f318c5.png" style="width:29.17em;height:15.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 14</span></div>
<p>Let's go ahead and look at how file searching will work to find this file:</p>
<ol>
<li>File searching starts in the <strong>current directory</strong>; it opens the first folder inside of that (<strong>d1</strong>) and opens the first folder in <strong>d1</strong> (<strong>d11</strong>). Inside of <strong>d11,</strong> it compares all of the filenames.</li>
<li>Since there's no more content inside of <strong>d11</strong>, the algorithm gets out of <strong>d11</strong>, goes inside of <strong>d1</strong>, and goes for the next folder, which is <strong>d12</strong>, comparing all of its files.</li>
<li>Now, it moves outside of <strong>d12</strong> and goes for the next folder inside of <strong>d1</strong> (<strong>f11</strong>), and then the next folder (<strong>f12</strong>).</li>
<li>Now, the search algorithm has covered all of the contents inside of the <strong>d1</strong> folder. So, it gets out of <strong>d1 </strong>and goes for the next folder inside of the <strong>current directory</strong>, which is <strong>d2</strong>.</li>
<li>Inside of <strong>d2</strong>, it opens the first folder (<strong>d21</strong>). Inside of <strong>d21</strong>, it compares all of the files, and we find the <strong>f211</strong> file that we're looking for.</li>
</ol>
<p>If you refer to the preceding folder structure, you will see that there's a pattern that is being repeated. When we reached <strong>f111</strong>, the algorithm had explored the leftmost part of the tree, upto its maximum depth. Once the maximum depth was reached, the algorithm backtracked to the previous level and went for the next subtree to the right. Again, in this case, the leftmost part of the subtree is explored, and, when we reach the maximum depth, the algorithm goes for the next subtree. This process is repeated until the file that we are searching for is found.</p>
<p>Now that we understand how the search algorithm functions logically, in the next topic, we will go through the main ingredients of searching, which are used for performing searching in this application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic search concepts</h1>
                </header>
            
            <article>
                
<p>To understand the functionality of search algorithms, we first need to understand basic searching concepts, such as the state, the ingredients of a search, and the nodes:</p>
<ul>
<li><strong>State</strong>: The state is defined as the space where the search process takes place. It basically answers the question—<em>what are we searching for?</em> For example, in a navigation application, a state is a place. In our search application, a state is a file or folder.</li>
<li><strong>Ingredients of a search</strong>: There are three main ingredients in a search algorithm. These ingredients are as follows, using the example of a treasure hunt:
<ul>
<li><strong>Initial state</strong>: This answers the question—<em>where do we begin our search?</em> In our example, the initial state would be the location where we begin our treasure hunt.</li>
<li><strong>Successor function</strong>: This answers the question—<em>how do we explore from the initial state?</em> In our example, the successor function should return all of the paths from the location where we began our treasure hunt.</li>
<li><strong>Goal function</strong>: This answers the question—<em>how will we know when we've found the solution?</em> In our example, the goal function returns true if you've found the place marked as the treasure.</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">The search ingredients are illustrated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/52509359-a71b-4cda-bfe1-39100207b526.png" style="width:41.83em;height:18.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 15</span></div>
<ul>
<li><strong>Node</strong>: A node is the basic unit of a tree. It may consist of data or links to other nodes.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Formulating the search problem</h1>
                </header>
            
            <article>
                
<p>In a file searching application, we start searching from the current directory, so our initial state is the current directory. Now, let's write the code for the state and the initial state, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c442b940-76bb-45e9-9208-82e45997e897.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 16</span></div>
<p>In the preceding screenshot, we have created two Python modules, <kbd>State.py</kbd> and <kbd>StateTest.py</kbd>. The <kbd>State.py</kbd> module will contain the code for the three search ingredients mentioned in the previous section. The <kbd>StateTest</kbd> <span>module</span> is a file where we can test these ingredients.</p>
<p>Let's go ahead and create a constructor and a function that returns an initial state, as shown in the following code:</p>
<pre>....<br/>import os <br/><br/>class State:<br/>    '''<br/>    This class retrieves state information for search application<br/>    '''<br/>    <br/>    def __init__(self, path = None):<br/>        if path == None:<br/>            #create initial state<br/>            self.path = self.getInitialState()<br/>        else:<br/>            self.path = path<br/>    <br/>    def getInitialState(self):<br/>        """<br/>        This method returns the current directory<br/>        """<br/>        initialState = os.path.dirname(os.path.realpath(__file__))<br/>        return initialState<br/> ....</pre>
<p>In the preceding code, the following apply:</p>
<ul>
<li>We have the constructor (the constructor name) and we have created a property called <kbd>path</kbd>, which stores the actual path of the state. In the preceding code example, we can see that the constructor takes <kbd>path</kbd> as an argument. The <kbd>if...else</kbd> block suggests that if the path is not provided, it will initialize the state as the initial state, and if the path is provided, it will create a state with that particular path.</li>
<li>The <kbd>getInitialState()</kbd> function returns the current working directory.</li>
</ul>
<p>Now, let's go ahead and create some sample states, as follows:</p>
<pre>...<br/>from State import State<br/>import os<br/>import pprint<br/><br/></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<pre>initialState = State()<br/>print "initialState", initialState.path<br/><br/>interState = State(os.path.join(initialState.path, "d2", "d21"))<br/>goalState = State(os.path.join(initialState.path, "d2", "d21", "f211.txt"))<br/><br/>print "interState", interState.path<br/>print "goalState", goalState.path<br/>....</pre>
<p>In the preceding code, we have created the following three states:</p>
<ul>
<li><kbd>initialState</kbd>, which points to the current directory</li>
<li><kbd>interState</kbd>, which is the intermediate function that points to the <kbd>d21</kbd> <span>folder </span></li>
<li><kbd>goalState</kbd>, which points to the <kbd>f211.txt</kbd> <span>folder </span></li>
</ul>
<p>Next, we will look at the <kbd>successor</kbd> function. If we're in a particular folder, the <kbd>successor</kbd> function should return the folders and files inside of that folder, and, if you're currently looking at a file, it should return an empty array. <span>Considering the following diagram, if the current state is <kbd>d2</kbd>, it should return paths to the <kbd>d21</kbd> and</span> <kbd>d22</kbd> <span>folders</span><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f23a39a5-3c83-4357-92f0-0dd93bc88518.png" style="width:13.08em;height:9.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 17</span></div>
<p>Now, let's create the preceding function with the following code:</p>
<pre>...<br/>    def successorFunction(self):<br/>        """<br/>        This is the successor function. It generates all the possible<br/>         paths that can be reached from current path.<br/>        """</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<pre>        if os.path.isdir(self.path):<br/>            return [os.path.join(self.path, x) for x in         <br/>            sorted(os.listdir(self.path))]<br/>        else:<br/>            return []<br/>...</pre>
<p>The preceding  function checks whether the current path is a directory. If it is a directory, it gets a sorted list of all of the folders and files inside it, and prepends the current path to them. If it is a file, it returns an empty array.</p>
<p>Now, let's test this function with some input. Open the <kbd>StateTest</kbd> module and take a look at the successors to the initial state and intermediate state:</p>
<pre>...<br/>initialState = State()<br/>print "initialState", initialState.path<br/><br/>interState = State(os.path.join(initialState.path, "d2", "d21"))<br/>goalState = State(os.path.join(initialState.path, "d2", "d21", "f211.txt"))<br/><br/>print "interState", interState.path<br/>print "goalState", goalState.path<br/>...</pre>
<p>As shown in the preceding code, the successors to the current directory (or the initial state) are the LiClipse project files and the folders <kbd>d1</kbd>, <kbd>d2</kbd>, and <kbd>d3</kbd>, and the successor of the intermediate state is the <kbd>f211.txt</kbd> <span>file</span>.  </p>
<p>The output of running the preceding code is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d8e41019-2d22-46c1-ac85-9392e155af13.png" style="width:62.75em;height:12.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 18</span></div>
<p>Finally, we will look at the goal function. So, how do we know that we have found the target file, <kbd>f211.txt</kbd>? Our goal function should return <kbd>False</kbd> for the <kbd>d21</kbd> <span> folder</span>, and <kbd>True</kbd> for the <kbd>f211.txt</kbd> <span>file </span>. Let's look at how to implement this function in code:</p>
<pre>...<br/>def checkGoalState(self):<br/>        """<br/>        This method checks whether the path is goal state <br/>        """ <br/>        #check if it is a folder<br/>        if os.path.isdir(self.path):<br/>            return False<br/>        else:<br/>            #extract the filename<br/>            fileSeparatorIndex = self.path.rfind(os.sep)<br/>            filename = self.path[fileSeparatorIndex + 1 : ]<br/>            if filename == "f211.txt":<br/>                return True<br/>            else:<br/>                return False<br/>...</pre>
<p>As shown in the preceding code, the function <kbd>checkGoalState()</kbd> is our goal function; this checks whether the current path is a directory. Now, since we are looking for a file, this returns <kbd>False</kbd> if it's a directory. If it is a file, it extracts the filename from the path. The filename is the substring of the path from the last occurrence of a slash to the end of the string. So, we extract the filename and compare it with <kbd>f211.txt</kbd>. If they match, we return <kbd>True</kbd>; otherwise, we return <kbd>False</kbd>.</p>
<p>Again, let's test this function for the states that we've created. To do so, open the <kbd>StateTest</kbd> module, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7987435d-366a-4c80-9456-cee0ed4dcf01.png" style="width:65.92em;height:13.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 19</span></div>
<p>As you can see, the function returns <kbd>False</kbd> for the current directory, it returns <kbd>False</kbd> for the <kbd>d21</kbd> <span>folder</span>, and it returns <kbd>True</kbd> for the <kbd>f211.txt</kbd> <span>file</span>.</p>
<p>Now that we understand the three ingredients in search algorithms, in the next section, we will look at building search trees with nodes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building trees with nodes</h1>
                </header>
            
            <article>
                
<p>In this topic, you'll be learning how to create a search tree with nodes. We will look at the concepts of states and nodes and the properties and methods of the node class, and we will show you how to create a tree with node objects. In our application, while the state is the path of the file or folder we are processing (for example, the current directory), the node is a node in the search tree (for example, the current directory node).</p>
<p>A node has many properties, and one of them is the state. The other properties are as follows:</p>
<ul>
<li><strong>Depth</strong>: This is the level of the node in the tree</li>
<li><strong>Reference to the parent node</strong>: This consists of links to the parent node</li>
<li><strong>References to the child nodes</strong>: This consists of links to the child nodes</li>
</ul>
<p>Let's look at a few examples, in order to understand these concepts more clearly:</p>
<ul>
<li>An example of these concepts in the <strong>current directory</strong> node is as follows:
<ul>
<li><strong>Depth</strong>: 0</li>
<li><strong>Reference to parent node</strong>: None</li>
<li><strong>References to children nodes</strong>: d1, d2, d3</li>
</ul>
</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-322 image-border" src="assets/b022eb2a-8994-490d-aa23-ed2490d9fc43.png" style="width:24.08em;height:15.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 20</span></div>
<ul>
<li>An example of these concepts in node <strong>d3</strong> is as follows:
<ul>
<li><strong>Depth</strong>: 1</li>
<li><strong>Reference to parent node</strong>: Current directory node</li>
<li><strong>Reference to children nodes</strong>: f31</li>
</ul>
</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/49246848-b68a-416b-bbc4-f52529a620ed.png" style="width:19.83em;height:15.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 21</span></div>
<ul>
<li>An example of the concepts for these file node <strong>f111</strong> is as follows:
<ul>
<li><strong>Depth</strong>: 3</li>
<li><strong>Reference to parent node</strong>: d11</li>
<li><strong>Reference to children node</strong>: []</li>
</ul>
</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a36b6308-e459-4f2b-ad3b-dca28765cdca.png" style="width:19.42em;height:19.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 22</span></div>
<p>Let's create a class called <kbd>Node</kbd>, which includes the four properties that we just discussed:</p>
<pre>...<br/>class Node:<br/>    '''<br/>    This class represents a node in the search tree<br/>    '''<br/>    <br/>    def __init__(self, state):<br/>        """<br/>        Constructor<br/>        """<br/>        self.state = state<br/>        self.depth = 0<br/>        self.children = []<br/>        self.parent = None<br/>...</pre>
<p>As shown in the preceding code, we have created a class called <kbd>Node</kbd>, and this class has a constructor that takes <kbd>state</kbd> as an argument. The <kbd>state</kbd> argument is assigned to the <kbd>state</kbd> property of this node, and the other properties are initialized as follows:</p>
<ul>
<li>The depth is set to <kbd>0</kbd></li>
<li>The reference to children is set to a blank array</li>
<li>The reference to parent nodes is set to <kbd>None</kbd></li>
</ul>
<p>This constructor creates a blank node for the search tree.</p>
<p>Aside from the constructor, we need to create the following two methods:</p>
<ul>
<li><kbd>addChild()</kbd>:  This method adds a child node under a parent node</li>
<li><kbd>printTree()</kbd>: This method prints a tree structure</li>
</ul>
<p>Consider the following code for the <kbd>addChild()</kbd> function:</p>
<pre>def addChild(self, childNode):<br/>        """<br/>        This method adds a node under another node<br/>        """<br/>        self.children.append(childNode)<br/>        childNode.parent = self<br/>        childNode.depth = self.depth + 1</pre>
<p>The <kbd>addChild()</kbd> method takes the child node as an argument; the child node is added to the children array, and the parent of the child node is assigned as its parent node. The depth of the child node is the parent node plus one.</p>
<p>Let's look at this in the form of a block diagram for a clearer understanding:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3fa34ee8-15ae-447b-a6c7-b4c80f899674.png" style="width:44.58em;height:22.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 23</span></div>
<p>Let's suppose that we're adding node <strong>f31</strong> under node <strong>d3</strong>. So, <strong>f31</strong> will be added to the <kbd>children</kbd> property of <strong>d3</strong>, and the parent property of <strong>f31</strong> will be assigned as <strong>d3</strong>. In addition to that, the depth of the child node will be one more than the parent node. Here, the depth of node <strong>d3</strong> is <strong>1</strong>, so the depth of <strong>f31</strong> is <strong>2</strong>.</p>
<p>Let's look at the <kbd>printTree</kbd> function, as follows: </p>
<pre>def printTree(self):<br/>        """<br/>        This method prints the tree<br/>        """<br/>        print self.depth , " - " , self.state.path<br/>        for child in self.children:<br/>            child.printTree()</pre>
<p>First, this function prints the depth and the state of the current node; then, it looks through all of its children and calls the <kbd>printTree</kbd> method for each of them.</p>
<p>Let's try to create the search tree shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a3f71cb8-67c0-40fc-b0c4-da5cf715a657.png" style="width:32.67em;height:9.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 24</span></div>
<p>As shown in the preceding diagram, as a root node we have the <strong>Current directory</strong> node; under that node, we have nodes <strong>d1</strong>, <strong>d2</strong>, and <strong>d3</strong>.</p>
<p>We will create a <kbd>NodeTest</kbd> module, which will create the sample search tree:</p>
<pre>...<br/>from Node import Node<br/>from State import State<br/><br/>initialState = State()<br/>root = Node(initialState)<br/><br/>childStates = initialState.successorFunction()<br/>for childState in childStates:<br/>    childNode = Node(State(childState))<br/>    root.addChild(childNode)<br/>    <br/>root.printTree()<br/>...</pre>
<p>As shown in the preceding code, we created an initial state by creating a <kbd>State</kbd> object with no arguments, and then we passed this initial state to the <kbd>Node</kbd> class constructor, which creates a root node. To get the folders <kbd>d1</kbd>, <kbd>d2</kbd>, and <kbd>d3</kbd>, we called the <kbd>successorFunction</kbd> method on the initial state and we looped each of the child states (to create a node from each of them); we added each child node under the root node.</p>
<p>When we execute the preceding code, we get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dda8ba44-3175-4f65-b077-43ce41ce39cd.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 25</span></div>
<p>Here, we can see that the current directory has a depth of <kbd>0</kbd>, and all of its contents have a depth <kbd>1</kbd>, including <kbd>d1</kbd>, <kbd>d2</kbd>, and <kbd>d3</kbd>.</p>
<p>With that, we have successfully built a sample search tree using the <kbd>Node</kbd> class.</p>
<p>In the next topic, you'll be learning about the stack data structure, which will help us to create the DFS algorithm.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stack data structure</h1>
                </header>
            
            <article>
                
<p>A <strong>stack</strong> is a pile of objects placed one atop another (for example, a stack of books, a stack of clothes, or a stack of papers). There are two stacking operations: one for adding items to a stack, and one for removing items from a stack.</p>
<p>The operation used for adding items to a stack is called <strong>push</strong>, while the operation used for removing items is called as <strong>pop</strong>. Items are popped in the reverse order to push; that is why this data structure is called <strong>last-in first-out</strong> (<strong>LIFO</strong>).</p>
<p>Let's experiment with the stack data structure in Python. We'll be using the list data structure as a stack in Python. We'll use the <kbd>append()</kbd> method to push items to the stack and the <kbd>pop()</kbd> method to pop them out:</p>
<pre>...<br/>stack = []<br/><br/>print "stack", stack<br/><br/>#add items to the stack<br/>stack.append(1)<br/>stack.append(2)<br/>stack.append(3)<br/>stack.append(4)<br/><br/>print "stack", stack<br/><br/>#pop all the items out<br/>while len(stack) &gt; 0:<br/>    item = stack.pop()<br/>    print item<br/>    <br/>print "stack", stack<br/>...</pre>
<p>As shown in the preceding code, we have created an empty stack and we are printing it out. One by one, we are adding the numbers <kbd>1</kbd>, <kbd>2</kbd>, <kbd>3</kbd>, and <kbd>4</kbd> to the stack and printing them out. Then, one by one, we are popping the items and printing them out; finally, we are printing the remaining stack.</p>
<p>If we execute the preceding code, <kbd>Stack.py</kbd>, we get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-314 image-border" src="assets/6bb18db6-a7fe-4142-a56f-fb41715ed011.png" style="width:19.17em;height:15.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 26</span></div>
<p>Initially, we have an empty stack, and when items <kbd>1</kbd>, <kbd>2</kbd>, <kbd>3</kbd>, and <kbd>4</kbd> are pushed to the stack, we have <kbd>4</kbd> at the top of the stack. Now, when you pop the items out, the first one to come out is <kbd>4</kbd>, then <kbd>3</kbd>, then <kbd>2</kbd>, and then <kbd>1</kbd>; this is the reverse of the order of entry. Then, finally, we have an empty stack.</p>
<p>Now that we are clear on how stacks work, let's use these concepts to actually create a DFS algorithm.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The DFS algorithm</h1>
                </header>
            
            <article>
                
<p>Now that you understand the basic concepts of searching, we'll look at how DFS works by using the three basic ingredients of search algorithms—the initial state, the successor function, and the goal function. We will use the stack data structure.</p>
<p>Let's first represent the DFS algorithm in the form of a flowchart, to offer a better understanding:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c0aac8c3-b1e3-4226-aece-bc2a3276b23d.png" style="width:19.17em;height:20.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 27</span></div>
<p>The steps in the preceding flowchart are as follows:</p>
<ol>
<li>We create a root node using the initial state, and we add this to our stack and tree</li>
<li>We pop a node from the stack</li>
<li>We check whether it has the goal state; if it has the goal state, we stop our search here</li>
<li>If the answer to the condition in step 3 is <strong>No</strong>, then we find the child nodes of the pop node, and add them to the tree and stack</li>
<li>We repeat steps 2 to 4 until we either find the goal state or exhaust all of the nodes in the search tree</li>
</ol>
<p>Let's apply the preceding algorithm to our filesystem, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-325 image-border" src="assets/5e9203c1-f883-4946-b17f-aed016d7cd96.png" style="width:62.67em;height:26.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 28</span></div>
<ol>
<li>We create our root node, add it to the search tree, and add it to the stack. We pop a node from the stack, which is the <strong>current directory</strong> node.</li>
<li>The <strong>current directory</strong> node doesn't have the goal state, so we find its child nodes and add them to the tree and stack.</li>
</ol>
<div class="packt_infobox">When we add nodes to the stack, they have to be added in reverse order, so that the node on the top of the stack is on the leftmost side of the search tree.</div>
<ol start="3">
<li>We pop a node from the stack (<strong>d1</strong>); it doesn't have the goal state, so we find its child nodes and add it to the tree and stack.</li>
<li>We pop a node from the stack (<strong>d11</strong>); it doesn't have the goal state, so we find its child node, add it to the tree and stack.</li>
<li>We pop a node (<strong>f111</strong>); it doesn't have the goal state, and it also doesn't have child nodes, so we carry on.</li>
<li>We pop the next node, <strong>d12</strong>; we find its child nodes and add them to the tree and stack.</li>
<li>We pop the next node, <strong>f121</strong>, and it doesn't have any child nodes, so we carry on.</li>
<li>We pop the next node, <strong>f122</strong>, and it doesn't have any child nodes, so we carry on.</li>
<li>We pop the next node, <strong>f11</strong>, and we encounter the same case (where we have no child nodes), so we carry on; the same goes for <strong>f12</strong>.</li>
<li>We pop the next node, <strong>d2</strong>, and we find its child nodes and add them to the tree and stack.</li>
<li>We pop the next node, <strong>d21</strong>, and we find its child node and add it to the tree and stack.</li>
<li>We pop the next node, <strong>f211</strong>, and we find that it has the goal state, so we end our search here.</li>
</ol>
<p>Let's try to implement these steps in code, as follows:</p>
<pre>...<br/>from Node import Node<br/>from State import State<br/><br/><br/>def performStackDFS():<br/>    """<br/>    This function performs DFS search using a stack<br/>    """<br/>    #create stack<br/>    stack = []<br/>    <br/>    #create root node and add to stack <br/>    initialState = State()<br/>    root = Node(initialState)<br/>    stack.append(root)<br/>...</pre>
<p>We have created a Python module called <kbd>StackDFS.py</kbd>, and it has a method called <kbd>performStackDFS()</kbd>. In this method, we have created an empty stack, which will hold all of our nodes, the <kbd>initialState</kbd>, a root node containing the <kbd>initialState</kbd>, and finally we have added this root node to the stack.</p>
<p>Remember that in <kbd>Stack.py</kbd>, we wrote a <kbd>while</kbd> loop to process all of the items in the stack. So, in the same way, in this case we will write a <kbd>while</kbd> loop to process all of the nodes in the stack:</p>
<pre>...<br/>while len(stack) &gt; 0:<br/>        <br/>        #pop top node<br/>        currentNode = stack.pop()<br/>        <br/>        print "-- pop --", currentNode.state.path<br/>        <br/>        #check if this is goal state<br/>        if currentNode.state.checkGoalState():<br/>            print "reached goal state"<br/>            break<br/>            <br/>        #get the child nodes <br/>        childStates = currentNode.state.successorFunction()<br/>        for childState in childStates:<br/>            childNode = Node(State(childState))<br/>            currentNode.addChild(childNode)<br/><br/>...</pre>
<p>As shown in the preceding code, we pop the node from the top of the stack and call it <kbd>currentNode()</kbd>, and then we print it so that we can see the order in which the nodes are processed. We check whether the current node has the goal state, and if it does, we end our execution here. If it doesn't have the goal state, we find its child nodes and add it under <kbd>currentNode</kbd>, just like we did in <kbd>NodeTest.py</kbd>.</p>
<p>We will also add these child nodes to the stack, but in reverse order, using the following <kbd>for</kbd> loop:</p>
<pre>...<br/>for index in range(len(currentNode.children) - 1, -1, -1):<br/>            stack.append(currentNode.children[index])<br/><br/>#print tree<br/>    print "----------------------"<br/>    root.printTree()<br/>...</pre>
<p>Finally, when we exit the <kbd>while</kbd> loop, we print the tree. Upon successful execution of the code, we will get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/aa4c4d6e-6443-4809-9330-f3643fa353f3.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 29</span></div>
<p>The output displays the order in which the nodes are processed, and we can see the first node of the tree. Finally, we encounter our goal state, and our search stops:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f1bf82a9-481d-46e1-95bd-d597c1f2ef6d.png" style="width:45.42em;height:38.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 30</span></div>
<p>The preceding screenshot displays the search tree. Note that the preceding output and the one before it are almost the same. The only difference is that in the preceding screenshot, we can find two nodes, <kbd>d22</kbd> and <kbd>d3</kbd>, because their parent nodes were explored.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recursive DFS</h1>
                </header>
            
            <article>
                
<p>When a function calls itself, we say that the function is a <strong>recursive</strong> function. Let's look at the example of the Fibonacci series. It is defined as follows: <kbd>f(1)</kbd> is equal to <kbd>1</kbd>, <kbd>f(2)</kbd> is equal to <kbd>1</kbd>, and for <kbd>n</kbd> greater than <kbd>2</kbd>, <kbd>f(n)</kbd> is equal to <kbd>f(n-1) + f(n-2)</kbd>. Let's look at the implementation of this function in code, as follows:</p>
<pre>...<br/>def fibonacci(n):<br/>    if n &lt;= 2:<br/>        return 1<br/>    else:<br/>        return fibonacci(n-1) + fibonacci(n-2)<br/><br/>print "fibonacci(5)", fibonacci(5)<br/>...</pre>
<p>In the preceding code, we have created our function, <kbd>fibonacci</kbd>, which takes a number, <kbd>n</kbd>, as input. If <kbd>n</kbd> is less than or equal to <kbd>2</kbd>, it returns <kbd>1</kbd>; otherwise, it returns <kbd>fibonacci(n-1) + fibonacci(n-2)</kbd>. Toward the end of the code, we have calculated the value of <kbd>fibonacci(5)</kbd>, which is <kbd>5</kbd>.</p>
<p>The output of running the preceding code is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8028501a-a5ef-4830-9278-60900c68c837.png" style="width:75.25em;height:34.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 31</span></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>If we want to visualize the recursion tree of the <kbd>fibonacci</kbd> function, we can go to <a href="https://visualgo.net/en/recursion">https://visualgo.net/en/recursion</a>. This website has visualizations of various data structures and algorithms.</p>
<p class="mce-root">The visualization of a recursion tree is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-315 image-border" src="assets/7042a331-bc4a-43a9-9946-7e0d617e9f73.png" style="width:45.08em;height:31.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 32</span></div>
<p>As shown in the preceding screenshot, the output that we get here is the same as the output we got with the code, and the order in which the nodes were explored is similar to DFS.</p>
<p>So, <em>what happens when function 1 calls function 2?</em> The program adds a stack frame to the program stack. A stack frame contains the local variables in function 1, the arguments passed to function 1, and the return addresses of function 2 and function 1.</p>
<p>Let's look at the example of the Fibonacci sequence again:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-321 image-border" src="assets/c469c95e-871a-4864-891c-063b617ba61c.png" style="width:35.33em;height:15.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 33</span></div>
<p>As you can see, the Fibonacci code has been modified for the sake of clarity. Suppose that the program is executing the line in bold, <strong>val2 = fibonacci(n-2)</strong>. Then, the stack frame created will contain the following values—local variables is equal to <strong>val1</strong>, arguments passed is equal to <strong>n</strong>, and return address is the address of the code in bold.</p>
<p>This means that the return address points to the unprocessed curve. Because in recursion the program stack keeps a stack of unprocessed calls, instead of storing nodes in the stack, we will call DFS recursively on the child nodes, so that the stack is indirectly maintained.</p>
<p>Let's look at the steps of recursive DFS in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3c4cd97a-bc72-4994-9b8b-24b26481219a.png" style="width:16.92em;height:18.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 34</span></div>
<p>The steps in the preceding diagram are explained as follows:</p>
<ol>
<li>We create an initial state.</li>
<li>We create a root node with this initial state.</li>
<li>We add the root node to the search tree and call DFS on the root node.</li>
<li>Recursive DFS is defined as follows: check whether the node has a goal state. If yes, then it returns the path; if no, then DFS finds the children node, and for each child node DFS adds the node to the tree, finally calling itself on the child node.</li>
</ol>
<p><span>Now, we will apply the preceding algorithm to our filesystem, the steps for which are as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-324 image-border" src="assets/1ea9aa73-f110-4a16-991e-f669760d0f94.png" style="width:37.33em;height:19.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 35</span></div>
<ol>
<li>We create the root node and add it to the search tree, and we call DFS on this root node.</li>
<li>When we call DFS on this root node, the function checks whether this node has the goal state, and it doesn't, so it finds its children nodes (<strong>d1</strong>, <strong>d2</strong>, and <strong>d3</strong>). It takes the first node, <strong>d1</strong>, adds it to the search tree, and calls DFS on the node.</li>
<li>When it calls DFS on <strong>d1</strong>, the function creates a program. When DFS is called on <strong>d1</strong>, then the program creates a stack frame and adds it to the program stack. In this case, we'll show the remaining nodes to be processed in the <kbd>for</kbd> loop. Here, we're adding <strong>d2</strong> and <strong>d3</strong> in the program stack.</li>
</ol>
<p> </p>
<ol start="4">
<li>When DFS is called on <strong>d1</strong>, it finds the children nodes <strong>d11</strong>, <strong>d12</strong>, <strong>f11</strong>, and <strong>f12</strong>, and adds <strong>d11</strong> to the search tree.</li>
<li>It calls DFS on <strong>d11</strong>, and when it does so, it creates an entry in the program stack with the unprocessed nodes. Now, when DFS is called on <strong>d11</strong>, it finds the child node <strong>f111</strong>, adds <strong>f111</strong> to the search tree, and calls DFS on the node.</li>
</ol>
<ol start="6">
<li>When DFS is called on <strong>f111,</strong> it has no children nodes, so it returns back; when this happens, the program stack is unwounded, which means that the program returns execution and processes the last unprocessed nodes in the stack. In this case, it starts processing node <strong>d12</strong>. So, the program adds node <strong>d12</strong> to the search tree, and calls DFS on <strong>d1</strong>.</li>
<li>When DFS is called on <strong>d12</strong>, it finds the children nodes <strong>f121</strong> and <strong>f122</strong>. It adds node <strong>f121</strong> to the search tree, and calls DFS on it. When DFS is called on <strong>f121</strong>, it adds the unprocessed node <strong>f122</strong> to the stack.</li>
<li>When DFS is called on <strong>f121,</strong> it has no children nodes, so again the stack is unwounded. So, we process node <strong>f122</strong>. This node is added to the search tree and DFS is called on it. So, we continue processing the last node, <strong>f11</strong>, add it to the search tree, and call DFS on it.</li>
<li>When we call DFS on <strong>f11,</strong> it has no children nodes, so again the stack is unwounded. We continue processing node <strong>f12</strong>, it is added to the search tree, and DFS is called on <strong>f12</strong>. We encounter this case, and we continue processing node <strong>d2</strong>. We add it to the search tree, and we call DFS on <strong>d2</strong>.</li>
<li>When we call DFS on <strong>d2,</strong> we find that is has children nodes: <strong>d21</strong> and <strong>d22</strong>. We add <strong>d21</strong> to the search tree, and we call DFS on <strong>d21</strong>; when we call DFS on <strong>d21,</strong> it creates an entry for <strong>d22</strong>. In the program stack, when DFS is called on <strong>d21,</strong> we find that it has a child, <strong>f211</strong>. This node is added to the search tree and DFS is called on <strong>f211</strong>.</li>
<li>When DFS is called an <strong>f211</strong>, we realize that it has the goal state, and we end our search process here.</li>
</ol>
<p>Let's look at how we can implement recursive DFS, as follows:</p>
<pre>...<br/>from State import State<br/>from Node import Node<br/><br/><br/>class RecursiveDFS():<br/>    """<br/>    This performs DFS search<br/>    """<br/>    def __init__(self):<br/>        self.found = False<br/>...</pre>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>As shown in the preceding code, we have created a Python module called <kbd>RecursiveDFS.py</kbd>. It has a class called <kbd>RecursiveDFS</kbd>, and, in the constructor, it has a property called <kbd>found</kbd>, which indicates whether the solution has been found. We'll look at the significance of the <kbd>found</kbd> variable later. </p>
<p class="mce-root">Let's look at the following lines of code:</p>
<pre>...<br/>    def search(self):<br/>        """<br/>        This method performs the search<br/>        """<br/>        #get the initial state<br/>        initialState = State()<br/>        <br/>        #create root node<br/>        rootNode = Node(initialState)<br/>        <br/>        #perform search from root node<br/>        self.DFS(rootNode)<br/>        <br/>        rootNode.printTree()<br/>...</pre>
<p>Here, we have a method called <kbd>search</kbd>, in which we are creating the <kbd>initialState</kbd>, and the <kbd>rootNode</kbd> we're calling the DFS function on the <kbd>rootNode</kbd>. Finally, we print the tree after we perform the DFS search, as follows:</p>
<pre>...<br/>def DFS(self, node):<br/>        """<br/>        This creates the search tree<br/>        """<br/>        if not self.found:<br/>            print "-- proc --", node.state.path<br/>            <br/>            #check if we have reached goal state<br/>            if node.state.checkGoalState():<br/>                print "reached goal state"<br/>                #self.found = True<br/>                <br/>            else:<br/>                #find the successor states from current state <br/>                childStates = node.state.successorFunction()<br/>                <br/>                #add these states as children nodes of current node<br/>                for childState in childStates:<br/>                    childNode = Node(State(childState))<br/>                    node.addChild(childNode)<br/>                    <br/>                    self.DFS(childNode)<br/>....</pre>
<p>The <kbd>DFS</kbd> function can be defined as follows:</p>
<ul>
<li>If the solution has not been found, then the node that is being processed is printed</li>
<li>We check whether the node has the goal state, and if it does, we print that the goal state has been reached</li>
<li>If it doesn't have the goal state, we find the child states; next, we create the child node for each child state, we add them to the tree, and we call <kbd>DFS</kbd> on each of the child nodes</li>
</ul>
<p>Let's execute the program; we will get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/17689949-b959-4be7-b181-6193c705ce0b.png" style="width:44.58em;height:34.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 36</span></div>
<p>When we processed <kbd>f211</kbd>, we reached the goal state, but here we have three extra lines; this is because these nodes have been added to the program stack. To remove these lines, we have created a variable called <kbd>found</kbd>, so that when the goal state is found, the variable will be set to <kbd>True</kbd>. Once we encounter <kbd>f211</kbd>, the remaining nodes in the program stack will not be processed:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3ed5768f-f868-4d3b-9929-514e6a724a7f.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 37</span></div>
<p>Let's run this code again and see what happens:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b3096f63-5186-404a-bb0a-790a9bb10ec0.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 38</span></div>
<p>As you can see, once we've processed <kbd>f211</kbd> and reached the goal state, the node processing stops. The output of the <kbd>printTree</kbd> function is the same as what we store in <kbd>StackDFS.py</kbd>.</p>
<p>Now that you understand how DFS can be made into a recursive function, in the next topic we will look at an application that you can develop by yourself.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Do it yourself</h1>
                </header>
            
            <article>
                
<p>In this section, we will look at an application that you can develop by yourself. We will take a look at a new application and discuss the changes that are required. In the <em>Introduction to file search applications</em> section, we discussed two applications of file searching; now, we will develop the second type of example. Our aim is to develop a search application that is able to find program files containing specific program text.</p>
<p>In the code for recursive DFS, we mainly used three classes, as follows:</p>
<ul>
<li><strong>State</strong>: This has the three main ingredients of the search process</li>
<li><strong>Node</strong>: This is used to build search trees</li>
<li><strong>Recursive</strong> <strong>DFS</strong>: This has the actual algorithm implementation</li>
</ul>
<p>Suppose that we want to adapt this code or file search application to new application. We will need to change three methods: <kbd>getInitialState</kbd>, <kbd>successorFunction</kbd>, and <kbd>checkGoalState</kbd>. For the new application of program searching, you will need to change just one method: <kbd>checkGoalState</kbd>.</p>
<p>In your new <kbd>checkGoalState</kbd> function, you will need to open the file, read the contents of the file line by line, and perform a substring check or regular expression check. Lastly, based on the results of the check, you will return true or false. </p>
<p>So, go ahead and try it out for yourself!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at four basic concepts related to searching: the state, which is the condition of our search process; the node, which is used for building a search tree; the stack, which helps to traverse the search tree and decides the order in which the nodes are traversed; and recursion, which eliminates the need for an explicit stack. You also learned about DFS, which explores the search tree in a depth-first order.</p>
<p>In the next chapter, you'll learn about <strong>breadth-first search</strong> (<strong>BFS</strong>), which explores a search tree in a breadth-first order. See you there!</p>
<div class="packt_infobox"><span>Please refer to the link <a href="https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf">https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf</a> </span><span>for the colored images of this chapter.</span></div>


            </article>

            
        </section>
    </body></html>