<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Mass Customization of Client Lifetime Wealth
                </header>
            
            <article>
                
<p><span>I</span><span>n the previous chapter, we learned how to manage the digital data of customers. We also covered the Open Bank Project and the Open Bank API. In addition, we learned about document layout analysis and looked at an example of projecting the cash flow for a typical household. Then, we looked at another example of how to track daily expenses using invoice entity recognition.</span></p>
<p>In this chapter, we will learn how to combine data from a survey for personal data analysis. We will learn techniques such as Neo4j, which is a graph database. We will build a chatbot to serve customers 24/7. We will also learn how to predict customer responses using NLP and Neo4j with the help of an example. After this, we will learn how to use cypher languages to manipulate data from the Neo4j database.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Financial concepts of wealth instruments</li>
<li>Ensemble learning</li>
<li>Predicting customer responses</li>
<li>Building a chatbot to serve customers 24/7</li>
<li>Knowledge management using NLP and graphs</li>
</ul>
<h1 id="uuid-41af4ae7-2d7e-49c8-8a32-7d902a01a656">Financial concepts of wealth instruments</h1>
<p>In this section, we will be answering a few questions asked by a consumer bank's marketers. Then, we will look at another important model development technique—ensemble learning—which will be useful in combining predictions from different models.</p>
<h2 id="uuid-6f9311b7-2ebe-4315-a1de-ddd4f237343a">Sources of wealth: asset, income, and gifted</h2>
<p>One of the most common tasks in retail banking customer analytics is to retrieve additional data that helps us to explain the customers' investment behavior and patterns. No doubt we will know the response of the customers, but the work of a model is to find out why they respond as they do. Surprisingly, there is a lot of aggregated information concerning the behaviors of individuals, such as census data. We can also find data from social media, where users use social media for authentication. The relevant social media information can then be chained together with individual-level transactional data that we observed internally in the organization. To explain individual banking behaviors, the most relevant supplementary data that we want is the information regarding their wealth.</p>
<h3 id="uuid-ef271a04-55b7-4b05-a8d8-646c21912e1a">Customer life cycle</h3>
<p><span>A typical life cycle involves three major phases—acquisition, cross-selling/upselling, and retention. The following diagram illustrates these three phases:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1042 image-border" src="assets/f5254c6a-e008-4981-86d9-da80671bf861.png" style="width:41.25em;height:4.33em;"/></p>
<p><strong>Acquisition</strong> is when we start a commercial relationship with customers. Then, we move on to <strong>cross-selling</strong> and <strong>upselling</strong>. Cross-selling is about improving the number of products/services that are sold to the customer. Up-selling is about deepening the wallet share of the same product with the products/services. <strong>Retention</strong> is about keeping the relationship and is a defensive act by the bank to protect the relationship. Our first example (described in the following section) concerns cross-selling (if the customers do not have the product) and up-selling (if the customers own the product).</p>
<h1 id="uuid-1fb4de99-3c0e-45cd-8075-0364a46fe362">Ensemble learning</h1>
<p>Ensemble learning is the boosting technique that helps us in improving the accuracy of the prediction. We will also learn how to use the graph database for knowledge storage. Knowledge storage is the current challenge in knowledge representation that can be used to empower AI for professional-grade financial services.</p>
<p>Ensemble learning is an approach that is used to summarize several models in order to give a more stable prediction. It was a very common approach before deep neural networks became popular. For completeness, we do not want to ignore this modeling technique in this very short book. In particular, we have used random forest, which means that we build lots of decision trees as a forest and we apply logic to cut down trees that have lower performance. Another approach would be combining the weaker model to generate a strong result, which is called the <strong>boosting method</strong>. We won't cover it here, but readers are encouraged to dig deeper in the <span>s</span>cikit-learn<span> </span>documentation (<a href="https://scikit-learn.org/stable/">https://scikit-learn.org/stable/</a>).</p>
<h2 id="uuid-1bf1a120-4848-4231-8ee4-36e924562c09">Knowledge retrieval via graph databases</h2>
<p>To make a machine talk like a human in customer services, one of the key elements is the conversational component. When we engage in conversation, it is normal that human customers may not be able to provide the full amount of information required for processing. Humans can work with fuzziness. Humans can understand the context, and so can extrapolate meaning without the concepts being explicitly mentioned. Knowing that a machine can only solve definite problems while humans can work on fuzziness, it is the job of the machine to infer meaning from the knowledge map that it has for the customers. A graph database is used to serve this purpose.</p>
<h1 id="uuid-ff037dcf-3de8-4f69-bfb2-c8dc88bcbb32">Predict customer responses</h1>
<p>So far, we have not talked about the day-to-day marketing activity of the bank. Now, we have finally come to look at how marketing prospects are determined. Even though each customer is unique, they are still handled by algorithms in the same way.</p>
<p>In this example, you will assume the role of a data scientist tasked with the marketing of a term deposit product. We are going to train the model to predict the marketing campaign for the term deposit. Data pertaining to the bank's internal data regarding customers and their previous responses to the campaign is obtained from<span> the </span>Center for Machine Learning and Intelligent Systems<span> (<a href="https://archive.ics.uci.edu/ml/datasets/bank+marketing">https://archive.ics.uci.edu/ml/datasets/bank+marketing</a>)</span>, the Bren School of Information and Computer Science, and the University of California, Irvine. Survey information about personal wealth is obtained<span> from the </span>US Census Bureau (<a href="https://www.census.gov/data/tables/time-series/demo/income-poverty/historical-income-households.html">https://www.census.gov/data/tables/time-series/demo/income-poverty/historical-income-households.html</a>), which serves as an augmentation to the bank's internal data.</p>
<p class="mce-root"/>
<h2 id="uuid-f7b70973-6c28-4278-b873-cf1dbfd1b827">Solution</h2>
<p>There are four steps to complete this example:</p>
<ol>
<li>We introduce random forest, which is a type of machine learning algorithm that utilizes ensemble learning, allowing predictions to be made by multiple models. The resulting model is a combination of the results from the multiple models. The following is the code snippet to import the required libraries and define the variables:</li>
</ol>
<pre style="padding-left: 60px">#import libraries &amp; define variables<br/>import pandas as pd<br/>import os<br/>from sklearn.ensemble import RandomForestClassifier<br/>from sklearn.datasets import make_classification</pre>
<ol start="2">
<li>Census data provides information about the deposit and wealth of the age group placed in the bank. The following is the code snippet to handle census data:</li>
</ol>
<pre style="padding-left: 60px">cat_val = ''<br/>cat_dict = {}<br/>for index, row in df_xtics.iterrows():<br/>    ...<br/><br/>df_bank['age_c'] = pd.cut(df_bank['age'], [0,35,45,55,65,70,75,200])<br/><br/>#ID Conversions<br/>df_bank['age_c_codes']=df_bank['age_c'].cat.codes.astype(str)<br/>age_map={'0':'Less than 35 years'<br/>,'1':'35 to 44 years'<br/>,'2':'45 to 54 years'<br/>,'3':'55 to 64 years'<br/>,'4':'.65 to 69 years'<br/>,'5':'.70 to 74 years'<br/>,'6':'.75 and over'}</pre>
<ol start="3">
<li>We want to illustrate the mapping of one column's data, using age to introduce wealth data. The following is the code snippet to combine census data with the bank's data:</li>
</ol>
<pre style="padding-left: 60px">#3. map back the survey data<br/>df_bank['age_c1']=df_bank['age_c_codes'].map(age_map)<br/>df_bank['age_c1_val']=df_bank['age_c1'].map(cat_dict['Age of Householder'])<br/><br/>X_flds = ['balance','day', 'duration', 'pdays',<br/>       'previous', 'age_c1_val']<br/>X = df_bank[X_flds]<br/>y = df_bank['y']</pre>
<ol start="4">
<li>The following is the code snippet to train the model:</li>
</ol>
<pre style="padding-left: 60px">X, y = make_classification(n_samples=1000, n_features=3,<br/>                           n_informative=2, n_redundant=0,<br/>                           random_state=0, shuffle=False)<br/>clf = RandomForestClassifier(n_estimators=100, max_depth=2,<br/>                             random_state=0)<br/>clf.fit(X, y)<br/>print(clf.feature_importances_)</pre>
<p>Congratulations! You have merged an external dataset with the internal dataset to augment our understanding of the customers.</p>
<h1 id="uuid-84899b78-5940-4989-abb2-9516d099b584">Building a chatbot to service customers 24/7</h1>
<p>When we interact with a robot, we expect it to understand and speak to us. The beauty of having a robot work for us is that it could serve us 24 hours a day throughout the week. Realistically, chatbots nowadays interact poorly with customers, and so we should try to break down the components of these chatbots to raise the bar to a higher standard. For an application-type development, you could use Google Assistant, Amazon's Alexa, or IBM Watson. But for learning purposes, let's break down the components and focus on the key challenges: </p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1043 image-border" src="assets/f9437b12-bdce-4813-9521-471012ec8b4c.png" style="width:188.83em;height:83.17em;"/></p>
<p>The chatbot performs two operations at a high level. One is to convert an input from voice to text, and another one is to translate an output from text to voice. Both of these operations involve extracting the entity and understanding the intent. In this example, the resulting text is an entity, whereas the meaning of the text is an intent. It represents a conversation between the service requester and the service provider. When faced with an incoming service request, the chatbot converts the voice instructions into text and adds context to the information received. Once the context building is done, the chatbot processes the information to generate the output in text format. The chatbot has to convert it into an audible voice output to be presented to the service requester. The whole scenario is explained in the preceding diagram.</p>
<p>Right now, let's focus on chat only, without worrying about voice recognition and utterance—that is, let's ignore voice to text and text to voice. In my opinion, since this task is machine- and memory-intensive, and the data is available in so many places, it is not for a start-up to work on this task; instead, we should leave it to a mainstream cloud provider with a strong infrastructure to deliver the service.</p>
<p class="mce-root">For text-only chat, the key focus should be on intent classification and entity extraction. While we have touched on entity extraction in the previous chapter, the input still needs to be classified before it is extracted. Intent classification works similarly to entity extraction, but treats the whole sentence as an entity for classification.</p>
<p class="mce-root">While it is very common to run a chatbot using ChatterBot or RasaNLU, we can break down the components to run from the bottom up.</p>
<p>Let's say that we are a simple bank that offers deposits and loans. We are building a simple chatbot that can serve existing customers only, and at the moment, we <span>only</span><span> </span><span>have two customers, one called</span> <strong>abc</strong> <span>with a deposit account, and another called</span> <strong>bcd</strong> <span>with a loan account:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1044 image-border" src="assets/fa9f65e9-f9a6-407c-ade7-46a8dbb18e8f.png" style="width:17.42em;height:15.42em;"/></p>
<p><span>Abc's deposit has an outstanding balance of 100 units and a pricing of 1, and bcd has an </span><span>outstanding</span><span> </span><span>loan of 100 units and a pricing of 2.</span></p>
<h1 id="uuid-d93aee85-762d-45e4-8697-934e1af931d8">Knowledge management using NLP and graphs</h1>
<p>Essentially, there are two ways for us to retrieve and update knowledge about our real world. One is to store the knowledge in vector space and read the file to our memory during runtime using programs such as Word2Vector and BERT. Another approach is to load the knowledge into a graph database, such as Neo4j, and retrieve and query the data. The strength and weakness of both approaches lies in speed and transparency. For high-speed subject classification, in-memory models fare better, but for tasks that require transparency, such as banking decisions, the updating of data requires full transparency and permanent record keeping. In these cases, we will use a graph database. However, like the example we briefly covered in <a href="d29ff3a8-3879-4d50-8795-a39bae5cc793.xhtml">Chapter 7</a>, <em>Sensing Market Sentiment for Algorithmic Marketing at Sell Side</em>, NLP is required to extract information from the document before we can store the information in graph format.</p>
<h2 id="uuid-b35f6db0-d17a-4385-be0d-21fbeffbca45">Practical implementation</h2>
<p>The following are the steps to complete this example:</p>
<ol>
<li>Use the Cypher languages to import <kbd>csv</kbd> files into the database. We assume that the CSV file is dumped from the traditional SQL database. The following are the commands to be executed from the command line:</li>
</ol>
<pre style="padding-left: 60px"><strong>sudo cp dataset.csv /var/lib/Neo4j/import/edge.csv</strong><br/><strong>sudo cp product.csv /var/lib/Neo4j/import/product.csv</strong><br/><strong>sudo cp customer.csv /var/lib/Neo4j/import/customer.csv</strong></pre>
<ol start="2">
<li class="mce-root">Open the browser and navigate to <kbd>http://localhost:7474/browser/</kbd>. Then, create a <kbd>username</kbd> and set a <kbd>password</kbd>. This will be executed only once:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">username: test, password: test</pre>
<ol start="3">
<li class="mce-root">Delete all nodes:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">MATCH (n) DETACH DELETE n;</pre>
<ol start="4">
<li class="mce-root">Create customer data:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">LOAD CSV WITH HEADERS FROM "file:///customer.csv" AS row<br/>CREATE (c:Customer {customer_id: row.customer});</pre>
<ol start="5">
<li class="mce-root">Create product data:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">LOAD CSV WITH HEADERS FROM "file:///product.csv" AS row<br/>CREATE (p:Product {product_name: row.product});</pre>
<ol start="6">
<li class="mce-root">Load the CSV file:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">LOAD CSV WITH HEADERS FROM "file:///edge.csv" AS line<br/>WITH line<br/>MATCH (c:Customer {customer_id:line.customer})<br/>MATCH (p:Product {product_name:line.product})<br/>MERGE (c)-[:HAS {TYPE:line.type, VALUE:toInteger(line.value)}]-&gt;(p)<br/>RETURN count(*);</pre>
<ol start="7">
<li class="mce-root">Match and return the data:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">MATCH (c)-[cp]-&gt;(p) RETURN c,cp,p;</pre>
<p style="padding-left: 60px">Cypher is a language in itself; what we do is essentially create the product and customers. Then, we load another file that connects customers to products.</p>
<ol start="8">
<li>We will connect to the <kbd>Neo4j</kbd> database that we just populated with data. The parameters follow the default setting. Please note the unique syntax of Cypher. In addition, the NLP model is loaded to be used for similarity analysis of the inputted instruction. The Cypher queries are stored in a dictionary. After the intent is read, the query string is retrieved. Then, we build the knowledge using the graph database:</li>
</ol>
<pre style="padding-left: 60px">#import libraries and define parameters<br/>from Neo4j import GraphDatabase<br/>import spacy<br/><br/>#define the parameters, host, query and keywords<br/>uri = "bolt://localhost:7687"<br/>driver = GraphDatabase.driver(uri, auth=("test", "test"))<br/>session = driver.session()<br/><br/>check_q = ("MATCH (c:Customer)-[r:HAS]-&gt;(p:Product)" <br/> "WHERE c.customer_id = $customerid AND p.product_name = \<br/>  $productname" <br/> "RETURN DISTINCT properties(r)")<br/>...<br/>intent_dict = {'check':check_q, 'login':check_c}<br/><br/>#list of key intent, product and attribute<br/>product_list = ['deposit','loan']<br/>attribute_list = ['pricing','balance']<br/>intent_list = ['check']<br/>print('loading nlp model')<br/>nlp = spacy.load('en_core_web_md')</pre>
<ol start="9">
<li>Users should be authenticated and identified properly using the SQL database. For ease of illustration, we will use <kbd>GraphDatabase</kbd>, but it is quite clear that using <kbd>GraphDatabase</kbd> for authentication is not right because we want to store a huge amount of data with usernames and passwords in a dedicated table whose access rights we can set to fewer individuals than the total number of people on the database. The following is the code snippet to authenticate the user:</li>
</ol>
<pre style="padding-left: 60px">if name == '' or reset:<br/>    name = input('Hello, What is your name? ')<br/>    print('Hi '+name)<br/>    #check for login<br/>    query_str = intent_dict['login']<br/>    result = session.read_transaction(run_query, query_str, name, \<br/>                                 product, attribute, attribute_val)</pre>
<p>Sentence intent and entity extraction utilizes spaCy on similarity analysis. Based on a pretrained word-to-vector model, the reserved words on intents and entities are compared with the inputted sentence to extract the relevant intent and entities. The model is overly simplified as readers are left with a lot of creative space to enhance the extraction works by using a better language model, such as BERT, on the assumption that we have made the relevant model to perform the relevant classification task.</p>
<p>The following is the code snippet to extract entities and add intent:</p>
<pre>#Sentences Intent and Entities Extraction<br/>input_sentence = input('What do you like to do? ')<br/>if input_sentence == "reset":<br/>    reset = True <br/>entities = intent_entity_attribute_extraction(nlp, input_sentence, \<br/>                         tokens_intent, tokens_products, tokens_attribute)<br/>#actually can build another intent classifier here based on the scores and words matched as features, as well as previous entities<br/>intent = entities[0]<br/>product = entities[1]<br/>attribute = entities[2]<br/>attribute_val = entities[3]</pre>
<h3 id="uuid-66fb5914-a576-4c85-a6cb-66d1a5c28aa4">Cross-checking and further requesting missing information</h3>
<p>The program will continuously ask for intents, products, and attributes until all three pieces of information are clear to the program. Underneath the classification of each of these parameters, we deploy Word2vec for simplified classification. In fact, we can run a best-in-class topic classification model, such as BERT, to understand the languages and topics.</p>
<p>The following is the code snippet to request missing information from the user:</p>
<pre>while intent == '':<br/>    input_sentence = input('What do you want to do?')<br/>    entities = intent_entity_attribute_extraction(nlp, input_sentence, \<br/>                     tokens_intent, tokens_products, tokens_attribute)<br/>    intent = entities[0]<br/><br/>while product == '':<br/>    input_sentence = input('What product do you want to check?')<br/>    entities = intent_entity_attribute_extraction(nlp, input_sentence, \<br/>                     tokens_intent, tokens_products, tokens_attribute)<br/>    product = entities[1]<br/><br/>while attribute == '':<br/>    input_sentence = input('What attribute of the ' + product + \<br/>                        ' that you want to '+intent+'?')<br/>    entities = intent_entity_attribute_extraction(nlp, input_sentence, \<br/>                      tokens_intent, tokens_products, tokens_attribute)<br/>    attribute = entities[2]</pre>
<h3 id="uuid-1e4cb308-4ce9-4c36-871d-50eecf8258bd">Extracting the answer</h3>
<p>When all information is filled in, the Cypher query will be executed and the information will be presented to the user. The following is the code snippet to extract the answer:</p>
<pre>#execute the query to extract the answer<br/>query_str = intent_dict[intent]<br/>results = session.read_transaction(run_query, query_str, name, \<br/>                                    product,attribute,attribute_val)<br/>if len(results) &gt;0:<br/>    for result in results:<br/>        if result['TYPE'] == attribute:<br/>            print(attribute + ' of ' + product + ' is '+ \<br/>                  str(result['VALUE']))<br/>else:<br/>    print('no record')<br/><br/></pre>
<h3 id="uuid-13c40246-3020-4f38-b90d-e59ca1a7a7e2">Sample script of interactions</h3>
<p>The following snippet shows the <span>users' </span><span>output and input</span><span>. It is meant to show that the NLU can </span><span>indeed</span><span> </span><span>extract intent and entities using closely associated words, thanks to the spaCy dictionary that allows us to find similar words. The whole point of the example is to show that for decisions requiring complete information before they are made, the graph database allows us to manage the dialogue and follow up with the missing information before any instructions are executed to serve the user.</span> <span>This is a very important feature when it comes to making professional decisions where we need </span><span>its rationale to be </span><span>transparent to a high degree of accuracy, as far as the machine can understand the language</span><span>. The following is a snippet of the sample conversation of the chatbot:</span></p>
<pre>loading nlp model<br/>Hello, What is your name? testing<br/>Hi testing<br/>Failed to find testing<br/>Hello, What is your name? abc<br/>Hi abc<br/>What do you like to do? do sth<br/>matching...<br/> <br/>What do you want to do?check sth<br/>matching...<br/>check <br/>What product do you want to check?some product<br/>matching...<br/> <br/>What product do you want to check?deposit<br/>matching...<br/> deposit <br/>What attribute of the deposit that you want to check?sth<br/>matching...<br/> <br/>What attribute of the deposit that you want to check?pricing<br/>matching...<br/> pricing<br/>pricing of deposit is 1</pre>
<p>Congratulations! You have built a very simple chatbot that can show you the core functionality of chatbots.</p>
<p>The example we are using is a very good echo of what we start with in commercial banking in terms of using borrowers' and depositors' data using reinforcement learning. Back then, the data was stored in variables at runtime. Right now, we have demonstrated another possibility for storing the data in graph data. Indeed, compared to the example in <a href="61949743-f7c3-4295-aaee-dab1d169d25c.xhtml">Chapter 3</a>, <em>Using Features and Reinforcement Learning to Automate Bank Financing,</em> the speed of reinforcement learning will be slower if we were to store data in a graph database rather than variables in a Python program. Therefore, <span>we will use a graph database, but </span><span>only for production and application levels when individual dialogues can tolerate some delay compared with a computation-intensive training phase.</span></p>
<h1 id="uuid-b4f5c5b9-5cee-4abb-8d65-085ca97d00b4" class=""><span>Summary</span></h1>
<p>In this chapter, we learned about NLP and graph databases and we learned about the financial concepts that are required to analyze customer data. We also learned about an artificial intelligence technique called ensemble learning. We looked at an example where we predicted customer responses using natural language processing. Lastly, we built a chatbot to serve requests from customers 24/7. These concepts are very powerful. NLP is capable of enabling programs to interpret languages that humans speak naturally. The graph database, on the other hand, is helpful in designing highly efficient algorithms.</p>
<p>In the next chapter, we will learn about practical c<span>onsiderations to bear in mind when you want to build a model to solve your day-to-day challenges. In addition, we also want to look at the practical IT considerations when equipping data scientists with languages to interact with IT developers who put the algorithm to use in real life.</span></p>


            </article>

            
        </section>
    </body></html>