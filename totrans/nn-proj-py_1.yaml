- en: Machine Learning and Neural Networks 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '** Artificial intelligence** (**AI**) has captured much of our attention in
    recent years. From face recognition security systems in our smartphones to booking
    an Uber ride through Alexa, AI has become ubiquitous in our everyday lives. Still,
    we are constantly being reminded that the full potential of AI has not yet been
    realized, and that AI will become an even bigger transformative factor in our
    lives.'
  prefs: []
  type: TYPE_NORMAL
- en: When we look at the horizon, we can see the relentless progression of AI with
    its promise to better our everyday lives. Powered by AI, self-driving cars are
    becoming less science fiction, and more of a reality. Self-driving cars aim to
    reduce traffic accidents by eliminating human error, ultimately improving our
    lives. Similarly, the usage of AI in healthcare promises to improve outcomes.
    Notably, the UK's National Health Service has announced an ambitious AI project
    to diagnose early-stage cancer, which can potentially save thousands of lives.
  prefs: []
  type: TYPE_NORMAL
- en: The transformative nature of AI has led experts to call it the fourth industrial
    revolution. AI is the catalyst that will shape modern industries, and having knowledge
    of AI is essential in this new world. By the end of this book, you will have a
    better understanding of the algorithms that power AI, and will have developed
    real-life projects using these cutting-edge algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A primer on machine learning and neural networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your computer for machine learning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing your machine learning projects from start to finish using the machine
    learning workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own neural network from scratch in Python without using a machine
    learning library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pandas for data analysis in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging machine learning libraries such as Keras to build powerful neural
    networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is machine learning?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although machine learning and AI are often used interchangeably, there are subtle
    differences that set them apart. The term AI was first coined in the 1950s, and
    it refers to the capability of a machine to imitate intelligent human behavior.
    To that end, researchers and computer scientists have pursued several approaches.
    Early efforts in AI were centered around an approach known as symbolic AI. Symbolic
    AI attempts to express human knowledge in a declarative form that computers could
    process. The height of symbolic AI resulted in the expert system, a computer system
    that emulated human decision making.
  prefs: []
  type: TYPE_NORMAL
- en: However, one major drawback of symbolic AI is that it relied on the domain knowledge
    of human experts, and required those rules and knowledge to be hardcoded for problem-solving.
    AI as a scientific field went through a period of drought (known as the AI winter),
    when scientists became increasingly disillusioned by the limitations of AI.
  prefs: []
  type: TYPE_NORMAL
- en: While symbolic AI took center stage in the 1950s, a subfield of AI known as
    machine learning was quietly bubbling in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning refers to algorithms that computers use to learn from data,
    allowing it to make predictions on future, unseen data.
  prefs: []
  type: TYPE_NORMAL
- en: However, early AI researchers did not pay much attention to machine learning,
    as computers back then were neither powerful enough nor had the capability to
    store the huge amount of data that machine learning algorithms require. As it
    turns out, machine learning would not be left in the cold for long. In the late
    2000s, AI enjoyed a resurgence, with machine learning largely propelling its growth.
    The key reason for this resurgence was the maturation of computer systems that
    could collect and store a massive amount of data (big data), along with processors
    that are fast enough to run the machine learning algorithms. Thus, the AI summer
    began.
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have talked about what machine learning is, we need to understand
    how machine learning algorithms work. Machine learning algorithms can be broadly
    classified into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Supervised learning**: Using labeled training data, the algorithm learns
    the rule for mapping the input variables into the target variable. For example,
    a supervised learning algorithm learns to predict whether there will be rain (the
    target variable) from input variables such as the temperature, time, season, atmospheric
    pressure, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unsupervised learning**: Using unlabeled training data, the algorithm learns
    associative rules for the data. The most common use case for unsupervised learning
    algorithms is in clustering analysis, where the algorithm learns hidden patterns
    and groups in data that are not explicitly labeled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book, we will focus on supervised learning algorithms. As a concrete
    example of a supervised learning algorithm, let''s consider the following problem.
    You are an animal lover and a machine learning enthusiast and you wish to build
    a machine learning algorithm using supervised learning to predict whether an animal
    is a friend (a friendly puppy) or a foe (a dangerous bear). For simplicity, let''s
    assume that you have collected two measurements from different breeds of dogs
    and bears—their **Weight** and their **Speed**. After collecting the data (known
    as the training dataset), you plot them out on a graph, along with their labels
    (**Friend or Foe**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66e4607f-a0dc-445c-8b1c-3b039eb7ac0c.png)'
  prefs: []
  type: TYPE_IMG
- en: Immediately, we can see that dogs tend to weigh less, and are generally faster,
    while bears are heavier and generally slower. If we draw a line (known as a decision
    boundary) between the dogs and the bears, we can use that line to make future
    predictions. Whenever we receive the measurements for a new animal, we can just
    see if it falls to the left or to the right of the line. Friends are to the left,
    and foes are to the right.
  prefs: []
  type: TYPE_NORMAL
- en: But this is a trivial dataset. What if we collect hundreds of different measurements?
    Then the graph would be more than 100-dimensional, and it would be impossible
    for a human being to draw a dividing line. However, such a task is not a problem
    for machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the task of the machine learning algorithm is to learn the
    optimal decision boundary separating the datasets. Ideally, we want the algorithm
    to produce a **Decision Boundary** that completely separates the two classes of
    data (although this is not always possible, depending on the dataset):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bede3862-ca7e-488b-b900-3bce50f65ae2.png)'
  prefs: []
  type: TYPE_IMG
- en: With this **Decision Boundary**, we can then make predictions on future, unseen
    data. If the **New Instance** lies to the left of the **Decision Boundary**, then
    we classify it as a friend. Vice versa, if the new instance lies to the right
    of the **Decision Boundary**, then we classify it as a foe.
  prefs: []
  type: TYPE_NORMAL
- en: In this trivial example, we have used only two input variables and two classes.
    However, we can generalize the problem to include multiple input variables with
    multiple classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, our choice of machine learning algorithm affects the kind of decision
    boundary produced. Some of the more popular supervised machine learning algorithms are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Neural networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear regression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logistic regression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Support vector machines** (**SVMs**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decision trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nature of the dataset (such as an image dataset or a numerical dataset)
    and the underlying problem that we are trying to solve should dictate the machine
    learning algorithm used. In this book, we will focus on neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: The machine learning workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have discussed what machine learning is. But how exactly do you *do* machine
    learning? At a high level, machine learning projects are all about taking in raw
    data as input and churning out **Predictions** as **Output**. To do that, there
    are several important intermediate steps that must be accomplished. This machine
    learning workflow can be summarized by the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14e0c1b0-4330-4fa7-88c3-80001e91d063.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Input** to our machine learning workflow will always be data. Data can
    come from different sources, with different data formats. For example, if we are
    working on a computer vision-based project, then our data will likely be images.
    For most other machine learning projects, the data will be presented in a tabular
    form, similar to spreadsheets. In some machine learning projects, data collection
    will be a significant first step. In this book, we will assume that the data will
    be provided to us, allowing us to focus on the machine learning aspect.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to preprocess the data. Raw data is often messy, error-prone,
    and unsuitable for machine learning algorithms. Hence, we need to preprocess the
    data before we feed it to our models. In cases where data is provided from multiple
    sources, we need to merge the data into a single dataset. Machine learning models
    also require a numeric dataset for training purposes. If there are any categorical
    variables in the raw dataset (that is, gender, country, day of week, and so on),
    we need to encode those variables as numeric variables. We will see how we can
    do so later on in the chapter. Data scaling and normalization is also required
    for certain machine learning algorithms. The intuition behind this is that if
    the magnitude of certain variables is much greater than other variables, then
    certain machine learning algorithms will mistakenly place more emphasis on those
    dominating variables.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world datasets are often messy. You will find that the data is incomplete
    and contains missing data in several rows and columns. There are several ways
    to deal with missing data, each with its own advantages and disadvantages. The
    easiest way is to simply discard rows and columns with missing data. However,
    this may not be practical, as we may end up discarding a significant percentage
    of our data. We can also replace the missing variables with the mean of the variables
    (if the variables happen to be numeric). This approach is more ideal than discarding
    data, as it preserves our dataset. However, replacing missing values with the
    mean tends to affect the distribution of the data, which may negatively impact
    our machine learning models. One other method is to predict what the missing values
    are, based on other values that are present. However, we have to be careful as
    doing this may introduce significant bias into our dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in **Data Preprocessing**, we need to split the dataset into a training
    and testing dataset. Our machine learning models will be trained and fitted only
    on the training set. Once we are satisfied with the performance of our model,
    we will then evaluate our model using the testing dataset. Note that our model
    should never be trained on the testing set. This ensures that the evaluation of
    model performance is unbiased, and will reflect its real-world performance.
  prefs: []
  type: TYPE_NORMAL
- en: Once **Data Preprocessing** has been completed, we will move on to **Exploratory
    Data Analysis** (**EDA**). EDA is the process of uncovering insights from your
    data using data visualization. EDA allows us to construct new features (known
    as feature engineering) and inject domain knowledge into our machine learning
    models.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we get to the heart of machine learning. After **Data Preprocessing**
    and EDA have been completed, we move on to **Model Building**. As mentioned in
    the earlier section, there are several machine learning algorithms at our disposal,
    and the nature of the problem should dictate the type of machine learning algorithm
    used. In this book, we will focus on neural networks. In **Model Building**, **Hyperparameter
    Tuning** is an essential step, and the right hyperparameters can drastically improve
    the performance of our model. In a later section, we will look at some of the hyperparameters
    in a neural network. Once the model has been trained, we are finally ready to
    evaluate our model using the testing set.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the machine learning workflow consists of many intermediate steps,
    each of which are crucial to the overall performance of our model. The major advantage
    of using Python for machine learning is that the entire machine learning workflow
    can be executed end-to-end entirely in Python, using just a handful of open source
    libraries. In this book, you will gain experience using Python in each step of
    the machine learning workflow, as you create sophisticated neural network projects
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your computer for machine learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive deeper into neural networks and machine learning, let's make
    sure that you have set up your computer properly, so that you can run the code
    in this book smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will use the Python programming language for each neural network
    project. Along with Python itself, we also require several Python libraries, such
    as Keras, pandas, NumPy, and many more. There are several ways to install Python
    and the required libraries, but the easiest way by far is to use Anaconda.
  prefs: []
  type: TYPE_NORMAL
- en: Anaconda is a free and open source distribution of Python and its libraries.
    Anaconda provides a handy package manager that allows us to easily install Python
    and all other libraries that we require. To install Anaconda, simply head to the
    website at [https://www.anaconda.com/distribution/](https://www.anaconda.com/distribution/) and
    download the Anaconda installer (select the Python 3.x installer).
  prefs: []
  type: TYPE_NORMAL
- en: Besides Anaconda, we also require Git. Git is essential for machine learning
    and software engineering in general. Git allows us to easily download code from
    GitHub, which is probably the most widely used software hosting service. To install
    Git, head to the Git website at [https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git).
    You can simply download and run the appropriate installer for your OS.
  prefs: []
  type: TYPE_NORMAL
- en: Once Anaconda and Git are installed, we are ready to download the code for this
    book. The code that you see in this book can be found in our accompanying GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download the code, simply run the following command from a command line
    (use Terminal if you''re using macOS/Linux, and if you''re using Windows, use
    the Anaconda Command Prompt):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `git clone` command will download all the Python code in this book to your
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that''s done, run the following command to move into the folder that you
    just downloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Within the folder, you will find a file titled `environment.yml`. With this
    file, we can install Python and all the required libraries into a virtual environment.
    You can think of a virtual environment as an isolated, sandboxed environment where
    we can install a fresh copy of Python and all the required libraries. The `environment.yml`
    file contains instructions for Anaconda to install a specific version of each
    library into a virtual environment. This ensures that the Python code will be
    executed in a standardized environment that we have designed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the required dependencies using Anaconda and the `environment.yml`
    file, simply execute the following command from a command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like that, Anaconda will install all required packages into a `neural-network-projects-python`
    virtual environment. To enter this virtual environment, we execute this next command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! We are now in a virtual environment with all dependencies installed.
    To execute a Python file in this virtual environment, we can run something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To leave the virtual environment, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Just note that you should be within the virtual environment (by running `conda
    activate neural-network-projects-python` first) whenever you run any Python code
    provided by us.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've set up our computer, let's return back to neural networks. We'll
    look at the theory behind neural networks, and how to program one from scratch
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Neural networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Neural networks are a class of machine learning algorithms that are loosely
    inspired by neurons in the human brain. However, without delving too much into
    brain analogies, I find it easier to simply describe neural networks as a mathematical
    function that maps a given input to the desired output. To understand what that
    means, let's take a look at a single layer neural network (known as a perceptron).
  prefs: []
  type: TYPE_NORMAL
- en: 'A **Perceptron** can be illustrated with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2e5d068-6510-410a-8d7d-4d5f4759683e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At its core, the **Perceptron** is simply a mathematical function that takes
    in a set of inputs, performs some mathematical computation, and outputs the result
    of the computation. In this case, that mathematical function is simply this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bdb4a2b7-f8d8-4120-bdeb-3f745715d1ca.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/50c8a031-2d2f-42a6-965d-378cae83b9ce.png) refers to the weights of
    the **Perceptron**. We will explain what the weights in a neural network refers
    to in the next few sections. For now, we just need to keep in mind that neural
    networks are simply mathematical functions that map a given input to a desired
    output.'
  prefs: []
  type: TYPE_NORMAL
- en: Why neural networks?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into creating our own neural network, it is worth understanding
    why neural networks have gained such an important foothold in machine learning
    and AI.
  prefs: []
  type: TYPE_NORMAL
- en: The first reason is that neural networks are universal function approximators.
    What that means is that given any arbitrary function that we are trying to model,
    no matter how complex, neural networks are alwaysable to represent that function.
    This has a profound implication on neural networks and AI in general. Assuming
    that any problem in the world can be described by a mathematical function (no
    matter how complex), we can use neural networks to represent that function, effectively
    modeling anything in the world. A caveat to this is that while scientists have
    proved the universality of neural networks, a large and complex neural network
    may never be trained and generalized correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The second reason is that the architecture of neural networks are highly scalable
    and flexible. As we will see in the next section, we can easily stack layers in
    each neural network, increasing the complexity of the neural network. Perhaps
    more interestingly, the capabilities of neural networks are only limited by our
    own imagination. Through creative neural network architecture design, machine
    learning engineers have learned how to use neural networks to predict time series
    data (known as **recurrent neural networks** (**RNNs**)), which are used in areas
    such as speech recognition. In recent years, scientists have also shown that by
    pitting two neural networks against each other in a contest (known as a **generative
    adversarial network** (**GAN**)), we can generate photorealistic images that are
    indistinguishable to the human eye.
  prefs: []
  type: TYPE_NORMAL
- en: The basic architecture of neural networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the basic architecture of neural networks,
    the building blocks on which all complex neural networks are based. We will also
    code up our own basic neural network from scratch in Python, without any machine
    learning libraries. This exercise will help you gain an intuitive understanding
    of the inner workings of neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Neural networks consist of the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: An input layer, *x*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An arbitrary amount of hidden layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An output layer, *ŷ*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of weights and biases between each layer, *W* and *b*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A choice of activation function for each hidden layer, ***σ***
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the architecture of a two-layer neural network
    (note that the input layer is typically excluded when counting the number of layers
    in a neural network):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/979cbfd4-9395-480d-9f30-6eb520569a9d.png)'
  prefs: []
  type: TYPE_IMG
- en: Training a neural network from scratch in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand the basic architecture of a neural network, let's create
    our own neural network from scratch in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a `NeuralNetwork` class in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the preceding code, we initialize the weights (`self.weights1`
    and `self.weights2`) as a NumPy array with random values. NumPy arrays are used
    to represent multidimensional arrays in Python. The exact dimensions of our weights
    are specified in the parameters of the `np.random.rand()` function. For the dimensions
    of the first weight array, we use a variable (`self.input.shape[1]`) to create
    an array of variable dimensions, depending on the size of our input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output, *ŷ*,of a simple two-layer neural network is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2f686f1-a94d-4f30-be9e-d29480326b24.png)'
  prefs: []
  type: TYPE_IMG
- en: You might notice that in the preceding equation, the weights, *W*,and the biases, *b*,are
    the only variables that affects the output, *ŷ*.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, the right values for the weights and biases determine the strength
    of the predictions. The process of fine-tuning the weights and biases from the
    input data is known as training the neural network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each iteration of the training process consists of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the predicted output **ŷ**,known as **Feedforward**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating the weights and biases, known as **Backpropagation**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following sequential graph illustrates the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e05188ed-5f65-4c56-9934-cb58361d5f3e.png)'
  prefs: []
  type: TYPE_IMG
- en: Feedforward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve seen in the preceding sequential graph, feedforward is just simple
    calculus, and for a basic two-layer neural network, the output of the neural network
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a5455e6-935d-4c34-82a5-102f26b78c2f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s add a `feedforward` function in our Python code to do exactly that.
    Note that for simplicity, we have assumed the biases to be `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, we still need a way to evaluate the accuracy of our predictions (that
    is, how far off our predictions are). The `loss` function allows us to do exactly
    that.
  prefs: []
  type: TYPE_NORMAL
- en: The loss function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many available `loss` functions, and the nature of our problem should
    dictate our choice of `loss` function. For now, we''ll use a simple *S**um-of-Squares
    Error* as our `loss` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e86faa7-73f3-4d34-9bf9-3c47dad08b5d.png)'
  prefs: []
  type: TYPE_IMG
- en: The *sum-of-squares error* is simply the sum of the difference between each
    predicted value and the actual value. The difference is squared so that we measure
    the absolute value of the difference.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal in training is to find the best set of weights and biases that minimizes
    the `loss` function.
  prefs: []
  type: TYPE_NORMAL
- en: Backpropagation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've measured the error of our prediction (loss), we need to find
    a way to propagate the error back, and to update our weights and biases.
  prefs: []
  type: TYPE_NORMAL
- en: In order to know the appropriate amount to adjust the weights and biases by,
    we need to know the derivative of the `loss` function with respect to the weights
    and biases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall from calculus that the derivative of a function is simply the slope
    of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/603d354a-7d0f-414f-8436-0f6b0f800c06.png)'
  prefs: []
  type: TYPE_IMG
- en: If we have the derivative, we can simply update the weights and biases by increasing/reducing
    with it (refer to the preceding diagram). This is known as **gradient descent**.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can't directly calculate the derivative of the `loss` function with
    respect to the weights and biases because the equation of the `loss` function
    does not contain the weights and biases. We need the chain ruleto help us calculate
    it. At this point, we are not going to delve into the chain rule because the math
    behind it can be rather complicated. Furthermore, machine learning libraries such
    as Keras takes care of gradient descent for us without requiring us to work out
    the chain rule from scratch. The key idea that we need to know is that once we
    have the derivative (slope) of the `loss` function with respect to the weights,
    we can adjust the weights accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add the `backprop` function into our Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the preceding code, we used a `sigmoid` function in the feedforward
    function. The `sigmoid` function is an activation function to *squash* the values
    between `0` and `1`. This is important because we need our predictions to be between
    `0` and `1` for this binary prediction problem. We will go through the `sigmoid`
    activation function in greater detail in the next chapter, [Chapter 2](81c9304f-2e96-4a6d-8ece-d972006f3180.xhtml),
    *Predicting Diabetes with Multilayer Perceptrons*.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our complete Python code for doing feedforward and backpropagation,
    let's apply our neural network on an example and see how well it does.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table contains four data points, each with three input variables
    ( *x[1]*, *x[2]*, and *x[3]*) and a target variable (*Y*):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **x[1]** | **x[2]** | **x[3]** | **Y** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: Our neural network should learn the ideal set of weights to represent this function.
    Note that it isn't exactly trivial for us to work out the weights just by inspection
    alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s train the neural network for 1,500 iterations and see what happens.
    Looking at the following loss-per-iteration graph, we can clearly see the loss monotonically
    decreasing toward a minimum. This is consistent with the gradient descent algorithm
    that we discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2237ea9f-d19e-4b91-a4cc-8315e58c47d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the final prediction (output) from the neural network after
    1,500 iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Prediction** | **Y (Actual)** |'
  prefs: []
  type: TYPE_TB
- en: '| 0.023 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0.979 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0.975 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0.025 | 0 |'
  prefs: []
  type: TYPE_TB
- en: We did it! Our feedforward and backpropagation algorithm trained the neural
    network successfully and the predictions converged on the true values.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there's a slight difference between the predictions and the actual
    values. This is desirable, as it prevents overfitting and allows the neural network
    to generalizebetter to unseen data.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the inner workings of a neural network, we will introduce
    the machine learning libraries in Python that we will use for the rest of the
    book. Don't worry if you find it difficult to create your own neural network from
    scratch at this point. For the rest of the book, we'll be using libraries that
    will greatly simplify the process of building and training a neural network.
  prefs: []
  type: TYPE_NORMAL
- en: Deep learning and neural networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What about deep learning? How is it different from neural networks? To put it
    simply, deep learning is a machine learning algorithm that uses multiple layers
    in a neural network for learning (also known as deep nets). While we can think
    of a single-layer perceptron as the simplest neural network, deep nets are simply
    neural networks on the opposite end of the complexity spectrum.
  prefs: []
  type: TYPE_NORMAL
- en: In a **deep neural network** (**DNN**), each layer learns information of increasing
    complexity, before passing it to successive layers. For example, when a DNN is
    trained for the purpose of facial recognition, the first few layers learn to identify
    edges in faces, followed by contours such as eyes and eventually complete facial
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Although perceptrons were introduced back in the 1950s, deep learning did not
    take off until a few years ago. A key reason for the relatively slow progress
    of deep learning in the past few centuries is largely due to a lack of data and
    a lack of computation power. In the past few years, however, we have witnessed
    deep learning driving key innovations in machine learning and AI. Today, deep
    learning is the algorithm of choice when it comes to image recognition, autonomous
    vehicles, speech recognition, and game playing. So, what changed over the last
    few years?
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, computer storage has become affordable enough to collect and
    store the massive amount of data that deep learning requires. It is becoming increasingly
    affordable to keep massive amount of data in the cloud, where it can be accessed
    by a cluster of computers from anywhere on earth. With the affordability of data
    storage, data is also becoming democratized. For example, websites such as ImageNet
    provides 14 million different images for deep learning researchers. Data is no
    longer a commodity that is owned by a privileged few.
  prefs: []
  type: TYPE_NORMAL
- en: The computational power that deep learning requires is also becoming more affordable
    and powerful. Most of deep learning today is powered by **graphics processing
    units** (**GPUs**), which excel in the computation required by DNNs. Keeping with
    the theme of democratization, many websites also provides free GPU processing
    power for deep learning enthusiasts. For example, Google Colab provides a free
    Tesla K80 GPU in the cloud for deep learning, available for anyone to use.
  prefs: []
  type: TYPE_NORMAL
- en: With these recent advancements, deep learning is becoming available to everyone.
    In the next few sections, we will introduce the Python libraries that we will
    use for deep learning.
  prefs: []
  type: TYPE_NORMAL
- en: pandas – a powerful data analysis toolkit in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pandas is perhaps the most ubiquitous library in Python for data analysis. Built
    upon the powerful NumPy library, pandas provides a fast and flexible data structure
    in Python for handling real-world datasets. Raw data is often presented in tabular
    form, shared using the `.csv` file format. pandas provides a simple interface
    for importing these `.csv` files into a data structure known as DataFrames that
    makes it extremely easy to manipulate data in Python.
  prefs: []
  type: TYPE_NORMAL
- en: pandas DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'pandas DataFrames are two-dimensional data structures, which you can think
    of as spreadsheets in Excel. DataFrames allow us to easily import the `.csv` files
    using a simple command. For example, the following sample code allows us to import
    the `raw_data.csv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the data is imported as a DataFrame, we can easily perform data preprocessing
    on it. Let''s work through it using the Iris flower dataset. The Iris flower dataset
    is a commonly used dataset that contains data on the measurements (sepal length
    and width, petal length and width) of several classes of flowers. First, let''s
    import the dataset as provided for free by **University of California Irvine**
    (**UCI**). Notice that pandas is able to import a dataset directly from a URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that it''s in a DataFrame, we can easily manipulate the data. First, let''s
    get a summary of the data as it is always important to know what kind of data
    we''re working with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8594b08a-140e-4ab0-b189-fe08c6d0007f.png)'
  prefs: []
  type: TYPE_IMG
- en: It looks like there are 150 rows in the dataset, with four numeric columns containing
    information regarding the `sepal_length` and `sepal_width`, along with the `petal_length`
    and `petal_width`. There is also one non-numeric column containing information
    regarding the class (that is, species) of the flowers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get a quick statistical summary of the four numeric columns by calling
    the `describe()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d55aa987-bbc2-43bd-8c6c-ab9420cee49a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, let''s take a look at the first 10 rows of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21b44887-cd45-48e2-9a46-ddc688f77d40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Simple, isn''t it? pandas also allows us to perform data wrangling easily.
    For example, we can do the following to filter and select rows with `sepal_length`
    greater than `5.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c819132e-6363-45c8-853e-e1e32062e3a9.png)'
  prefs: []
  type: TYPE_IMG
- en: The `loc` command allows us to access a group of rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: Data visualization in pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EDA is perhaps one of the most important steps in the machine learning workflow,
    and pandas makes it extremely easy to visualize data in Python. pandas provides
    a high-level API for the popular `matplotlib` library, which makes it easy to
    construct plots directly from DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s visualize the Iris dataset using pandas to uncover important
    insights. Let''s plot a scatterplot to visualize how `sepal_width` is related
    to `sepal_length`. We can construct a scatterplot easily using the `DataFrame.plot.scatter()`
    method, which is built into all DataFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll get a scatterplot, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6c4ba47-98da-48da-8c21-85d90e461773.png)'
  prefs: []
  type: TYPE_IMG
- en: From the scatterplot, we can notice some interesting insights. First, the relationship
    between `sepal_width` and `sepal_length` is dependent on the species. Setosa (dots)
    has a fairly linear relationship between `sepal_width` and `sepal_length`, while
    versicolor (triangle) and virginica (star) tends to have much greater `sepal_length`
    than Setosa. If we're designing a machine learning algorithm to predict the type
    of species of flower, we know that the `sepal_width` and `sepal_length` are important
    features to include in our model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s plot a histogram to investigate the distribution. Consistent with
    scatterplots, pandas DataFrames provides a built in method to plot histograms
    using the `DataFrame.plot.hist()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can see the output in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd8c1d3b-b859-485a-902f-59b5379a5ff3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the distribution of petal lengths is essentially bimodal. It
    appears that certain species of flowers have shorter petals than the rest. We
    can also plot a boxplot of the data. The boxplot is an important data visualization
    tool used by data scientists to understand the distribution of the data based
    on the first quartile, median, and the third quartile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is given in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f91a419-3b73-47d9-bf0b-9f988805dbea.png)'
  prefs: []
  type: TYPE_IMG
- en: From the boxplot, we can see that the variance of `sepal_width` is much smaller
    than the other numeric variables, with `petal_length` having the greatest variance.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how convenient and easy it is to visualize data using pandas
    directly. Keep in mind that EDA is a crucial step in the machine learning pipeline,
    and it is something that we will continue to do in every project for the rest
    of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Data preprocessing in pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lastly, let's take a look at how we can use pandas for data preprocessing, specifically
    to encode categorical variables and to impute missing values.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding categorical variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In machine learning projects, it is common to receive datasets with categorical
    variables. Here are some examples of categorical variables in datasets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gender**: Male, female'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Day**:Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Country**:USA, UK, China, Japan'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machine learning algorithms such as neural networks are unable to work with
    such categorical variables as they expect numerical variables. Therefore, we need
    to perform preprocessing on these variables before feeding them into a machine
    learning algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common way to convert these categorical variables into numerical variables
    is a technique known as one-hot encoding, implemented by the `get_dummies()` function
    in pandas. One-hot encoding is a process that converts a categorical variable
    with `n` categories into `n` distinct binary features. An example is provided
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/493047e9-352a-4f6d-8ad7-310528d2a7d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Essentially, the transformed features are binary features with a **1** value
    if it represents the original feature, and **0** otherwise. As you can imagine,
    it would be a hassle to write the code for this manually. Fortunately, pandas
    has a handy function that does exactly that. First, let''s create a DataFrame
    in pandas using the data in the preceding table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the output in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4e56c5d-278d-4beb-afeb-6572cbe9486a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To one-hot encode the preceding categorical feature using pandas, it is as
    simple as calling the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b5a3920-12aa-4c02-8cde-0d330f4927f7.png)'
  prefs: []
  type: TYPE_IMG
- en: Imputing missing values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed earlier, imputing missing values is an essential part of the machine
    learning workflow. Real-world datasets are messy and usually contain missing values.
    Most machine learning models such as neural networks are unable to work with missing
    data, and hence we have to preprocess the data before we feed the data into our
    models. pandas makes it easy to handle missing values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the Iris dataset from earlier. The Iris dataset does not have any
    missing values by default. Therefore, we have to delete some values on purpose
    for the sake of this exercise. The following code randomly selects `10` rows in
    the dataset, and deletes the `sepal_length` values in these `10` rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use this modified dataset to see how we can deal with missing values. First,
    let''s check where our missing values are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `print` function gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab3a96aa-9d4c-43e5-a26a-1c9a4981616e.png)'
  prefs: []
  type: TYPE_IMG
- en: Unsurprisingly, pandas tells us that there are missing (that is, null) values
    in the `sepal_length` column. This command is useful to find out which columns
    in our dataset contains missing values.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to deal with missing values is to simply remove any rows with missing
    values. pandas provides a handy `dropna` function for us to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03ec86b0-1d20-45a2-a573-e1db0a2b9737.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another way is to replace the missing `sepal_length` values with the mean of
    the non-missing `sepal_length` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: pandas will automatically exclude the missing values when calculating the mean
    using `df.mean()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s confirm that there are no missing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6da172fd-6933-44e2-90af-951b5589e9db.png)'
  prefs: []
  type: TYPE_IMG
- en: With the missing values handled, we can then pass the DataFrame to machine learning
    models.
  prefs: []
  type: TYPE_NORMAL
- en: Using pandas in neural network projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how pandas can be used to import tabular data in `.csv` format,
    and perform data preprocessing and data visualization directly using built-in
    functions in pandas. For the rest of the book, we will use pandas when the dataset
    is of a tabular nature. pandas plays a crucial role in data preprocessing and
    EDA, as we shall see in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: TensorFlow and Keras – open source deep learning libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TensorFlow is an open source library for neural networks and deep learning developed
    by the Google Brain team. Designed for scalability, TensorFlow runs across a variety
    of platforms, from desktops to mobile devices and even to clusters of computers.
    Today, TensorFlow is one of the most popular machine learning libraries and is
    used extensively in a wide variety of real-world applications. For example, TensorFlow
    powers the AI behind many online services that we use today, including image search,
    voice recognition, recommendation engines. TensorFlow has become the silent workhorse
    powering many AI applications, even though we might not even notice it.
  prefs: []
  type: TYPE_NORMAL
- en: Keras is a high-level API that runs on top of TensorFlow. So, why Keras? Why
    do we need another library to act as an API for TensorFlow? To put it simply,
    Keras removes the complexities in building neural networks, and enables rapid
    experimentation and testing without concerning the user with low-level implementation
    details. Keras provides a simple and intuitive API for building neural networks
    using TensorFlow. Its guiding principles are modularity and extensibility. As
    we shall see later, it is extremely easy to build neural networks by stacking
    Keras API calls on top of one another, which you can think of like stacking Lego
    blocks in order to create bigger structures. This beginner-friendly approach has
    led to the popularity of Keras as one of the top machine learning libraries in
    Python. In this book, we will use Keras as the primary machine learning library
    for building our neural network projects.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental building blocks in Keras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fundamental building blocks in Keras are layers, and we can stack layers
    linearly to create a model. The **Loss Function **that we choose will provide
    the metrics for which we will use to train our model using an **Optimizer. **Recall
    that while building our neural network from scratch earlier, we had to define
    and write the code for those terms. We call these the fundamental building blocks
    in Keras because we can build any neural network using these basic structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the relationship between these building blocks
    in Keras:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/081fd69c-7a42-4394-a198-a533a7e2892d.png)'
  prefs: []
  type: TYPE_IMG
- en: Layers – the atom of neural networks in Keras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can think of layers in Keras as an atom, because they are the smallest unit
    of our neural network. Each layer takes in an input performs a mathematical function,
    then outputs that for the next layer. The core layers in Keras includes dense
    layers, activation layers, and dropout layers. There are other layers that are
    more complex, including convolutional layers and pooling layers. In this book,
    you will be exposed to projects that uses all these layers.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's take a closer look at dense layers, which are by far the most
    common type of layer used in Keras. A dense layer is also known as a fully-connected
    layer. It is fully-connected because it uses all of its input (as opposed to a
    subset of the input) for the mathematical function that it implements.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dense layer implements the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1899d70e-e335-4861-a5b2-afdbc619f1d0.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/b4d15384-5e35-4805-9005-2c8d0eb02210.png) is the output, ![](img/cb669ce2-0c83-4127-ae60-d0105f4b99ed.png) is
    the activation function, ![](img/81a91630-b8d9-443e-ac60-657e76f6808c.png) is
    the input, and ![](img/5f5bd2fa-6f2c-408b-b07c-834d7b3f2462.png) and ![](img/825fd59c-a153-4f9e-97f5-41c17f287c57.png) are
    the weights and biases respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: This equation should look familiar to you. We used the fully-connected layer
    when we were building our neural network from scratch earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Models – a collection of layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If layers can be thought of as atoms, then models can be thought of as molecules
    in Keras. A model is simply a collection of layers, and the most commonly used
    model in Keras is the `Sequential` model. A `Sequential` model allows us to linearly
    stack layers on one another, where a single layer is connected to one other layer
    only. This allows us to easily design model architectures without worrying about
    the underlying math. As we will see in later chapters, there is a significant
    amount of thought needed to ensure that consecutive layer dimensions are compatible with
    one another, something that Keras takes care for us under the hood!
  prefs: []
  type: TYPE_NORMAL
- en: Once we have defined our model architecture, we need to define our training
    process, which is done using the `compile` method in Keras. The `compile`  method
    takes in several arguments, but the most important arguments we need to define
    is the optimizer and the loss function.
  prefs: []
  type: TYPE_NORMAL
- en: Loss function – error metric for neural network training
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an earlier section, we defined the loss function as a way to evaluate the
    goodness of our predictions (that is, how far off our predictions are). The nature
    of our problem should dictate the loss function used. There are several loss functions
    implemented in Keras, but the most commonly used loss functions are `mean_squared_error`, `categorical_crossentropy`,
    and `binary_crossentropy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a general rule of thumb, this is how you should choose which loss function
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mean_squared_error` if the problem is a regression problem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`categorical_crossentropy` if the problem is a multiclass classification problem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary_crossentropy` if the problem is a binary classification problem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In certain cases, you might find that the default loss functions in Keras are
    unsuitable for your problem. In that case, you can define your own loss function
    by defining a custom function in Python, then passing that custom function to
    the `compile` method in Keras.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizers – training algorithm for neural networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An optimizer is an algorithm for updating the weights of the neural network
    in the training process. Optimizers in Keras are based on the gradient descent
    algorithm, which we have covered in an earlier section.
  prefs: []
  type: TYPE_NORMAL
- en: While we won't cover in detail the differences between each optimizer, it is
    important to note that our choice of optimizer should depend on the nature of
    the problem. In general, researchers have found that the `Adam` optimizer works
    best for DNNs, while the `sgd` optimizer works best for shallow neural networks.
    The `Adagrad` optimizer is also a popular choice, and it adapts the learning rate
    of the algorithm based on how frequent a particular set of weights are updated.
    The main advantage of this approach is that it eliminates the need to manually
    tune the learning rate hyperparameter, which is a time-consuming process in the
    machine learning workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Creating neural networks in Keras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can use Keras to build the two-layer neural network
    that we introduced earlier. To build a linear collection of layers, first declare
    a `Sequential` model in Keras:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates an empty  `Sequential` model that we can now add layers to. Adding
    layers in Keras is simple and similar to stacking Lego blocks on top of one another.
    We start by adding layers from the left (the layer closest to the input):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Stacking layers in Keras is as simple as calling the `model.add()` command.
    Notice that we had to define the number of units in each layer. Generally, increasing
    the number of units increases the complexity of the model, as it means that there
    are more weights to be trained. For the first layer, we had to define `input_dim`.
    This informs Keras the number of features (that is, columns) in the dataset. Also,
    note that we have used a `Dense` layer. A `Dense` layer is simply a fully connected
    layer. In later chapters, we will introduce other kinds of layers, specific to
    different types of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify the structure of our model by calling the `model.summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9289d890-2b97-4c18-9e1b-9c1886620e33.png)'
  prefs: []
  type: TYPE_IMG
- en: The number of params is the number of weights and biases we need to train for
    the model that we have just defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are satisfied with our model''s architecture, let''s compile it and
    start the training process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have defined the learning rate of the `sgd` optimizer to be 1.0
    (`lr=1`). In general, the learning rate is a hyperparameter of the neural network
    that needs to be tuned carefully depending on the problem. We will take a closer
    look at tuning hyperparameters in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The `mean_squared_error` loss function in Keras is similar to the sum-of-squares
    error that we have defined earlier. We are using the SGDoptimizer to train our
    model. Recall that gradient descent is the method of updating the weights and
    biases by moving it toward the derivative of the loss function with respect to
    the weights and biases.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the same data that we used earlier to train our neural network. This
    will allow us to compare the predictions obtained using Keras versus the predictions
    obtained when we created our neural network from scratch earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define an `X` and `Y` NumPy array, corresponding to the features and
    the target variables respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s train the model for `1500` iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the predictions, run the `model.predict()` command on our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fbc61878-0d50-4431-a6d6-913d66f5196c.png)'
  prefs: []
  type: TYPE_IMG
- en: Comparing this to the predictions that we obtained earlier, we can see that
    the results are extremely similar. The major advantage of using Keras is that
    we did not have to worry about the low-level implementation details and mathematics
    while building our neural network, unlike what we did earlier. In fact, we did
    no math at all. All we did in Keras was to call a series of APIs to build our
    neural network. This allows us to focus on high-level details, enabling rapid
    experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: Other Python libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides pandas and Keras, we will also be using other Python libraries, such
    as scikit-learn and seaborn. scikit-learn is an open source machine learning library
    that is widely used in machine learning projects. The main functionality that
    we use in scikit-learn is to separate our data into a training and testing set
    during data preprocessing. seaborn is an alternative data visualization in Python
    that has been gaining traction recently. In the later chapters, we'll see how
    we can use seaborn to make data visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen what machine learning is, and looked at the complete
    end-to-end workflow for every machine learning project. We have also seen what
    neural networks and deep learning is, and coded up our own neural network from
    scratch and in Keras.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of the book, we will create our own real-world neural network projects.
    Each chapter will cover one project, and the projects are listed in order of increasing
    complexity. By the end of the book, you will have created your own neural network
    projects in medical diagnosis, taxi fare predictions, image classification, sentiment
    analysis, and much more. In the next chapter, [Chapter 2](81c9304f-2e96-4a6d-8ece-d972006f3180.xhtml),
    *Predicting Diabetes with Multilayer Perceptrons* we will cover diabetes prediction
    with **multilayer perceptrons** (**MLPs**). Let's get started!
  prefs: []
  type: TYPE_NORMAL
