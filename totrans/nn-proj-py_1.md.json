["```py\n$ git clone https://github.com/PacktPublishing/Neural-Network-Projects-with-Python\n```", "```py\n$ cd Neural-Network-Projects-with-Python\n```", "```py\n$ conda env create -f environment.yml\n```", "```py\n$ conda activate neural-network-projects-python\n```", "```py\n$ python Chapter01\\keras_chapter1.py\n```", "```py\n$ conda deactivate\n```", "```py\nimport numpy as np\n\nclass NeuralNetwork:\n    def __init__(self, x, y):\n        self.input    = x\n        self.weights1 = np.random.rand(self.input.shape[1],4) \n        self.weights2 = np.random.rand(4,1) \n        self.y        = y\n        self.output = np.zeros(self.y.shape)\n```", "```py\nimport numpy as np\n\ndef sigmoid(x):\n    return 1.0/(1 + np.exp(-x))\n\nclass NeuralNetwork:\n    def __init__(self, x, y):\n        self.input    = x\n        self.weights1 = np.random.rand(self.input.shape[1],4) \n        self.weights2 = np.random.rand(4,1) \n        self.y        = y\n        self.output   = np.zeros(self.y.shape)\n\n    def feedforward(self):\n        self.layer1 = sigmoid(np.dot(self.input, self.weights1))\n        self.output = sigmoid(np.dot(self.layer1, self.weights2))\n\n```", "```py\nimport numpy as np\n\ndef sigmoid(x):\n    return 1.0/(1 + np.exp(-x))\n\ndef sigmoid_derivative(x):\n   return x * (1.0 - x)\n\nclass NeuralNetwork:\n    def __init__(self, x, y):\n        self.input    = x\n        self.weights1 = np.random.rand(self.input.shape[1],4) \n        self.weights2 = np.random.rand(4,1) \n        self.y        = y\n        self.output = np.zeros(self.y.shape)\n\n    def feedforward(self):\n        self.layer1 = sigmoid(np.dot(self.input, self.weights1))\n        self.output = sigmoid(np.dot(self.layer1, self.weights2))\n\n    def backprop(self):\n        # application of the chain rule to find the derivation of the \n        # loss function with respect to weights2 and weights1\n        d_weights2 = np.dot(self.layer1.T, (2*(self.y - self.output) *                                                                          \n                     sigmoid_derivative(self.output)))       \n        d_weights1 = np.dot(self.input.T, (np.dot(2*(self.y - self.output) \n                    * sigmoid_derivative(self.output), self.weights2.T) *                                                \n                      sigmoid_derivative(self.layer1))) \n\n        self.weights1 += d_weights1\n        self.weights2 += d_weights2\n\nif __name__ == \"__main__\":\n    X = np.array([[0,0,1],\n                  [0,1,1],\n                  [1,0,1],\n                  [1,1,1]])\n    y = np.array([[0],[1],[1],[0]])\n    nn = NeuralNetwork(X,y)\n\n    for i in range(1500):\n        nn.feedforward()\n        nn.backprop()\n\n    print(nn.output)\n```", "```py\nimport pandas as pd\ndf = pd.read_csv(\"raw_data.csv\")\n```", "```py\nURL = \\\n    'https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data'\ndf = pd.read_csv(URL, names = ['sepal_length', 'sepal_width', \n                               'petal_length', 'petal_width', 'class'])\n```", "```py\nprint(df.info())\n```", "```py\nprint(df.describe())\n```", "```py\nprint(df.head(10))\n```", "```py\ndf2 = df.loc[df['sepal_length'] > 5.0, ]\n```", "```py\n# Define marker shapes by class\nimport matplotlib.pyplot as plt\nmarker_shapes = ['.', '^', '*']\n\n# Then, plot the scatterplot\nax = plt.axes()\nfor i, species in enumerate(df['class'].unique()):\n    species_data = df[df['class'] == species]\n    species_data.plot.scatter(x='sepal_length',\n                              y='sepal_width', \n                              marker=marker_shapes[i],\n                              s=100,\n                              title=\"Sepal Width vs Length by Species\", \n                              label=species, figsize=(10,7), ax=ax)\n```", "```py\ndf['petal_length'].plot.hist(title='Histogram of Petal Length')\n```", "```py\ndf.plot.box(title='Boxplot of Sepal Length & Width, and Petal Length & Width')\n```", "```py\ndf2 = pd.DataFrame({'Day': ['Monday','Tuesday','Wednesday',\n                           'Thursday','Friday','Saturday',\n                           'Sunday']})\n```", "```py\nprint(pd.get_dummies(df2))\n```", "```py\nimport numpy as np\nimport pandas as pd\n\n# Import the iris data once again\nURL = \\\n    'https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data'\ndf = pd.read_csv(URL, names = ['sepal_length', 'sepal_width', \n                               'petal_length', 'petal_width', 'class'])\n\n# Randomly select 10 rows\nrandom_index = np.random.choice(df.index, replace= False, size=10)\n\n# Set the sepal_length values of these rows to be None\ndf.loc[random_index,'sepal_length'] = None\n```", "```py\nprint(df.isnull().any())\n```", "```py\nprint(\"Number of rows before deleting: %d\" % (df.shape[0]))\ndf2 = df.dropna()\nprint(\"Number of rows after deleting: %d\" % (df2.shape[0]))\n```", "```py\ndf.sepal_length = df.sepal_length.fillna(df.sepal_length.mean())\n```", "```py\nfrom keras.models import Sequential\nmodel = Sequential()\n```", "```py\nfrom keras.layers import Dense\n# Layer 1\nmodel.add(Dense(units=4, activation='sigmoid', input_dim=3))\n# Output Layer\nmodel.add(Dense(units=1, activation='sigmoid'))\n```", "```py\nprint(model.summary())\n```", "```py\nfrom keras import optimizers\nsgd = optimizers.SGD(lr=1)\nmodel.compile(loss='mean_squared_error', optimizer=sgd)\n```", "```py\nimport numpy as np\n# Fixing a random seed ensures reproducible results\nnp.random.seed(9)\n\nX = np.array([[0,0,1],\n              [0,1,1],\n              [1,0,1],\n              [1,1,1]])\ny = np.array([[0],[1],[1],[0]])\n```", "```py\nmodel.fit(X, y, epochs=1500, verbose=False)\n```", "```py\nprint(model.predict(X))\n```"]