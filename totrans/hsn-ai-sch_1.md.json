["```py\npip install pydot \n```", "```py\npip install matplotlib  \n```", "```py\n....\nimport os \n\nclass State:\n    '''\n    This class retrieves state information for search application\n    '''\n\n    def __init__(self, path = None):\n        if path == None:\n            #create initial state\n            self.path = self.getInitialState()\n        else:\n            self.path = path\n\n    def getInitialState(self):\n        \"\"\"\n        This method returns the current directory\n        \"\"\"\n        initialState = os.path.dirname(os.path.realpath(__file__))\n        return initialState\n ....\n```", "```py\n...\nfrom State import State\nimport os\nimport pprint\n\n```", "```py\ninitialState = State()\nprint \"initialState\", initialState.path\n\ninterState = State(os.path.join(initialState.path, \"d2\", \"d21\"))\ngoalState = State(os.path.join(initialState.path, \"d2\", \"d21\", \"f211.txt\"))\n\nprint \"interState\", interState.path\nprint \"goalState\", goalState.path\n....\n```", "```py\n...\n    def successorFunction(self):\n        \"\"\"\n        This is the successor function. It generates all the possible\n         paths that can be reached from current path.\n        \"\"\"\n```", "```py\n        if os.path.isdir(self.path):\n            return [os.path.join(self.path, x) for x in         \n            sorted(os.listdir(self.path))]\n        else:\n            return []\n...\n```", "```py\n...\ninitialState = State()\nprint \"initialState\", initialState.path\n\ninterState = State(os.path.join(initialState.path, \"d2\", \"d21\"))\ngoalState = State(os.path.join(initialState.path, \"d2\", \"d21\", \"f211.txt\"))\n\nprint \"interState\", interState.path\nprint \"goalState\", goalState.path\n...\n```", "```py\n...\ndef checkGoalState(self):\n        \"\"\"\n        This method checks whether the path is goal state \n        \"\"\" \n        #check if it is a folder\n        if os.path.isdir(self.path):\n            return False\n        else:\n            #extract the filename\n            fileSeparatorIndex = self.path.rfind(os.sep)\n            filename = self.path[fileSeparatorIndex + 1 : ]\n            if filename == \"f211.txt\":\n                return True\n            else:\n                return False\n...\n```", "```py\n...\nclass Node:\n    '''\n    This class represents a node in the search tree\n    '''\n\n    def __init__(self, state):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.state = state\n        self.depth = 0\n        self.children = []\n        self.parent = None\n...\n```", "```py\ndef addChild(self, childNode):\n        \"\"\"\n        This method adds a node under another node\n        \"\"\"\n        self.children.append(childNode)\n        childNode.parent = self\n        childNode.depth = self.depth + 1\n```", "```py\ndef printTree(self):\n        \"\"\"\n        This method prints the tree\n        \"\"\"\n        print self.depth , \" - \" , self.state.path\n        for child in self.children:\n            child.printTree()\n```", "```py\n...\nfrom Node import Node\nfrom State import State\n\ninitialState = State()\nroot = Node(initialState)\n\nchildStates = initialState.successorFunction()\nfor childState in childStates:\n    childNode = Node(State(childState))\n    root.addChild(childNode)\n\nroot.printTree()\n...\n```", "```py\n...\nstack = []\n\nprint \"stack\", stack\n\n#add items to the stack\nstack.append(1)\nstack.append(2)\nstack.append(3)\nstack.append(4)\n\nprint \"stack\", stack\n\n#pop all the items out\nwhile len(stack) > 0:\n    item = stack.pop()\n    print item\n\nprint \"stack\", stack\n...\n```", "```py\n...\nfrom Node import Node\nfrom State import State\n\ndef performStackDFS():\n    \"\"\"\n    This function performs DFS search using a stack\n    \"\"\"\n    #create stack\n    stack = []\n\n    #create root node and add to stack \n    initialState = State()\n    root = Node(initialState)\n    stack.append(root)\n...\n```", "```py\n...\nwhile len(stack) > 0:\n\n        #pop top node\n        currentNode = stack.pop()\n\n        print \"-- pop --\", currentNode.state.path\n\n        #check if this is goal state\n        if currentNode.state.checkGoalState():\n            print \"reached goal state\"\n            break\n\n        #get the child nodes \n        childStates = currentNode.state.successorFunction()\n        for childState in childStates:\n            childNode = Node(State(childState))\n            currentNode.addChild(childNode)\n\n...\n```", "```py\n...\nfor index in range(len(currentNode.children) - 1, -1, -1):\n            stack.append(currentNode.children[index])\n\n#print tree\n    print \"----------------------\"\n    root.printTree()\n...\n```", "```py\n...\ndef fibonacci(n):\n    if n <= 2:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n\nprint \"fibonacci(5)\", fibonacci(5)\n...\n```", "```py\n...\nfrom State import State\nfrom Node import Node\n\nclass RecursiveDFS():\n    \"\"\"\n    This performs DFS search\n    \"\"\"\n    def __init__(self):\n        self.found = False\n...\n```", "```py\n...\n    def search(self):\n        \"\"\"\n        This method performs the search\n        \"\"\"\n        #get the initial state\n        initialState = State()\n\n        #create root node\n        rootNode = Node(initialState)\n\n        #perform search from root node\n        self.DFS(rootNode)\n\n        rootNode.printTree()\n...\n```", "```py\n...\ndef DFS(self, node):\n        \"\"\"\n        This creates the search tree\n        \"\"\"\n        if not self.found:\n            print \"-- proc --\", node.state.path\n\n            #check if we have reached goal state\n            if node.state.checkGoalState():\n                print \"reached goal state\"\n                #self.found = True\n\n            else:\n                #find the successor states from current state \n                childStates = node.state.successorFunction()\n\n                #add these states as children nodes of current node\n                for childState in childStates:\n                    childNode = Node(State(childState))\n                    node.addChild(childNode)\n\n                    self.DFS(childNode)\n....\n```"]