<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Personal and Home IoT</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">Now that you are fully equipped with </span><strong><span class="koboSpan" id="kobo.3.1">machine learning</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">ML</span></strong><span class="koboSpan" id="kobo.6.1">) and </span><strong><span class="koboSpan" id="kobo.7.1">deep learning</span></strong><span class="koboSpan" id="kobo.8.1"> (</span><strong><span class="koboSpan" id="kobo.9.1">DL</span></strong><span class="koboSpan" id="kobo.10.1">) knowledge, and have learned how to use it for big data, image tasks, text tasks, and time series data, it is time to explore some real uses of the algorithms and the techniques that you have learned. </span><span class="koboSpan" id="kobo.10.2">This chapter and the following two chapters will now concentrate on some specific case studies. </span><span class="koboSpan" id="kobo.10.3">This chapter will focus on personal and home </span><strong><span class="koboSpan" id="kobo.11.1">Internet of Things</span></strong><span class="koboSpan" id="kobo.12.1"> (</span><strong><span class="koboSpan" id="kobo.13.1">IoT</span></strong><span class="koboSpan" id="kobo.14.1">) use cases. </span><span class="koboSpan" id="kobo.14.2">We will cover the following in this chapter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">Successful IoT applications</span></li>
<li><span class="koboSpan" id="kobo.16.1">Wearables and their role in personal IoT</span></li>
<li><span class="koboSpan" id="kobo.17.1">How to monitor heart using ML</span></li>
<li><span class="koboSpan" id="kobo.18.1">What makes home smart home</span></li>
<li><span class="koboSpan" id="kobo.19.1">Devices used in smart home</span></li>
<li><span class="koboSpan" id="kobo.20.1">The application of Artificial Intelligence in predicting human activity recognition</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Personal IoT</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The personal IoT is dominated by the use of wearables, technological devices designed to be worn on body, they are used in tandem with an app on a smartphone. </span><span class="koboSpan" id="kobo.2.2">The first wearable available was the Pulsar Calculator watch made by Time Computer Inc, USA (at that time known as </span><strong><span class="koboSpan" id="kobo.3.1">Hamilton Watch Company</span></strong><span class="koboSpan" id="kobo.4.1">). </span><span class="koboSpan" id="kobo.4.2">It was a standalone device not connected to the internet. </span><span class="koboSpan" id="kobo.4.3">Soon, with the growth of the internet, wearables that can connect to the internet became a fad. </span><span class="koboSpan" id="kobo.4.4">The wearables market is expected to jump from an estimate of </span><strong><span class="koboSpan" id="kobo.5.1">325</span></strong> <strong><span class="koboSpan" id="kobo.6.1">million</span></strong><span class="koboSpan" id="kobo.7.1"> in </span><strong><span class="koboSpan" id="kobo.8.1">2016</span></strong><span class="koboSpan" id="kobo.9.1"> to over </span><strong><span class="koboSpan" id="kobo.10.1">830</span></strong> <strong><span class="koboSpan" id="kobo.11.1">million</span></strong><span class="koboSpan" id="kobo.12.1"> by </span><strong><span class="koboSpan" id="kobo.13.1">2020</span></strong><span class="koboSpan" id="kobo.14.1">:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.15.1"><img class="aligncenter size-full wp-image-1108 image-border" src="assets/11b5c44d-8c4c-4040-adeb-2c5498122d54.png" style="width:35.92em;height:24.08em;"/></span></p>
<p><span class="koboSpan" id="kobo.16.1">This graph shows the number of wearables worldwide from 2016–2021 (data source: Statista). </span><span class="koboSpan" id="kobo.16.2">With so many devices connected online, continuously generating data, AI/ML tools are a natural choice to analyze this data and make informed decisions. </span><span class="koboSpan" id="kobo.16.3">In this section, you will learn about some successful personal IoT applications.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">SuperShoes by MIT</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Holding your mobile in one hand and navigating your way along the road with the help of </span><em><span class="koboSpan" id="kobo.3.1">Google Maps</span></em><span class="koboSpan" id="kobo.4.1">, how often have you thought that it is cumbersome? </span><span class="koboSpan" id="kobo.4.2">How often have you wished for magic slippers that will take you anywhere you want? </span><span class="koboSpan" id="kobo.4.3">SuperShoes by </span><em><span class="koboSpan" id="kobo.5.1">MIT Media Lab</span></em><span class="koboSpan" id="kobo.6.1"> (</span><a href="https://www.media.mit.edu/projects/supershoes/overview/"><span class="koboSpan" id="kobo.7.1">https://www.media.mit.edu/projects/supershoes/overview/</span></a><span class="koboSpan" id="kobo.8.1">) are almost like those magic slippers; they allow the user to navigate through the sidewalks without any need to check the smartphone screen.</span></p>
<p><span class="koboSpan" id="kobo.9.1">SuperShoes have flexible insoles, embedded with vibrating motors under the toes. </span><span class="koboSpan" id="kobo.9.2">They connect wirelessly to an app on the smartphone. </span><span class="koboSpan" id="kobo.9.3">The app not only allows the user to interface with the SuperShoes, but it also stores likes/dislikes, hobbies, shops, foods, people, interests, and so on in a cloud account. </span><span class="koboSpan" id="kobo.9.4">The vibrating motors generate tickles that communicate with the user. </span><span class="koboSpan" id="kobo.9.5">Once the user enters a destination on the app, the shoes start their work. </span><span class="koboSpan" id="kobo.9.6">If the left toe tickles then the user is supposed to take a left turn; if the right toe tickles then the user has to take a right turn. </span><span class="koboSpan" id="kobo.9.7">When there is no tickle, then the user has to continue straight. </span><span class="koboSpan" id="kobo.9.8">If both tickle repeatedly, the user has arrived at their destination.</span></p>
<p><span class="koboSpan" id="kobo.10.1">Besides navigation, it can also recommend places of interest nearby; the user updates their likes and dislikes on the cloud. </span><span class="koboSpan" id="kobo.10.2">Based on the likes and dislikes of the user, SuperShoe also gives an indication (both toes tickle once) when the user is near a recommended place of interest. </span><span class="koboSpan" id="kobo.10.3">Another interesting feature of SuperShoes is that it can give reminders as well; it can remind you if you have a task on a location nearby.</span></p>
<p><span class="koboSpan" id="kobo.11.1">The hardware required to make this shoe is very simple, it requires the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.12.1">Three vibrotactile ticklers to tickle the toes</span></li>
<li><span class="koboSpan" id="kobo.13.1">A capacitive pad to sense the walk</span></li>
<li><span class="koboSpan" id="kobo.14.1">A microcontroller that takes the commands from the app, and accordingly, controls the ticklers</span></li>
<li><span class="koboSpan" id="kobo.15.1">A Bluetooth device to connect with the smartphone</span></li>
<li><span class="koboSpan" id="kobo.16.1">Batteries to power the entire system</span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">The magic is performed by the software coded into the app. </span><span class="koboSpan" id="kobo.17.2">You can learn more about the SuperShoes at this website: </span><a href="http://dhairyadand.com/works/supershoes"><span class="koboSpan" id="kobo.18.1">http://dhairyadand.com/works/supershoes</span></a><span class="koboSpan" id="kobo.19.1">.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Continuous glucose monitoring</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A major application of AI has been in IoT for healthcare, with one of the most successful commercial applications being continuous monitoring of the body's glucose level. </span><span class="koboSpan" id="kobo.2.2">Abbott's FreeStyle CGM, DexCom CGM, and Medtronic CGM are some of the commercially available brands.</span></p>
<p><strong><span class="koboSpan" id="kobo.3.1">Continuous glucose monitoring</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">CGM</span></strong><span class="koboSpan" id="kobo.6.1">) allows people suffering from diabetes to check their body's glucose level in real time. </span><span class="koboSpan" id="kobo.6.2">It helps them in monitoring the readings over a period of time, and the data can also be used to prediction of future glucose level, thus helping them to deal with conditions like hypoglycemia.</span></p>
<p><span class="koboSpan" id="kobo.7.1">In CGM, normally a sensor is placed either under the skin of the belly or adhered to the back of your arm. </span><span class="koboSpan" id="kobo.7.2">The sensor sends the readings to a connected pager/smartphone app. </span><span class="koboSpan" id="kobo.7.3">The app has additional AI-based algorithms that can inform the user of any clinically relevant glucose patterns. </span><span class="koboSpan" id="kobo.7.4">The availability of this data not only helps the user to proactively manage their glucose highs and lows, but additionally, it can also provide an insight into the impact that meals, exercise, or illness may have on a person's glucose levels.</span></p>
<p><span class="koboSpan" id="kobo.8.1">The sensors have a lifespan ranging from 7 to 14 days, normally this time is sufficient for a medical practitioner to understand the person's lifestyle, and accordingly, suggest changes.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Hypoglycemia prediction using CGM data</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Once a person has CGM data, it can be analyzed using AI/ML to gather more information or to make a prediction about hypoglycemia. </span><span class="koboSpan" id="kobo.2.2">In this section, we see how we can use the algorithms we had learned in the previous chapters to make a glucose-predictor system.</span></p>
<p><span class="koboSpan" id="kobo.3.1">We will build our predictor based on the research paper </span><span><em><span class="koboSpan" id="kobo.4.1">Glucose Concentration can be Predicted Ahead in Time From Continuous Glucose Monitoring sensor Time-Series</span></em><span class="koboSpan" id="kobo.5.1"> by Sparacino et al. </span><span class="koboSpan" id="kobo.5.2">(</span><a href="https://doi.org/10.1109/TBME.2006.889774" target="_blank"><span class="koboSpan" id="kobo.6.1">10.1109/TBME.2006.889774</span></a><span class="koboSpan" id="kobo.7.1">).</span></span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.8.1">In the paper, the CGM time series glucose data is described by a times series model; the paper considered two models, one a simple first order polynomial and second a first order </span><span><span class="koboSpan" id="kobo.9.1">autoregressive</span></span><span class="koboSpan" id="kobo.10.1"> model. </span><span class="koboSpan" id="kobo.10.2">The model parameters are fitted at each sampling time, </span><em><span class="koboSpan" id="kobo.11.1">t</span><sub><span class="koboSpan" id="kobo.12.1">s</span></sub></em><span class="koboSpan" id="kobo.13.1">, against the past glucose data. </span><span class="koboSpan" id="kobo.13.2">Here, we will implement the simple first order polynomial using scikit linear regressor that we learned about in </span><a href="09538353-bf5b-4035-8b98-cc131bcfcf24.xhtml"><span class="koboSpan" id="kobo.14.1">Chapter 3</span></a><span class="koboSpan" id="kobo.15.1">, </span><em><span class="koboSpan" id="kobo.16.1">Machine Learning for IoT</span></em><span class="koboSpan" id="kobo.17.1">:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.18.1">We import the modules pandas to read the </span><kbd><span class="koboSpan" id="kobo.19.1">csv</span></kbd><span class="koboSpan" id="kobo.20.1"> file, NumpPy for data processing, Matplolib for plotting, and scikit-learn for the linear regressor, as follows:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.21.1">import pandas as pd</span><br/><span class="koboSpan" id="kobo.22.1">import numpy as np</span><br/><span class="koboSpan" id="kobo.23.1">import matplotlib.pyplot as plt</span><br/><span class="koboSpan" id="kobo.24.1">from sklearn.linear_model import LinearRegression</span><br/><span class="koboSpan" id="kobo.25.1">%matplotlib inline</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.26.1">Save the data obtained from your CGM in the data folder and read it. </span><span class="koboSpan" id="kobo.26.2">We require two values, the glucose reading and its time. </span><span class="koboSpan" id="kobo.26.3">The data that we are using has these available in two CSV files, </span><kbd><span class="koboSpan" id="kobo.27.1">ys.csv</span></kbd><span class="koboSpan" id="kobo.28.1"> and </span><kbd><span class="koboSpan" id="kobo.29.1">ts.csv</span></kbd><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">The first one contains the glucose value and the second one contains the corresponding time, as follows:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.31.1"># Read the data</span><br/><span class="koboSpan" id="kobo.32.1">ys = pd.read_csv('data/ys.csv')</span><br/><span class="koboSpan" id="kobo.33.1">ts = pd.read_csv('data/ts.csv')</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.34.1">According to the paper, we define two parameters of the predictive model </span><kbd><span class="koboSpan" id="kobo.35.1">ph</span></kbd><span class="koboSpan" id="kobo.36.1">, the prediction </span><kbd><span class="koboSpan" id="kobo.37.1">horizon</span></kbd><span class="koboSpan" id="kobo.38.1">, and </span><kbd><span class="koboSpan" id="kobo.39.1">mu</span></kbd><span class="koboSpan" id="kobo.40.1"> the forgetting factor. </span><span class="koboSpan" id="kobo.40.2">Please refer to the we mentioned earlier paper for more details on these two parameters:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.41.1"># MODEL FIT AND PREDICTION</span><br/><br/><span class="koboSpan" id="kobo.42.1"># Parameters of the predictive model. </span><span class="koboSpan" id="kobo.42.2">ph is Prediction horizon, mu is Forgetting factor.</span><br/><span class="koboSpan" id="kobo.43.1">ph = 10 </span><br/><span class="koboSpan" id="kobo.44.1">mu = 0.98</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.45.1">We create the arrays to hold our predicted values, shown as follows:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.46.1">n_s = len(ys)</span><br/><br/><span class="koboSpan" id="kobo.47.1"># Arrays to hold predicted values</span><br/><span class="koboSpan" id="kobo.48.1">tp_pred = np.zeros(n_s-1) </span><br/><span class="koboSpan" id="kobo.49.1">yp_pred = np.zeros(n_s-1)</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="5">
<li><span class="koboSpan" id="kobo.50.1">We now read the CGM data simulating the real-time acquisition and predict the glucose level </span><kbd><span class="koboSpan" id="kobo.51.1">ph</span></kbd><span class="koboSpan" id="kobo.52.1"> minutes forward. </span><span class="koboSpan" id="kobo.52.2">All the past data is used to determine the model parameters, however, each has a different contribution decided by the individual weight assigned to it </span><kbd><span class="koboSpan" id="kobo.53.1">mu</span><sup><span class="koboSpan" id="kobo.54.1">k</span></sup></kbd><span class="koboSpan" id="kobo.55.1"> (to the sample taken </span><kbd><span class="koboSpan" id="kobo.56.1">k</span></kbd><span class="koboSpan" id="kobo.57.1"> instants before the actual sampling time):</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.58.1"># At every iteration of the for loop a new sample from CGM is acquired.</span><br/><span class="koboSpan" id="kobo.59.1">for i in range(2, n_s+1):</span><br/><span class="koboSpan" id="kobo.60.1">    ts_tmp = ts[0:i]</span><br/><span class="koboSpan" id="kobo.61.1">    ys_tmp = ys[0:i]</span><br/><span class="koboSpan" id="kobo.62.1">    ns = len(ys_tmp)</span><br/> <br/><span class="koboSpan" id="kobo.63.1">    # The mu**k assigns the weight to the previous samples.</span><br/><span class="koboSpan" id="kobo.64.1">    weights = np.ones(ns)*mu</span><br/><span class="koboSpan" id="kobo.65.1">    for k in range(ns):</span><br/><span class="koboSpan" id="kobo.66.1">        weights[k] = weights[k]**k</span><br/><span class="koboSpan" id="kobo.67.1">    weights = np.flip(weights, 0)</span><br/><span class="koboSpan" id="kobo.68.1">    # MODEL</span><br/><span class="koboSpan" id="kobo.69.1">    # Linear Regression.</span><br/><span class="koboSpan" id="kobo.70.1">    lm_tmp = LinearRegression() </span><br/><span class="koboSpan" id="kobo.71.1">    model_tmp = lm_tmp.fit(ts_tmp, ys_tmp, sample_weight=weights)</span><br/>    <br/><span class="koboSpan" id="kobo.72.1">    # Coefficients of the linear model, y = mx + q </span><br/><span class="koboSpan" id="kobo.73.1">    m_tmp = model_tmp.coef_</span><br/><span class="koboSpan" id="kobo.74.1">    q_tmp = model</span><em><span class="koboSpan" id="kobo.75.1">tmp.intercept</span><br/><br/></em><span class="koboSpan" id="kobo.76.1">    # PREDICTION</span><br/><span class="koboSpan" id="kobo.77.1">    tp = ts.iloc[ns-1,0] + ph</span><br/><span class="koboSpan" id="kobo.78.1">    yp = m_tmp*tp + q_tmp</span><br/> <br/><span class="koboSpan" id="kobo.79.1">    tp_pred[i-2] = tp </span><br/><span class="koboSpan" id="kobo.80.1">    yp_pred[i-2] = yp</span></pre>
<ol start="6">
<li><span class="koboSpan" id="kobo.81.1">We can see that the prediction is lagging behind the actual. </span><span class="koboSpan" id="kobo.81.2">The normal glucose level lies in the range </span><kbd><span class="koboSpan" id="kobo.82.1">70</span></kbd><span class="koboSpan" id="kobo.83.1"> to </span><kbd><span class="koboSpan" id="kobo.84.1">180</span></kbd><span class="koboSpan" id="kobo.85.1">. Below </span><kbd><span class="koboSpan" id="kobo.86.1">70</span></kbd><span class="koboSpan" id="kobo.87.1">, the patient can suffer from hypoglycemia and above </span><kbd><span class="koboSpan" id="kobo.88.1">180</span></kbd><span class="koboSpan" id="kobo.89.1"> it can lead to hyperglycemia. </span><span class="koboSpan" id="kobo.89.2">Let us see the plot of our predicted data:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.90.1"># PLOT</span><br/><span class="koboSpan" id="kobo.91.1"># Hypoglycemia threshold vector. </span><br/><span class="koboSpan" id="kobo.92.1">t_tot = [l for l in range(int(ts.min()), int(tp_pred.max())+1)]</span><br/><span class="koboSpan" id="kobo.93.1">hypoglycemiaTH = 70*np.ones(len(t_tot)) </span><br/><span class="koboSpan" id="kobo.94.1">#hyperglycemiaTH = 180*np.ones(len(t_tot))</span><br/> <br/><span class="koboSpan" id="kobo.95.1">fig, ax = plt.subplots(figsize=(10,10))</span><br/><span class="koboSpan" id="kobo.96.1">fig.suptitle('Glucose Level Prediction', fontsize=22, fontweight='bold')</span><br/><span class="koboSpan" id="kobo.97.1">ax.set_title('mu = %g, ph=%g ' %(mu, ph))</span><br/><span class="koboSpan" id="kobo.98.1">ax.plot(tp_pred, yp_pred, label='Predicted Value') </span><br/><span class="koboSpan" id="kobo.99.1">ax.plot(ts.iloc[:,0], ys.iloc[:,0], label='CGM data') </span><br/><span class="koboSpan" id="kobo.100.1">ax.plot(t_tot, hypoglycemiaTH, label='Hypoglycemia threshold')</span><br/><span class="koboSpan" id="kobo.101.1">#ax.plot(t_tot, hyperglycemiaTH, label='Hyperglycemia threshold')</span><br/><span class="koboSpan" id="kobo.102.1">ax.set_xlabel('time (min)')</span><br/><span class="koboSpan" id="kobo.103.1">ax.set_ylabel('glucose (mg/dl)')</span><br/><span class="koboSpan" id="kobo.104.1">ax.legend()</span></pre>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.105.1"><img class="aligncenter size-full wp-image-1109 image-border" src="assets/df2045fe-1257-4d6e-84e0-713cd388dea0.png" style="width:40.08em;height:42.92em;"/></span></p>
<ol start="7">
<li><span class="koboSpan" id="kobo.106.1">The RMSE error will be 27 for the following code:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.107.1">from sklearn.metrics import mean_squared_error as mse</span><br/><span class="koboSpan" id="kobo.108.1">print("RMSE is", mse(ys[1:],yp_pred))</span></pre>
<p><span class="koboSpan" id="kobo.109.1">The code is located at </span><kbd><span class="koboSpan" id="kobo.110.1">Chapter09/Hypoglycemia_Prediction.ipynb</span></kbd><span class="koboSpan" id="kobo.111.1"> notebook. </span><span class="koboSpan" id="kobo.111.2">The glucose-prediction system is available in many commercial products. </span><span class="koboSpan" id="kobo.111.3">You can make one too, based on the model that we just made. </span><span class="koboSpan" id="kobo.111.4">You can also use an artificial neural network to make a similar prediction with better results (refer to  </span><a href="https://www.ncbi.nlm.nih.gov/pubmed/20082589"><span class="koboSpan" id="kobo.112.1">https://www.ncbi.nlm.nih.gov/pubmed/20082589</span></a><span class="koboSpan" id="kobo.113.1">).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Heart monitor</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Another very useful personal application of AI in IoT is in the detection of heart disease. </span><span class="koboSpan" id="kobo.2.2">A large number of wearables exist that can be used to monitor and record heart rate. </span><span class="koboSpan" id="kobo.2.3">The data can be used to predict any harmful heart condition. </span><span class="koboSpan" id="kobo.2.4">Here, we will employ AI/ML tools to predict cardiac </span><strong><span class="koboSpan" id="kobo.3.1">arrhythmia</span></strong><span class="koboSpan" id="kobo.4.1">, a group of conditions where the heart rate is irregular; it can be either too fast (above 100 beats per minute) or too slow (below 60 beats per minute). </span><span class="koboSpan" id="kobo.4.2">The data used is taken from the </span><em><span class="koboSpan" id="kobo.5.1">UCI Machine learning R</span></em><span><em><span class="koboSpan" id="kobo.6.1">epository</span></em></span><span class="koboSpan" id="kobo.7.1"> dataset: </span><a href="https://archive.ics.uci.edu/ml/datasets/heart+Disease"><span class="koboSpan" id="kobo.8.1">https://archive.ics.uci.edu/ml/datasets/heart+Disease</span></a><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">The dataset consists of 76 attributes, not all required for prediction of the presence of disease; the dataset has a goal field associated with each data row. </span><span class="koboSpan" id="kobo.9.3">It has five possible values 0–4, the value 0 indicates a healthy heart, any other value means there is a disease. </span><span class="koboSpan" id="kobo.9.4">The problem can be broken into a binary classification problems for better accuracy. </span><span class="koboSpan" id="kobo.9.5">The code is inspired from the GitHub link of Mohammed Rashad, it is shared under the GNU GPL 3.0 license: </span><a href="https://github.com/MohammedRashad/Deep-Learning-and-Wearable-IoT-to-Monitor-and-Predict-Cardiac-Arrhytmia"><span class="koboSpan" id="kobo.10.1">https://github.com/MohammedRashad/Deep-Learning-and-Wearable-IoT-to-Monitor-and-Predict-Cardiac-Arrhytmia</span></a><span class="koboSpan" id="kobo.11.1">. </span><span class="koboSpan" id="kobo.11.2">The complete code can be accessed from GitHub repository under </span><kbd><span class="koboSpan" id="kobo.12.1">Chapter09/Heart_Disease_Prediction.ipynb</span></kbd><span class="koboSpan" id="kobo.13.1"> file:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.14.1">The first step as always is to import the necessary modules. </span><span class="koboSpan" id="kobo.14.2">Since we are now classifying the patients as suffering from heart disease or not, we will need a classifier. </span><span class="koboSpan" id="kobo.14.3">Here for simplicity, we use the </span><kbd><span class="koboSpan" id="kobo.15.1">SVC</span></kbd><span class="koboSpan" id="kobo.16.1"> classifier. </span><span class="koboSpan" id="kobo.16.2">You can experiment with the MLP classifier, shown as follows:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.17.1"># importing required libraries</span><br/><span class="koboSpan" id="kobo.18.1">import numpy as np</span><br/><span class="koboSpan" id="kobo.19.1">import pandas as pd</span><br/><span class="koboSpan" id="kobo.20.1">import matplotlib.pyplot as plt</span><br/><br/><span class="koboSpan" id="kobo.21.1">from sklearn.svm import SVC</span><br/><span class="koboSpan" id="kobo.22.1">from sklearn import metrics</span><br/><span class="koboSpan" id="kobo.23.1">from sklearn.metrics import confusion_matrix</span><br/><span class="koboSpan" id="kobo.24.1">from sklearn.model_selection import train_test_split</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.25.1">Next, read the dataset, preprocess the dataset to select the attributes you will be considering. </span><span class="koboSpan" id="kobo.25.2">We chose 13 attributes from 76, and then we convert the target from a multi-class value to binary class. </span><span class="koboSpan" id="kobo.25.3">Finally, the data is split into the train and test dataset, as follows:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.26.1"># reading csv file and extracting class column to y.</span><br/><span class="koboSpan" id="kobo.27.1">dataset = pd.read_csv("data.csv")</span><br/><span class="koboSpan" id="kobo.28.1">dataset.fillna(dataset.mean(), inplace=True)</span><br/><br/><span class="koboSpan" id="kobo.29.1">dataset_to_array = np.array(dataset)</span><br/><span class="koboSpan" id="kobo.30.1">label = dataset_to_array[:,57] # "Target" classes having 0 and 1</span><br/><span class="koboSpan" id="kobo.31.1">label = label.astype('int')</span><br/><span class="koboSpan" id="kobo.32.1">label[label&gt;0] = 1 # When it is 0 heart is healthy, 1 otherwise</span><br/><br/><span class="koboSpan" id="kobo.33.1"># extracting 13 features</span><br/><span class="koboSpan" id="kobo.34.1">dataset = np.column_stack((</span><br/><span class="koboSpan" id="kobo.35.1">    dataset_to_array[:,4] , # pain location</span><br/><span class="koboSpan" id="kobo.36.1">    dataset_to_array[:,6] , # relieved after rest</span><br/><span class="koboSpan" id="kobo.37.1">    dataset_to_array[:,9] , # pain type </span><br/><span class="koboSpan" id="kobo.38.1">    dataset_to_array[:,11], # resting blood pressure</span><br/><span class="koboSpan" id="kobo.39.1">    dataset_to_array[:,33], # maximum heart rate achieve</span><br/><span class="koboSpan" id="kobo.40.1">    dataset_to_array[:,34], # resting heart rate </span><br/><span class="koboSpan" id="kobo.41.1">    dataset_to_array[:,35], # peak exercise blood pressure (first of 2 parts) </span><br/><span class="koboSpan" id="kobo.42.1">    dataset_to_array[:,36], # peak exercise blood pressure (second of 2 parts) </span><br/><span class="koboSpan" id="kobo.43.1">    dataset_to_array[:,38], # resting blood pressure </span><br/><span class="koboSpan" id="kobo.44.1">    dataset_to_array[:,39], # exercise induced angina (1 = yes; 0 = no) </span><br/><span class="koboSpan" id="kobo.45.1">    dataset.age, # age </span><br/><span class="koboSpan" id="kobo.46.1">    dataset.sex , # sex</span><br/><span class="koboSpan" id="kobo.47.1">    dataset.hypertension # hyper tension</span><br/><span class="koboSpan" id="kobo.48.1"> ))</span><br/><br/><span class="koboSpan" id="kobo.49.1">print ("The Dataset dimensions are : " , dataset.shape , "\n")</span><br/><br/><span class="koboSpan" id="kobo.50.1"># dividing data into train and test data</span><br/><span class="koboSpan" id="kobo.51.1">X_train, X_test, y_train, y_test = train_test_split(dataset, label, random_state = 223)</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.52.1">Now, we define the model to be used. </span><span class="koboSpan" id="kobo.52.2">Here we are using a support vector classifier, using the </span><kbd><span class="koboSpan" id="kobo.53.1">fit</span></kbd><span class="koboSpan" id="kobo.54.1"> function to train the dataset:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.55.1">model = SVC(kernel = 'linear').fit(X_train, y_train)</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.56.1">Let us see its performance on the test dataset:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.57.1">model_predictions = model.predict(X_test)</span><br/><span class="koboSpan" id="kobo.58.1"># model accuracy for X_test </span><br/><span class="koboSpan" id="kobo.59.1">accuracy = metrics.accuracy_score(y_test, model_predictions)</span><br/><span class="koboSpan" id="kobo.60.1">print ("Accuracy of the model is :" , </span><br/><span class="koboSpan" id="kobo.61.1">    accuracy , "\nApproximately : ", </span><br/><span class="koboSpan" id="kobo.62.1">    round(accuracy*100) , "%\n")</span></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.63.1">You can see that it provides an accuracy of 74%, using MLP, we can increase it further. </span><span class="koboSpan" id="kobo.63.2">But do remember to normalize all the input features before using the MLP classifier. </span><span class="koboSpan" id="kobo.63.3">Following is the confusion matrix of our trained support vector classifier on the test dataset:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.64.1">#creating a confusion matrix</span><br/><span class="koboSpan" id="kobo.65.1">cm = confusion_matrix(y_test, model_predictions)</span><br/><br/><span class="koboSpan" id="kobo.66.1">import pandas as pd</span><br/><span class="koboSpan" id="kobo.67.1">import seaborn as sn</span><br/><span class="koboSpan" id="kobo.68.1">import matplotlib.pyplot as plt</span><br/><span class="koboSpan" id="kobo.69.1">%matplotlib inline</span><br/><span class="koboSpan" id="kobo.70.1">df_cm = pd.DataFrame(cm, index = [i for i in "01"],</span><br/><span class="koboSpan" id="kobo.71.1">columns = [i for i in "01"])</span><br/><span class="koboSpan" id="kobo.72.1">plt.figure(figsize = (10,7))</span><br/><span class="koboSpan" id="kobo.73.1">sn.heatmap(df_cm, annot=True)</span></pre>
<p><span class="koboSpan" id="kobo.74.1">The following output shows the confusion matrix for the test dataset:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.75.1"><img src="assets/fe756965-f750-4f3a-a070-01330b4ac16d.png" style="width:39.25em;height:30.00em;"/></span></p>
<p><span class="koboSpan" id="kobo.76.1">You can train your model on the same dataset and use your trained model to predict heart conditions for your friends, family, or clients.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Digital assistants</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Digital assistants are one of the oldest conceived AI applications. </span><span class="koboSpan" id="kobo.2.2">Initial attempts at digital assistants never really took off. </span><span class="koboSpan" id="kobo.2.3">But with the advent and mass spread of smartphones, today we have a large number of digital assistants providing services such as dialing a phone number, writing a text message, scheduling appointments, or even searching the internet for you. </span><span class="koboSpan" id="kobo.2.4">You can ask them for recommendations for nearby restaurants and bars or any other similar thing.</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.3.1">Some of the following are popular digital assistants:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.4.1">Siri</span></strong><span class="koboSpan" id="kobo.5.1">: Developed by Apple, it allows the user to send/make calls, add appointments in the calendar, play music or video, and even send a text. </span><span class="koboSpan" id="kobo.5.2">Today, a voice-activated interface is available on almost all Apple products.</span></li>
<li><strong><span class="koboSpan" id="kobo.6.1">Cortana</span></strong><span class="koboSpan" id="kobo.7.1">: Created by Microsoft, it helps you to stay on schedule by reminding you to do things based on time, place, or even people. </span><span class="koboSpan" id="kobo.7.2">You can ask Cortana to order lunch for you or use any other app it partners with. </span><span class="koboSpan" id="kobo.7.3">It comes integrated with Edge  and invokes a voice-activated speaker featuring Cortana.</span></li>
<li><strong><span class="koboSpan" id="kobo.8.1">Alexa</span></strong><span class="koboSpan" id="kobo.9.1">: Developed by Amazon, this is available with Amazon Echo smart speakers. </span><span class="koboSpan" id="kobo.9.2">It can play music, make a to-do list, set alarms for you, play audio books, and provide real-time information on stocks, weather, and more. </span><span class="koboSpan" id="kobo.9.3">It is also capable of voice interaction.</span></li>
<li><strong><span class="koboSpan" id="kobo.10.1">Google Assistant</span></strong><span class="koboSpan" id="kobo.11.1">: This is a voice-controlled smart assistant. </span><span class="koboSpan" id="kobo.11.2">It provides continued conversation, that is you don't have to say </span><em><span class="koboSpan" id="kobo.12.1">Hey Google</span></em><span class="koboSpan" id="kobo.13.1"> for any follow-up requests, once you start talking, it listens for a response without needing the triggering phrase. </span><span class="koboSpan" id="kobo.13.2">It can also recognize the voice profiles for different people and can tailor its response according to the personal likes and dislikes of that person. </span><span class="koboSpan" id="kobo.13.3">It is available not only on Android smartphones but also on Google Home.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.14.1">In 2018, Google went even further, releasing Google Duplex, an assistant that can make calls for you and book your appointments. </span><span class="koboSpan" id="kobo.14.2">It talks like a human, and also understands the context when speaking.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">IoT and smart homes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A close friend of mine was always worried about his ageing mother, she was left home alone, while he, his wife, and kids were out. </span><span class="koboSpan" id="kobo.2.2">As her health started deteriorating, he asked for a piece of advice. </span><span class="koboSpan" id="kobo.2.3">The solution was simple; he installed CCTV cameras in all the rooms, interfaced with a mobile app. </span><span class="koboSpan" id="kobo.2.4">The cameras were connected to the internet, now, no matter where he is, he can check-in home to ensure the well-being of his mother.</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.3.1">CCTV, smart lightning, smart speakers, and so on connected to the internet help automate a lot of tasks at home, and what you get is a smart home. </span><span class="koboSpan" id="kobo.3.2">Most smart home systems at present work through a voice command interface, where you can use a set of commands to control the particular device. </span><span class="koboSpan" id="kobo.3.3">For example, in Amazon's Echo Dot, you can ask it to search or play a particular song. </span><span class="koboSpan" id="kobo.3.4">You can ask Apple's Siri to use your phone to call a friend, all by simple voice interface. </span><span class="koboSpan" id="kobo.3.5">Most of these devices are using AI/ML in some form, but home automation can be further advanced by employing AI/ML. </span><span class="koboSpan" id="kobo.3.6">For example, in the case of my friend, an AI system can be trained to identify activity from video, or to detect intrusion in the home. </span><span class="koboSpan" id="kobo.3.7">The possibilities are infinite. </span><span class="koboSpan" id="kobo.3.8">With the right data and sufficient computing power, you are limited only by your imagination.</span></p>
<p><span class="koboSpan" id="kobo.4.1">In this section, we will see some existing home automation products, and see how we can further use AI to augment the automation.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Human activity recognition</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">One of the most researched smart home application is </span><strong><span class="koboSpan" id="kobo.3.1">human activity recognition</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">HAR</span></strong><span class="koboSpan" id="kobo.6.1">). </span><span class="koboSpan" id="kobo.6.2">There are many companies trying to develop apps that keep track of physical activity and its corresponding calorie burn count. </span><span class="koboSpan" id="kobo.6.3">Health and fitness no doubt is big business. </span><span class="koboSpan" id="kobo.6.4">Besides its application in fitness and health, HAR can also be useful in elder care or rehabilitation centers. </span><span class="koboSpan" id="kobo.6.5">There have been many approaches to perform HAR, two of which as the follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Use cameras (or radar or similar devices) to record human activity and classify it using a DL approach</span></li>
<li><span class="koboSpan" id="kobo.8.1">The individuals use wearable sensors (similar to accelerometers in smartphones) whose data is recorded and used to predict the activity</span></li>
</ul>
<p><span class="koboSpan" id="kobo.9.1">Both approaches have their pros and cons. </span><span class="koboSpan" id="kobo.9.2">We will go through them in further detail in the following sections.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">HAR using wearable sensors</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A large number of vendors have wearable watches and bracelets with fitness trackers. </span><span class="koboSpan" id="kobo.2.2">These watches and bracelets have GPS, accelerometer, gyroscope, heart rate sensor, and/or ambient light sensors. </span><span class="koboSpan" id="kobo.2.3">Employing </span><strong><span class="koboSpan" id="kobo.3.1">sensor fusion</span></strong><span class="koboSpan" id="kobo.4.1">, they combine the output of these sensors to make a prediction about the activity. </span><span class="koboSpan" id="kobo.4.2">Due to the temporal nature of the data, it is a challenging time series classification task.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Fitbit (</span><a href="https://www.fitbit.com/smarttrack"><span class="koboSpan" id="kobo.6.1">https://www.fitbit.com/smarttrack</span></a><span class="koboSpan" id="kobo.7.1">), a premier company in the field of fitness trackers, use a technology it calls </span><strong><span class="koboSpan" id="kobo.8.1">SmartTrack</span></strong><span class="koboSpan" id="kobo.9.1">, which recognizes activities with continuous movement or light movement. </span><span class="koboSpan" id="kobo.9.2">It uses the intensity and patterns of the movement to classify the activity. </span><span class="koboSpan" id="kobo.9.3">It classifies the activity in seven classes, as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">Walking</span></li>
<li><span class="koboSpan" id="kobo.11.1">Running</span></li>
<li><span class="koboSpan" id="kobo.12.1">Aerobic workout</span></li>
<li><span class="koboSpan" id="kobo.13.1">Elliptical</span></li>
<li><span class="koboSpan" id="kobo.14.1">Outdoor bike</span></li>
<li><span class="koboSpan" id="kobo.15.1">Sports</span></li>
<li><span class="koboSpan" id="kobo.16.1">Swimming</span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">Apple Watch (</span><a href="https://www.apple.com/in/apple-watch-series-4/workout/"><span class="koboSpan" id="kobo.18.1">https://www.apple.com/in/apple-watch-series-4/workout/</span></a><span class="koboSpan" id="kobo.19.1">) offers tough competition to Fitbit. </span><span class="koboSpan" id="kobo.19.2">Working on an iOSoperating system, it comes with fall detection, along with many other health tracking features. </span><span class="koboSpan" id="kobo.19.3">By analyzing the wrist trajectory and impact acceleration, it detects if the person is falling and can also initiate an emergency call. </span><span class="koboSpan" id="kobo.19.4">The Apple watch, by default, classifies activities into three groups: walking, exercise, and standing. </span><span class="koboSpan" id="kobo.19.5">The exercise (workouts) are further classified in another domain, such as indoor run, outdoor run, skiing, snowboarding, yoga, and even hiking.</span></p>
<p><span class="koboSpan" id="kobo.20.1">If you want to try making a similar app using your smartphone sensors, the first thing you will need is data. </span><span class="koboSpan" id="kobo.20.2">Following, we present an implementation of HAR using random forest, the code has been adapted from the GitHub link of Nilesh Patil, Data Scientist at the University of Rochester: </span><a href="https://github.com/nilesh-patil/human-activity-recognition-smartphone-sensors"><span class="koboSpan" id="kobo.21.1">https://github.com/nilesh-patil/human-activity-recognition-smartphone-sensors</span></a><span class="koboSpan" id="kobo.22.1">.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<div class="packt_infobox"><span class="koboSpan" id="kobo.23.1">The dataset is from the paper </span><span><em><span class="koboSpan" id="kobo.24.1">Davide Anguita, Alessandro Ghio, Luca Oneto, Xavier Parra and Jorge L. </span><span class="koboSpan" id="kobo.24.2">Reyes-Ortiz. </span><span class="koboSpan" id="kobo.24.3">A Public Domain Dataset for Human Activity Recognition Using Smartphones. </span><span class="koboSpan" id="kobo.24.4">21th European Symposium on Artificial Neural Networks, Computational Intelligence and Machine Learning, ESANN 2013. </span><span class="koboSpan" id="kobo.24.5">Bruges, Belgium 24-26 April 2013.</span></em><br/></span><span class="koboSpan" id="kobo.25.1"> Available at the UCI ML website: </span><a href="https://archive.ics.uci.edu/ml/datasets/Human+Activity+Recognition+Using+Smartphones#"><span class="koboSpan" id="kobo.26.1">https://archive.ics.uci.edu/ml/datasets/Human+Activity+Recognition+Using+Smartphones#</span></a><span class="koboSpan" id="kobo.27.1">.</span><br/>
<p><span class="koboSpan" id="kobo.28.1">For each record in the dataset contains:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.29.1">Triaxial acceleration from the accelerometer (total acceleration) and the estimated body acceleration</span></li>
<li><span class="koboSpan" id="kobo.30.1">Triaxial angular velocity from the gyroscope</span></li>
<li><span class="koboSpan" id="kobo.31.1">A 561-feature vector with time and frequency domain variables</span></li>
<li><span class="koboSpan" id="kobo.32.1">Its activity label</span></li>
<li><span class="koboSpan" id="kobo.33.1">An identifier of the subject who carried out the experiment</span></li>
</ul>
</div>
<p class="mce-root"><span class="koboSpan" id="kobo.34.1">The data is classified into six categories:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.35.1">Laying</span></li>
<li><span class="koboSpan" id="kobo.36.1">Sitting</span></li>
<li><span class="koboSpan" id="kobo.37.1">Standing</span></li>
<li><span class="koboSpan" id="kobo.38.1">Walk</span></li>
<li><span class="koboSpan" id="kobo.39.1">Walk-down</span></li>
<li><span class="koboSpan" id="kobo.40.1">Walk-up</span></li>
</ul>
<ol>
<li><span class="koboSpan" id="kobo.41.1">Here, we use random forest classifier of the scikit-learn to classify the data. </span><span class="koboSpan" id="kobo.41.2">The necessary modules needed for the implementation are imported in the first step:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.42.1">import pandas as pd</span><br/><span class="koboSpan" id="kobo.43.1">import numpy as np</span><br/><span class="koboSpan" id="kobo.44.1">import seaborn as sns</span><br/><span class="koboSpan" id="kobo.45.1">import matplotlib.pyplot as plt</span><br/><br/><span class="koboSpan" id="kobo.46.1">from sklearn.ensemble import RandomForestClassifier as rfc</span><br/><span class="koboSpan" id="kobo.47.1">from sklearn.metrics import confusion_matrix</span><br/><span class="koboSpan" id="kobo.48.1">from sklearn.metrics import accuracy_score</span><br/><span class="koboSpan" id="kobo.49.1">%matplotlib inline</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.50.1">We read the data and divide it into </span><kbd><span class="koboSpan" id="kobo.51.1">train</span></kbd><span class="koboSpan" id="kobo.52.1"> and </span><kbd><span class="koboSpan" id="kobo.53.1">test</span></kbd><span class="koboSpan" id="kobo.54.1"> datasets, as follows:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.55.1">data = pd.read_csv('data/samsung_data.txt',sep='|')</span><br/><span class="koboSpan" id="kobo.56.1">train = data.sample(frac=0.7,</span><br/><span class="koboSpan" id="kobo.57.1">        random_state=42)</span><br/><span class="koboSpan" id="kobo.58.1">test = data[~data.index.isin(train.index)]</span><br/><br/><span class="koboSpan" id="kobo.59.1">X = train[train.columns[:-2]]</span><br/><span class="koboSpan" id="kobo.60.1">Y = train.activity</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.61.1">The data consists of 561 features however, not all are equally important. </span><span class="koboSpan" id="kobo.61.2">We can choose the more important features by making a simple random forest classifier, and choosing only the most important ones. </span><span class="koboSpan" id="kobo.61.3">In this implementation, it is done using two steps. </span><span class="koboSpan" id="kobo.61.4">Initially, we get the list of important features and arrange them in descending order of importance. </span><span class="koboSpan" id="kobo.61.5">Then the number and the features are found by grid hypertuning. </span><span class="koboSpan" id="kobo.61.6">The results of hypertuning are shown in the curve. </span><span class="koboSpan" id="kobo.61.7">We can see that after about 20 features, there is no significant improvement in </span><strong><span class="koboSpan" id="kobo.62.1">out of bag</span></strong><span class="koboSpan" id="kobo.63.1"> (</span><strong><span class="koboSpan" id="kobo.64.1">OOB</span></strong><span class="koboSpan" id="kobo.65.1">) accuracy using the following code:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.66.1">randomState = 42</span><br/><span class="koboSpan" id="kobo.67.1">ntree = 25</span><br/><br/><span class="koboSpan" id="kobo.68.1">model0 = rfc(n_estimators=ntree,</span><br/><span class="koboSpan" id="kobo.69.1">random_state=randomState,</span><br/><span class="koboSpan" id="kobo.70.1">n_jobs=4,</span><br/><span class="koboSpan" id="kobo.71.1">warm_start=True,</span><br/><span class="koboSpan" id="kobo.72.1">oob_score=True)</span><br/><span class="koboSpan" id="kobo.73.1">model0 = model0.fit(X, Y)</span><br/><br/><span class="koboSpan" id="kobo.74.1"># Arrange the features in ascending order</span><br/><span class="koboSpan" id="kobo.75.1">model_vars0 = pd.DataFrame(</span><br/><span class="koboSpan" id="kobo.76.1">    {'variable':X.columns,</span><br/><span class="koboSpan" id="kobo.77.1">    'importance':model0.feature_importances_})</span><br/><br/><span class="koboSpan" id="kobo.78.1">model_vars0.sort_values(by='importance',</span><br/><span class="koboSpan" id="kobo.79.1">    ascending=False,</span><br/><span class="koboSpan" id="kobo.80.1">    inplace=True)</span><br/><br/><span class="koboSpan" id="kobo.81.1"># Build a feature vector with most important 25 features</span><br/><br/><span class="koboSpan" id="kobo.82.1">n = 25</span><br/><span class="koboSpan" id="kobo.83.1">cols_model = [col for col in model_vars0.variable[:n].values]</span></pre>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.84.1"><img class="aligncenter size-full wp-image-1110 image-border" src="assets/192c852f-e7d6-4b50-a10e-07a0fbe2b223.png" style="width:37.92em;height:20.50em;"/></span></p>
<ol start="4">
<li><span class="koboSpan" id="kobo.85.1">We can also see the average importance of the top 25 features in the following diagram:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.86.1"><img class="aligncenter size-full wp-image-1111 image-border" src="assets/a50b2557-fe4d-4eec-a2b8-ae21cbf41606.png" style="width:45.92em;height:28.33em;"/></span></p>
<ol start="5">
<li><span class="koboSpan" id="kobo.87.1">In the same manner, we can hypertune the number of tree parameter. </span><span class="koboSpan" id="kobo.87.2">Here, we restricted ourselves to four important features:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.88.1">n_used = 4</span><br/><span class="koboSpan" id="kobo.89.1">cols_model = [col for col in model_vars0.variable[:n_used].values]\</span><br/><span class="koboSpan" id="kobo.90.1">     + [model_vars0.variable[6]]</span><br/><span class="koboSpan" id="kobo.91.1">X = train[cols_model]</span><br/><span class="koboSpan" id="kobo.92.1">Y = train.activity</span><br/><br/><span class="koboSpan" id="kobo.93.1">ntree_determination = {}</span><br/><span class="koboSpan" id="kobo.94.1">for ntree in range(5,150,5):</span><br/><span class="koboSpan" id="kobo.95.1">    model = rfc(n_estimators=ntree,</span><br/><span class="koboSpan" id="kobo.96.1">        random_state=randomState,</span><br/><span class="koboSpan" id="kobo.97.1">        n_jobs=4,</span><br/><span class="koboSpan" id="kobo.98.1">        warm_start=False,</span><br/><span class="koboSpan" id="kobo.99.1">        oob_score=True)</span><br/><span class="koboSpan" id="kobo.100.1">model = model.fit(X, Y)</span><br/><span class="koboSpan" id="kobo.101.1">ntree_determination[ntree]=model.oob_score_</span></pre>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.102.1"><img class="aligncenter size-full wp-image-1112 image-border" src="assets/8ca940bc-92b6-464e-953f-1f6c67d35399.png" style="width:28.67em;height:19.25em;"/></span></p>
<ol start="6">
<li><span class="koboSpan" id="kobo.103.1">Thus, we can see that a random forest with about four important features and </span><kbd><span class="koboSpan" id="kobo.104.1">50</span></kbd><span class="koboSpan" id="kobo.105.1"> trees can give a good OOB accuracy. </span><span class="koboSpan" id="kobo.105.2">Hence our final model is as follows:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.106.1">model2 = rfc(n_estimators=50,</span><br/><span class="koboSpan" id="kobo.107.1">    random_state=randomState,</span><br/><span class="koboSpan" id="kobo.108.1">    n_jobs=4,</span><br/><span class="koboSpan" id="kobo.109.1">    warm_start=False,</span><br/><span class="koboSpan" id="kobo.110.1">    oob_score=True)</span><br/><span class="koboSpan" id="kobo.111.1">model2 = model2.fit(X, Y)</span></pre>
<p class="mce-root"/>
<ol start="7">
<li><span class="koboSpan" id="kobo.112.1">This results in a test data accuracy of 94%. </span><span class="koboSpan" id="kobo.112.2">Following you can see the confusion matrix for the test dataset:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.113.1">test_actual = test.activity</span><br/><span class="koboSpan" id="kobo.114.1">test_pred = model2.predict(test[X.columns])</span><br/><span class="koboSpan" id="kobo.115.1">cm = confusion_matrix(test_actual,test_pred)</span><br/><span class="koboSpan" id="kobo.116.1">sns.heatmap(data=cm,</span><br/><span class="koboSpan" id="kobo.117.1">     fmt='.0f',</span><br/><span class="koboSpan" id="kobo.118.1">     annot=True,</span><br/><span class="koboSpan" id="kobo.119.1">     xticklabels=np.unique(test_actual),</span><br/><span class="koboSpan" id="kobo.120.1">     yticklabels=np.unique(test_actual))</span></pre>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.121.1"><img class="aligncenter size-full wp-image-1113 image-border" src="assets/5b71c386-b294-4b2f-8887-92cf66ef4cc7.png" style="width:32.67em;height:21.00em;"/></span></p>
<p><span class="koboSpan" id="kobo.122.1">The complete code, along with the data exploration, is available at the GitHub repository, </span><kbd><span class="koboSpan" id="kobo.123.1">Chapter09/Human_activity_recognition_using_accelerometer.ipynb</span></kbd><span class="koboSpan" id="kobo.124.1">. </span><span class="koboSpan" id="kobo.124.2">The advantage of using accelerometer data is that it is gathered from wearable devices, and hence, requires </span><span><span class="koboSpan" id="kobo.125.1">no</span></span><span class="koboSpan" id="kobo.126.1"> installation on the premises. </span><span class="koboSpan" id="kobo.126.2">Another advantage is that it is textual data, hence, requires fewer computation resources than video data.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">HAR from videos</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Another way to detect human activity is through videos. </span><span class="koboSpan" id="kobo.2.2">In this case, we will have to use a DL model such as CNN to get good results. </span><span class="koboSpan" id="kobo.2.3">A good dataset for classified videos is available from Ivan Laptev and Barbara Caputo (</span><a href="http://www.nada.kth.se/cvap/actions/"><span class="koboSpan" id="kobo.3.1">http://www.nada.kth.se/cvap/actions/</span></a><span class="koboSpan" id="kobo.4.1">). </span><span class="koboSpan" id="kobo.4.2">It contains six types of action: walking, jogging, running, boxing, hand waving, and hand clapping, in different scenarios. </span><span class="koboSpan" id="kobo.4.3">Each video has been recorded using a camera with 25 fps. </span><span class="koboSpan" id="kobo.4.4">The spatial resolution is 160 × 120, and of an average length of four seconds. </span><span class="koboSpan" id="kobo.4.5">It has in total 599 videos with about 100 for each of the six categories.</span></p>
<p><span class="koboSpan" id="kobo.5.1">One of the problems with video data is that it is computationally expensive, thus it will be important to reduce the dataset, and a few ways of doing this are as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.6.1">Since color has no role in the activity, the images can be converted from three- channel color images to two-dimensional grayscale images.</span></li>
<li><span class="koboSpan" id="kobo.7.1">The video is of four seconds at 25 frames in one second, most of these frames contain redundant data, so instead of (25 × 4 = 100) frames corresponding to one data row, we can reduce the number of frames to say 5 frames per second resulting in 20 frames. </span><span class="koboSpan" id="kobo.7.2">(It would be best if the total number of frames extracted per video is fixed).</span></li>
<li><span class="koboSpan" id="kobo.8.1">Reduce the spatial resolution of individual frames from 160 × 120.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.9.1">Next, when it comes to modeling, we should be using three-dimensional convolutional layers. </span><span class="koboSpan" id="kobo.9.2">So let us say if have taken only 20 frames per video, and reduced the size of each frame to 128 × 128, then a single sample will be: 20 × 128 × 128 × 1, this corresponds to the volume of 20 × 128 × 128 with a single channel.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Smart lighting</span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">The first home automation application that comes to mind when talking about smart homes is using smart light. </span><span class="koboSpan" id="kobo.2.2">Most of the smart lighting systems that exist at present offer an option to control the switching on and off of the lights, as well as their intensity, using an app on your smartphone or via the internet. </span><span class="koboSpan" id="kobo.2.3">Some also allow you to change the color/hue.</span></span> <span><span class="koboSpan" id="kobo.3.1">Motion detecting lights, which automatically switch on after detecting any motion, are part of almost all households today:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1"><img class="aligncenter size-full wp-image-1114 image-border" src="assets/45ffbdaf-d76a-455d-a42c-f3c4ca885eb8.png" style="width:40.25em;height:25.67em;"/></span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.5.1">Smart light for people with hearing impairments changes color based on the situation</span></div>
<p><span><span class="koboSpan" id="kobo.6.1">Using AI, we can make these smart lights even smarter. </span><span class="koboSpan" id="kobo.6.2">In case of emergency, they can be programmed to work in collaboration and guide you to the right exit. </span><span class="koboSpan" id="kobo.6.3">For people with hearing impairments, the smart lights can be used instead of alarms, for example, a red light when the fire alarm goes off, but an orange light when there's a burglar, and a welcoming green when someone rings the door bell. </span><span class="koboSpan" id="kobo.6.4">With the help of services such as </span><strong><span class="koboSpan" id="kobo.7.1">If This Then That</span></strong><span class="koboSpan" id="kobo.8.1"> (</span><strong><span class="koboSpan" id="kobo.9.1">IFTTT</span></strong><span class="koboSpan" id="kobo.10.1">) you can set up smarter and more complex support systems.</span></span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.11.1">The IFTTT provides a free service to control your devices. </span><span class="koboSpan" id="kobo.11.2">An action by one device (or service) can trigger one or more other devices. </span><span class="koboSpan" id="kobo.11.3">It is very simple to use, you just create an applet at the IFTTT website: </span><a href="https://ifttt.com"><span class="koboSpan" id="kobo.12.1">https://ifttt.com</span></a><span class="koboSpan" id="kobo.13.1">, you select the device (point and click) or service you want to use as a trigger, and link it with your IFTTT account. </span><span class="koboSpan" id="kobo.13.2">Next you select (point and click) the service or the device you want should act when the trigger is activated. </span><span class="koboSpan" id="kobo.13.3">The site contains thousands of pre-made applets to make your job even easier.</span></div>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.14.1"><img class="aligncenter size-full wp-image-1117 image-border" src="assets/84e7219c-8800-479b-af5b-65fa2780892d.png" style="width:37.67em;height:27.33em;"/></span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.15.1">Algorithm for a personalized smart light system</span></div>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.16.1">These are just some examples of what you can do with existing smart lights. </span><span class="koboSpan" id="kobo.16.2">But if you are adventurous and are ready to interface new sensors with these smart lights, you can build a personal light for yourself, one that changes its hue/intensity based on the mental activity of the person. </span><span class="koboSpan" id="kobo.16.3">It gets dim when you feel sleepy, and is full intensity when you are working, but when you are talking and spending time with friends, it simply provides a pleasant hue. </span><span class="koboSpan" id="kobo.16.4">Sounds far-fetched? </span><span class="koboSpan" id="kobo.16.5">Not really, you can first use an AI algorithm that detects human activity from video (or wearable fitness trackers) and classifies it into three classes: work, leisure, and sleep, and then use its output to control the smart light hue/intensity.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Home surveillance</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Home surveillance is a very useful and much-needed application. </span><span class="koboSpan" id="kobo.2.2">With single parents and the elderly population on the rise, the need for security and surveillance, not just on the outer premises, but inside homes, is also needed. </span><span class="koboSpan" id="kobo.2.3">Many companies are trying to provide in-home surveillance using videos. </span><span class="koboSpan" id="kobo.2.4">One of the successful implementations is by a company named DeepSight AILabs (</span><a href="http://deepsightlabs.com"><span class="koboSpan" id="kobo.3.1">http://deepsightlabs.com</span></a><span class="koboSpan" id="kobo.4.1">), they have developed proprietary software </span><strong><span class="koboSpan" id="kobo.5.1">SuperSecure</span></strong><span class="koboSpan" id="kobo.6.1">; a universally compatible retrofit solution that works with any CCTV system, any camera, any resolution, and turns it into an </span><strong><span class="koboSpan" id="kobo.7.1">AI-powered smart surveillance solution</span></strong><span class="koboSpan" id="kobo.8.1"> to detect potential threats with high accuracy, and trigger instant alerts to save lives and protect assets.</span></p>
<p><span class="koboSpan" id="kobo.9.1">When you try your own implementation of home surveillance, the points we discussed in the implementation of HAR using videos will be useful here as well.</span></p>
<p><span class="koboSpan" id="kobo.10.1">Smart homes are still in their infancy, the major reason being that they involve a high cost of ownership and the inflexibility of the interconnected devices. </span><span class="koboSpan" id="kobo.10.2">Normally, one particular system is managed completely by one company. </span><span class="koboSpan" id="kobo.10.3">If for some reason the company is closed, the consumer is left in the lurch. </span><span class="koboSpan" id="kobo.10.4">The solution would be to allow open source home automation hardware and software. </span><span class="koboSpan" id="kobo.10.5">An interesting read on the challenges and opportunities in the field of home automation is an article by Microsoft Research, </span><em><span class="koboSpan" id="kobo.11.1">Home Automation in the Wild: Challenges and Opportunities</span></em><span class="koboSpan" id="kobo.12.1"> (</span><a href="https://www.microsoft.com/en-us/research/publication/home-automation-in-the-wild-challenges-and-opportunities/"><span class="koboSpan" id="kobo.13.1">https://www.microsoft.com/en-us/research/publication/home-automation-in-the-wild-challenges-and-opportunities/</span></a><span class="koboSpan" id="kobo.14.1">).</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The focus of this chapter was personal and home AI-powered IoT solutions. </span><span class="koboSpan" id="kobo.2.2">The large-scale use of smartphones has brought wearable sensors to every person's reach, resulting in a plethora of personal apps. </span><span class="koboSpan" id="kobo.2.3">In this chapter, we explored and implemented some of the successful personal and home AI-powered IoT solutions. </span><span class="koboSpan" id="kobo.2.4">We learned about SuperShoes by MIT, shoes that can find their own path to the destination. </span><span class="koboSpan" id="kobo.2.5">We learned about CGM systems and implemented code to predict hyperglycemia. </span><span class="koboSpan" id="kobo.2.6">This chapter also demonstrated how personalized heart monitors can be implemented.</span></p>
<p><span class="koboSpan" id="kobo.3.1">While smart homes are still in their infancy, the chapter explored some of the most popular and useful smart home solutions. </span><span class="koboSpan" id="kobo.3.2">HAR, an application that exists at the boundary of smart homes and personal IoT, was introduced. </span><span class="koboSpan" id="kobo.3.3">We wrote some code using scikit-learn to classify the activity from data obtained using accelerometers. </span><span class="koboSpan" id="kobo.3.4">The chapter introduced some cool smart lighting applications and talked about home surveillance using videos.</span></p>
<p><span class="koboSpan" id="kobo.4.1">In the next chapter, we will look at some case studies where the data obtained from IoT sensors is used to improve production and efficiency in industries.</span></p>


            </article>

            
        </section>
    </body></html>