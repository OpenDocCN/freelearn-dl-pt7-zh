<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Understanding the Breadth-First Search Algorithm</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>The <strong>breadth-first search</strong> (<strong>BFS</strong>) algorithm is a traversing algorithm where you start at a selected node (the source or starting node) and traverse the graph layer-wise, exploring the neighboring nodes (nodes that are directly connected to the source node). You then move towards the neighboring nodes in the next level.</span></p>
<p>In this chapter, you will learn about BFS while developing LinkedIn's connection feature. You will learn how second-degree connections can be computed by using the BFS algorithm.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding the LinkedIn connection feature</li>
<li>Graph data structure</li>
<li>Queue data structure</li>
<li>The BFS algorithm</li>
<li>DFS versus BFS</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the LinkedIn connection feature</h1>
                </header>
            
            <article>
                
<p>As you know, LinkedIn is a social network, and users are connected to one another through first- or second-degree connections. In order to better understand this concept, use the following diagram as a reference:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-395 image-border" src="assets/a9d1c864-52d8-40ab-9b41-b62fa17a5c7d.png" style="width:50.75em;height:25.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1</div>
<p>Suppose that I want to find an acquaintance named <strong>Jill </strong>and connect with her. When I go to her profile, I find that she is a second-degree connection, which means that we have a mutual colleague. Let's look at how this degree is computed. To do so, we will create a connection tree:</p>
<ol>
<li>We start with the profile node, <strong>Dev</strong>, and add it to the connection tree:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-329 image-border" src="assets/05a0cb02-1efe-4b1c-a906-0561b07010d8.png" style="width:6.58em;height:4.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 2</span></div>
<ol start="2">
<li>Now, <span>I </span>will find my colleagues and add them beneath my node. So, I add <strong>Ali</strong> and <strong>Tom</strong> beneath the <strong>Dev</strong> node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-330 image-border" src="assets/7a569634-9366-42e6-aa28-95a997a6c16f.png" style="width:30.58em;height:8.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 3</span></div>
<ol start="3">
<li>Now, for both <strong>Ali</strong> and <strong>Tom</strong>, I find their colleagues and add them beneath their nodes. So, under <strong>Ali, </strong>I add <strong>Dev</strong>, <strong>Seth</strong>, and <strong>Ram</strong>, and under <strong>Tom,</strong> I add <strong>Dev</strong>, <strong>Seth</strong>, <strong>Kai</strong>, and <strong>Jill</strong>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-331 image-border" src="assets/624c3eaa-ebbc-46e9-8199-d7dc39417e90.png" style="width:54.33em;height:13.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 4</span></div>
<ol start="4">
<li>Now, for each of these nodes, we find their connections and add those as well:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-396 image-border" src="assets/a7bd3a9e-f2f4-4ece-a11d-74a8955c5625.png" style="width:51.42em;height:20.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 5</span></div>
<p>In the preceding diagram, the connections to <strong>Dev</strong> have been added (due to space constraints, this is not shown). For <strong>Seth</strong>, we find his connections (<strong>Ali</strong>, <strong>Tom</strong>, and <strong>Harry</strong>) and add them underneath his name. For <strong>Ram</strong>, we add <strong>Ali</strong> and <strong>Jill</strong>. Similarly, due to space constraints, we are not showing the connections for <strong>Dev</strong> and <strong>Seth</strong>, as they are already shown in the diagram. Under <strong>Kai</strong>, we add his connection, <strong>Tom</strong>. Finally, when we come to the node for <strong>Jill (</strong>to add her connections), we find that this node has the goal state, so we end our search.</p>
<p>You may have noticed that <strong>Jill</strong> appears as a connection to <strong>Ram</strong> at the bottom of the tree; but, if you consider the bottom node, then the connection degree is <strong>3</strong>, which is not the least value. However, because a BFS search processes the search tree level by level, we're able to find the least path solution. We can also see that there are people that appear multiple times in this connection tree. For example, <strong>Dev</strong>, <strong>Ali</strong>, and <strong>Tom</strong> appear three times each, while <strong>Seth</strong> and <strong>Jill</strong> each appear twice.</p>
<p>So, we'll keep the first entry of the node in the connection tree, and we will remove the other instances; the following diagram shows how the search tree should look:</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-397 image-border" src="assets/989bb140-e37c-4877-8bfb-7f9c2584edec.png" style="width:66.75em;height:28.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 6</span></div>
<p>When we add the node to the search tree, we should check whether it already exists in the search tree.</p>
<p>In <a href="50419d40-ab0f-4d63-9447-295dc802574c.xhtml">Chapter 1</a>, <em>Understanding the Depth-First Search Algorithm,</em> you learned that the <kbd>State</kbd> class indicates the condition of the search process. You also learned that the <kbd>State</kbd> class has to be changed for every application, even though the search algorithm is the same. Now, let's look at the changes that we need to make to the <kbd>State</kbd> class for this application.</p>
<p>First, we need a property to track the condition of the search. In this case, the property is the person under consideration. Then, we have the same four methods—<kbd>constructor()</kbd>, <kbd>getInitialState()</kbd>, <kbd>successorFunction()</kbd>, and <kbd>checkGoalState()</kbd>.</p>
<p>Let's look at each of these three ingredients in detail. To find the initial state, we should ask ourselves the question, <em>where do we start searching from?</em> In this application, we start searching from my profile. To find the successor function, we should ask ourselves, <em>how do we explore from the current state?</em> In this application, the function should return the people connected to the person under consideration. So, for <strong>Ali </strong>it should return all of his colleagues. Finally, to find the goal function, we should ask the question, <em>how will we know when we have found the solution?</em> The goal function should return true if the person is <kbd>Jill</kbd>. So, if the current person is Harry, the function should return false, and if the current person is <kbd>Jill</kbd>, it should return true.</p>
<p>Let's look at the <kbd>State</kbd> class code for this application, as follows:</p>
<pre>...<br/>from GraphData import *<br/>class State:<br/>    '''<br/>    This class retrieves state information for social connection    <br/>    feature<br/>    '''<br/>    <br/>    def __init__(self, name = None):<br/>        if name == None:<br/>            #create initial state<br/>            self.name = self.getInitialState()<br/>        else:<br/>            self.name = name<br/>    <br/>    def getInitialState(self):<br/>        """<br/>        This method returns me.<br/>        """<br/>        initialState = "Dev"<br/>        return initialState<br/>   def successorFunction(self):<br/>        """<br/>        This is the successor function. It finds all the persons     <br/>        connected to the current person<br/>        """<br/>        return connections[self.name]<br/>...</pre>
<p>As shown in the preceding code, in this module, <kbd>State.py</kbd>, we are importing all of the variables from <kbd>GraphData</kbd>. The purpose of <kbd>GraphData</kbd> will be explained in the <em>Graph data structure</em> section. In the constructor, the <kbd>name</kbd> argument is passed. If the argument <kbd>name</kbd> is <kbd>None</kbd>, then the initial state is created, and if the name is provided, that name is assigned to the name property. The <kbd>initialState</kbd> property holds the value <kbd>Dev</kbd>, and the <kbd>successorFunction</kbd> <span>method </span>returns all of the people connected to the current person. To get the people connected to the person, we use connections from GraphData:</p>
<pre>    def checkGoalState(self):<br/>        """<br/>        This method checks whether the person is Jill.<br/>        """ <br/>        #check if the person's name is Jill<br/>        return self.name == "Jill"</pre>
<p>The <kbd>checkGoalState</kbd> <span>function </span>returns if the current person's name is <kbd>Jill</kbd>.</p>
<p>Now, you should understand how the degree of connection is computed and how the <kbd>State</kbd> class has changed for this application.</p>
<p>In the next section, we'll look at how to represent social network data as a graph.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Graph data structure</h1>
                </header>
            
            <article>
                
<p>A <strong>graph</strong> is a non-linear data structure containing a set of points known as <strong>nodes</strong> (or vertices) and a set of links known as <strong>edges</strong>, as illustrated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-398 image-border" src="assets/f4a7c5fa-9513-4a4c-8d90-45f222707e44.png" style="width:31.92em;height:18.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 7</span></div>
<p>An edge that connects to the same node is called a <strong>cycle</strong>. As shown in the preceding diagram, nodes <strong>a</strong> and <strong>b</strong> are connected by two paths; one is through edge <strong>a-b</strong>, and the other is through edges <strong>a-d</strong> and <strong>d-b</strong>. A <strong>tree</strong> is a special type of graph, in which there are no cycles, and two nodes are connected by one path.</p>
<p>In Python, we can use a dictionary structure to represent a graph. A <strong>dictionary</strong> is a data structure where many keys are mapped to values. For a dictionary that represents a graph, the keys are the nodes, and the values of those nodes are the nodes that they are connected to:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-399 image-border" src="assets/1dbe59aa-ca3f-420c-83d2-aa88e455b6dd.png" style="width:34.08em;height:16.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 8</span></div>
<p>In the preceding diagram, we can see that the following applies:</p>
<ul>
<li><strong>For key a</strong>, the values are <strong>b</strong> and <strong>c</strong></li>
<li><strong>For key b</strong>, the values are <strong>c</strong> and <strong>a</strong></li>
<li><strong>For key c</strong>, the values are <strong>a</strong> and <strong>b</strong></li>
</ul>
<p>Now, let's create a dictionary to show the graph structure of the social network that we saw in the previous topic:</p>
<pre>...<br/>#create a dictionary with all the mappings<br/>connections = {}<br/>connections["Dev"] = {"Ali", "Seth", "Tom"}<br/>connections["Ali"] = {"Dev", "Seth", "Ram"}<br/>connections["Seth"] = {"Ali", "Tom", "Harry"}<br/>connections["Tom"] = {"Dev", "Seth", "Kai", 'Jill'}<br/>connections["Ram"] = {"Ali", "Jill"}<br/>connections["Kai"] = {"Tom"}<br/>connections["Mary"] = {"Jill"}<br/>connections["Harry"] = {"Seth"}<br/>connections["Jill"] = {"Ram", "Tom", "Mary"}<br/>...</pre>
<p>In the Python module <kbd>GraphData.py</kbd>, we have created a dictionary called <kbd>connections</kbd>. The keys are the people in the social network, and the corresponding values are the people that they are connected to. Now, the <kbd>connections</kbd> dictionary is used in <kbd>State.py</kbd>. It is used in the  <kbd>successorFunction</kbd> function, as shown in the following code:</p>
<pre>... <br/>def successorFunction(self):<br/>        """<br/>        This is the successor function. It finds all the persons   <br/>        connected to the current person<br/>        """<br/>        return connections[self.name]<br/>...</pre>
<p>Here, we can get the people that the person is connected to by using the <kbd>connections</kbd> dictionary, with the person's name as the key. We can get the people that are connected to that person by using the <kbd>connections</kbd> object.</p>
<p>Now, let's look at how to traverse this graph data structure, in order to create a search tree:</p>
<ol>
<li>We will start with my profile in the graph, and add the <strong>Dev</strong> <span>node </span>to the search tree and the visited nodes list.</li>
<li>From my node in the graph, we can find the connected people, <strong>Ali</strong> and <strong>Tom</strong>; we add these nodes to the search tree and the visited nodes list.</li>
<li>For <strong>Ali</strong> and <strong>Tom</strong>, we find who they're connected to by using the graph data structure, and we add these nodes to the search tree and the visited nodes list, if they have not been visited before. <strong>Ali</strong> is connected to <strong>Dev</strong>, <strong>Seth</strong>, and <strong>Ram</strong>. <strong>Dev</strong> has already been visited, so we ignore this node. <strong>Seth</strong> and <strong>Ram</strong> have not been visited before, so we add these nodes to the search tree and the visited nodes list. <strong>Tom</strong> is connected to <strong>Dev</strong>, <strong>Seth</strong>, <strong>Kai</strong>, and <strong>Jill</strong>. <strong>Dev</strong> and <strong>Seth</strong> have already been visited, so we ignore these nodes, and we add the nodes <strong>Kai</strong> and <strong>Jill</strong> to the list, because they have not been visited before.</li>
<li>We repeat the process of adding the children to the search tree and the visited nodes list (if they have not been visited before). <strong>Seth</strong> is connected to <strong>Ali</strong>, <strong>Tom</strong>, and <strong>Harry</strong>. <strong>Ali</strong> and <strong>Tom</strong> have already been visited, so we ignore them, and we add <strong>Harry</strong> to the search tree and the visited nodes list. <strong>Ram</strong> is connected to <strong>Ali</strong> and <strong>Jill</strong>, and both of them have been visited before. Moving forward, <strong>Kai</strong> is connected to <strong>Tom</strong>, and he's already been visited, as well. When we process the <strong>Jill</strong> node, we find that it has the goal state, and we end our search.</li>
</ol>
<p>You have now learned how to use a list of visited nodes to explore a graph as a tree, which will look like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-400 image-border" src="assets/e97fd7e7-f8ae-4bf3-98dc-53c3e001cfa7.png" style="width:45.08em;height:26.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 9</span></div>
<p>In the next section, you'll learn about the queue data structure, which forms the basis of node reversal, just like a stack in the DFS method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Queue data structure</h1>
                </header>
            
            <article>
                
<p>A <strong>queue</strong> is a sequence of people or objects waiting to be attended to. Some examples include a queue of people waiting at a counter, a queue of swimmers that are ready to dive in to a pool, and a queue of songs in a playlist:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-401 image-border" src="assets/6e7fa6ab-615b-44e4-92bf-e084c5e9204e.png" style="width:59.17em;height:34.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 10</span></div>
<p>Just like in a stack, there are two types of operations—one for inserting items into a queue, and one for removing items from a queue. When a person joins a queue, he or she must stand behind the last person. The operation of adding an item to a queue is called <strong>enqueue</strong>. The first person to be attended to in a queue is the person standing in the front. The operation to remove an item from a queue is called <strong>dequeue</strong>. Queue operations can be seen in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7681900b-ad36-463c-a701-fa4a225ed277.png" style="width:28.67em;height:18.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 11</span></div>
<p>Since the first object inserted is the first one to be removed, this data structure is called <strong>first in first out</strong> (<strong>FIFO</strong>). In Python, we can use the <kbd>deque</kbd> class to create <kbd>queue</kbd> objects. The <kbd>deque</kbd> class provides two methods—one method, <kbd>append</kbd>, for inserting items, and a method called <kbd>popleft</kbd> for removing items:</p>
<pre>...<br/>from collections import deque<br/><br/>queue = deque([])<br/>print queue<br/><br/>queue.append("1") <br/>queue.append("2") <br/>queue.append("3") <br/>queue.append("4") <br/><br/>print queue<br/>...</pre>
<p>In the preceding code, we have created an empty queue, to which we will add the items <kbd>1</kbd>, <kbd>2</kbd>, <kbd>3</kbd>, and <kbd>4</kbd>; later, we will delete these items from the queue one by one. Upon successful execution of the code, we will get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-339 image-border" src="assets/8484ed2f-aece-4384-8dd1-6da565c1e9e9.png" style="width:22.33em;height:14.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 12</span></div>
<p>As shown in the preceding screenshot, we initially have an empty queue, and, after adding items <kbd>1</kbd>, <kbd>2</kbd>, <kbd>3</kbd>, and <kbd>4</kbd>, you can see that the items are in the queue, with <kbd>1</kbd> at the front and <kbd>4</kbd> at the back. When we remove an item from the queue, the first one to be removed is <kbd>1</kbd>, because it is at the front, and then <kbd>2</kbd>, <kbd>3</kbd>, and <kbd>4</kbd> are removed. At the end, we have an empty queue.</p>
<p>Now that you understand how a queue works, we'll look at the steps in a BFS algorithm and how the graph and queue data structures are used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The BFS algorithm</h1>
                </header>
            
            <article>
                
<p>In this section, we'll look at the flow of the BFS algorithm, how a queue is used, and how graph data affects the algorithm. The flow of the BFS algorithm is similar to that of DFS, but instead of using a stack data structure, a queue data structure is used.</p>
<p>A flowchart of the BFS algorithm can be illustrated as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-340 image-border" src="assets/0b4087b1-79bb-4692-a691-d0131dbc9b2e.png" style="width:20.17em;height:23.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 13</span></div>
<ol>
<li>We initially create a root node with an initial state, and add it to a queue and tree.</li>
<li>A node is dequeued from the queue, and we check whether it has the goal state. If it does, we end our search. If it doesn't, we find the child nodes of the dequeued node and add them to the queue entry.</li>
<li>This process is repeated until we either find the goal state or have exhausted all of the nodes in our search tree.</li>
<li>Since our connection data is in a graph structure, we have to check whether each node has been visited before.</li>
<li>So, we add the root node to a list of visited nodes, and the child node is added to the queue, tree, and visited list (if the child node has not been visited previously).</li>
</ol>
<p>Let's look at these steps in detail by implementing them in our graph diagram, which we covered in the <em>Understanding the LinkedIn connection feature</em> section:</p>
<ol>
<li>We start by adding my profile node to the search tree, queue, and visited nodes list. We dequeue the <strong>Dev</strong> <span>node </span>from the queue.</li>
<li>Since the <strong>Ali</strong> <span>node </span>has not been visited, we add this node to the search tree, queue, and visited nodes list. Similarly, since <strong>Tom</strong> has not been visited, we add this node to the search tree, queue, and visited nodes list.</li>
<li>We dequeue the <strong>Ali </strong>node from the queue, and, since it doesn't have the goal state, we find its child nodes: <strong>Dev</strong>, <strong>Seth,</strong> and <strong>Ram</strong>. The <strong>Dev</strong> <span>node </span>has been visited, so we ignore that node. The <strong>Seth</strong> node has not been visited, so we add that node to the search tree, queue, and visited nodes list. Similarly, we add <strong>Ram</strong> to the search tree, queue, and visited nodes list.</li>
<li>We dequeue the <strong>Tom</strong> node from the queue, and we find its children nodes: <strong>Dev</strong>, <strong>Seth</strong>, <strong>Kai,</strong> and <strong>Jill</strong>. The <strong>Dev</strong> node has been visited, so we ignore that node, and the same goes for the <strong>Seth</strong> node. The <strong>Kai</strong> node has not been visited, so we add that node to the search tree, queue, and visited nodes list; the same goes for the <strong>Jill</strong> node. We dequeue the <strong>Seth</strong> <span>node </span>from the queue, and we find its child nodes: <strong>Ali</strong>, <strong>Tom</strong>, and <strong>Harry</strong>. The <strong>Ali</strong> and <strong>Tom</strong><span> nodes </span>have been visited, so we ignore these nodes. We add the node <strong>Harry</strong> to the search tree, queue, and visited nodes list.</li>
<li>We dequeue the <strong>Ram </strong>node from the queue, and we find its child nodes, <strong>Ali</strong> and <strong>Jill</strong>, which have both been visited; so, we carry on.</li>
<li>We dequeue the <strong>Kai </strong>node, and we find its child node, <strong>Tom</strong>, which has been visited; so, we carry on again.</li>
<li>We dequeue the <strong>Jill</strong> node from the queue, and we find that it has the goal state, so we end our search.</li>
</ol>
<p>Once we have completed the preceding steps, we will have the following tree:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-404 image-border" src="assets/888f7612-2134-4edf-95ea-36aea1f073c2.png" style="width:44.75em;height:28.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 14</span></div>
<p>Let's implement the preceding algorithm with the following code:</p>
<pre>...<br/>def performQueueBFS():<br/>    """<br/>    This function performs BFS search using a queue<br/>    """<br/>    #create queue<br/>    queue = deque([])<br/>    <br/>    #since it is a graph, we create visited list<br/>    visited = []<br/>    <br/>    #create root node<br/>    initialState = State()<br/>    root = Node(initialState)<br/>    #add to queue and visited list<br/>    queue.append(root) <br/>    visited.append(root.state.name)<br/>...</pre>
<p>In the Python module <kbd>QueueBFS.py</kbd>, we have created a method called <kbd>performQueueBFS</kbd>, in which we have an empty queue that will hold the nodes and a list of visited nodes. We create the root node with <kbd>initialState</kbd>, and we add this root node to the queue, along with a list of visited nodes. One by one, we dequeue elements from the queue; we call the dequeued node the <kbd>currentNode</kbd>:</p>
<pre>...   <br/>        while len(queue) &gt; 0:<br/>        <br/>        #get first item in queue<br/>        currentNode = queue.popleft()<br/>        <br/>        print "-- dequeue --", currentNode.state.name<br/>        <br/>        #check if this is goal state<br/>        if currentNode.state.checkGoalState():<br/>            print "reached goal state"<br/>            #print the path<br/>            print "----------------------"<br/>            print "Path"<br/>            currentNode.printPath()<br/>            break<br/>...</pre>
<p>We print the name of the current node and check whether it has the goal state. If it does, we print the path from the root node to the current node and break the loop. If it doesn't have the goal state, we find the child states of the current state, and for each higher state, we construct the child node and check whether that node has been visited.</p>
<p>The list of visited nodes now holds the names of the nodes. So, in the following code, we have added the name of the root node:</p>
<pre> visited.append(root.state.name)</pre>
<p>We have done the same in the following code:</p>
<pre>...<br/>#check if node is not visited<br/>            if childNode.state.name not in visited:<br/>                <br/>                #add this node to visited nodes<br/>                visited.append(childNode.state.name)<br/>                <br/>                #add to tree and queue<br/>                currentNode.addChild(childNode)<br/>                queue.append(childNode)<br/>                <br/>            <br/>    #print tree<br/>    print "----------------------"<br/>    print "Tree"<br/>    root.printTree()<br/>...</pre>
<p>In the preceding code, we check whether the name of the node has not been visited. Because we're checking for unique names, if the node has not been visited, we add the name of the child node to the list of visited nodes, and we add the child node to the search tree and the queue. Finally, we print the queue.</p>
<p>Let's run the code and see what happens:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-342 image-border" src="assets/f4b02ccc-942e-4e42-b23e-79c553aaf212.png" style="width:20.67em;height:28.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 15</span></div>
<p>In the preceding screenshot, we can see the order in which the nodes are processed. We start off with the <kbd>Dev</kbd> node, and then we process the connections, <kbd>Ali</kbd> and <kbd>Tom</kbd>, and then the connections of <kbd>Ali</kbd>, <kbd>Ram</kbd>, and <kbd>Seth</kbd>, and the connections of <kbd>Tom</kbd>, <kbd>Kai</kbd> and <kbd>Jill</kbd>. When we process the <kbd>Jill</kbd> <span>node</span>, we find that we have reached the goal state and we end our search.</p>
<p>In the preceding screenshot, we can see the path printed from the initial state to the goal state through the <kbd>Tom</kbd><span> node </span>. From this, we can see that <kbd>Jill</kbd> is a second-level connection. We can also see the search tree that has been constructed so far.</p>
<p>Now that you are aware of the steps involved in BFS, we'll compare the BFS and DFS algorithms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">BFS versus DFS</h1>
                </header>
            
            <article>
                
<p>In this section, we'll look at the differences between the DFS and BFS algorithms. We will compare these differences in terms of various factors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Order of traversal</h1>
                </header>
            
            <article>
                
<p>In DFS, preference is given to child nodes, which means that after node <strong>a</strong> and node <strong>b</strong> are explored, and after node <strong>b</strong> and node <strong>c</strong> are explored, we hit a dead end and we backtrack to the previous level. This means that we go back to node <strong>b,</strong> and then to its next child, which is node <strong>c</strong>.</p>
<p>In BFS, the nodes are covered level by level, and preference is given to siblings. This means that after node <strong>a</strong>, nodes <strong>b</strong> and <strong>e</strong> are explored, and after that, nodes <strong>c</strong>, <strong>d</strong>, and <strong>f</strong> are explored, as indicated by the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-405 image-border" src="assets/48b567e6-fc7c-457b-86a8-39a1bb338a01.png" style="width:73.17em;height:32.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 16</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data structures</h1>
                </header>
            
            <article>
                
<p>In DFS, a stack data structure is used, while in BFS, a queue is used, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-406 image-border" src="assets/92e48e65-c300-4948-bf75-3c159d62630e.png" style="width:32.00em;height:19.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 17</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Memory</h1>
                </header>
            
            <article>
                
<p>When recursive DFS is called on node <strong>c</strong>, the implicit stack stores two entries—one for node <strong>e</strong>, and one for nodes <strong>c</strong> and <strong>d</strong>. So, the memory used is in the order of <strong>d</strong>, where <strong>d</strong> is the depth of the search tree.</p>
<p>When the BFS method is called on node <strong>c</strong>, the queue contains four entries—nodes <strong>c</strong>, <strong>d</strong>, <strong>f</strong>, and <strong>g</strong>. So, the memory used is in the order of <em>b^d</em>, where <strong>b</strong> is the branching factor and <strong>d</strong> is the depth of the search tree. Here, the branching factor is <strong>2</strong>, because each internal node has two children:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-407 image-border" src="assets/fc83fa38-2bdb-4941-a803-d1b53100c105.png" style="width:71.58em;height:28.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 18</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optimal solution</h1>
                </header>
            
            <article>
                
<p>Suppose that there are two possible solutions—nodes <strong>d</strong> and <strong>e</strong>. In this case, <strong>e</strong> is the optimal solution, because it has the shortest path from root node <strong>a</strong>. Here, DFS finds the sub-optimal solution, <strong>d</strong>, before it finds the optimal solution, <strong>e</strong>. BFS finds the optimal solution, <strong>e,</strong> before it encounters node <strong>d</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-408 image-border" src="assets/c62bb3fa-1473-4c2f-a281-9dc4773ce14c.png" style="width:64.67em;height:28.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 19</span></div>
<p><span>We already saw that DFS uses less memory than BFS, and BFS finds the optimal solution. So, the choice of algorithm depends on how big the search space is (in this case, you will go for DFS), and whether finding the optimal solution is important (in this case, BFS is preferred).</span></p>
<p>Next, we will look at an application that you can try to develop yourself.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Do it yourself</h1>
                </header>
            
            <article>
                
<p>In the previous section, we discussed the differences between the DFS and BFS algorithms. In this section, we'll look at an application that you can try to develop yourself. We'll go over the application that you'll try to develop, and the changes that are required for the application.</p>
<p>Your aim will be to develop a university navigation application, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-409 image-border" src="assets/ff8166a6-adaa-4993-8633-24baefbd0683.png" style="width:29.08em;height:16.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 20</span></div>
<p>Suppose that this is the layout of the university, and people can travel along horizontal or vertical lines. In this application, the user has to enter the source and destination places. For this specific case, we'll assume that a new student wants to find his way from the <strong>Bus Stop</strong> to the <strong>AI Lab</strong>.</p>
<p>You can refer to the classes that we developed for the LinkedIn connection feature, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-411 image-border" src="assets/7c8c3593-77a2-44f7-ba14-16cef6cbfddb.png" style="width:32.83em;height:17.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 21</span></div>
<p>To adapt that code for this application, we need to change the <kbd>State</kbd> class and the graph data. In the <kbd>State</kbd> class, the <kbd>name</kbd> property is replaced with the <kbd>place</kbd> property, and <kbd>NavigationData</kbd> contains the connections between places:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-412 image-border" src="assets/e415b6cb-1a0c-41a9-bb3b-38742ec27c74.png" style="width:24.58em;height:15.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 22</span></div>
<p>Let's look at the three ingredients of the search in detail. To get the answer for the initial state, we can ask ourselves the question, <em>where do we start searching from?</em> In this case, it's the <strong>Bus Stop</strong>. So, <kbd>successorFunction</kbd> should return all of the connected places. For example, if the current place is <strong>Car Park</strong>, then this function should return the <strong>Library</strong>, the <strong>Store</strong>, and the <strong>Maths Building</strong>. To get the answer for the goal function, we should ask ourselves the question, <em>how will we know when we have found the solution?</em> For this application, the function should return true if the place is the <strong>AI Lab</strong>; for example, if the current place is the <strong>Canteen</strong>, then it should return false, and if the current place is the <strong>AI Lab</strong>, then it should return true.</p>
<p>Go ahead and try it out for yourself!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, to help you understand the BFS algorithm, we revisited the concepts of state and node. You learned about the graph and queue data structures, and we discussed the differences between the DFS and BFS algorithms.</p>
<p>In the next chapter, you'll be learning about the heuristic search algorithm. Instead of giving preference to child or sibling nodes, this method gives preference to the nodes that are closest to the goal state; the term <strong>heuristic</strong> refers to the measure of how close the nodes are to the goal state.</p>
<div class="packt_infobox"><span>Please refer to the link <a href="https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf">https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf</a> </span><span>for the colored images of this chapter.</span></div>


            </article>

            
        </section>
    </body></html>