<html><head></head><body>
		<div>
			<div id="_idContainer465" class="Content">
			</div>
		</div>
		<div id="_idContainer466" class="Content">
			<h1 id="_idParaDest-200"><a id="_idTextAnchor240"/>7. Temporal Difference Learning</h1>
		</div>
		<div id="_idContainer618" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we will be introduced to <strong class="bold">Temporal Difference</strong> (<strong class="bold">TD</strong>) learning and focus on how it develops the ideas of the Monte Carlo methods and dynamic programming. TD learning is one of the key topics in the field and studying it allows us to have a deep understanding of reinforcement learning and how it works at the most fundamental level. A new perspective will allow us to see MC methods as a particular case of TD ones, unifying the approach and extending their applicability to non-episodic problems. By the end of this chapter, you will be able to implement the <strong class="bold">TD(0)</strong>, <strong class="bold">SARSA</strong>, <strong class="bold">Q-learning</strong>, and <strong class="bold">TD(λ)</strong> algorithms and use them to solve environments with both stochastic and deterministic transition dynamics.</p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor241"/>Introduction to TD Learning </h1>
			<p>After having studied dynamic programming and Monte Carlo methods in the previous chapters, in this chapter, we will focus on temporal difference learning, one of the main stepping stones of reinforcement learning. We will start with their simplest formulation, that is, the one-step methods, and we will build on them to create their most advanced formulation, which is based on the eligibility traces concept. We will see how this new approach allows us to frame TD and MC methods under the same derivation idea, giving us the ability to compare the two. Throughout this chapter, we will implement many different flavors of TD methods and apply them to the FrozenLake-v0 environment under both the deterministic and the stochastic environment dynamics. Finally, we will solve the stochastic version of FrozenLake-v0 with an off-policy TD method known as Q-learning. </p>
			<p>Temporal difference learning, whose name derives from the fact that it uses differences in state (or state-actions pairs) values between subsequent timesteps to learn, can be considered a central idea in the field of reinforcement learning algorithms. It shares some important aspects with the methods we studied in previous chapters – in fact, just like those methods, it learns through experience, with no need to have a model (like Monte Carlo methods do), and it "bootstraps," meaning it learns how to use information it's acquired before reaching the end of the episode (like dynamic programming methods do).</p>
			<p>These differences are strictly related to the advantages that TD methods offer with respect to MC and DP ones: it doesn't need a model of the environment and it can be applied with a greater generality with respect to DP methods. Its ability to bootstrap, on the other hand, makes TD more suited for tasks with very long episodes and the only solution for non-episodic ones – to which Monte Carlo methods cannot be applied. As an example of a long-term or non-episodic task, think of an algorithm that is used to grant user access to a server that's rewarded every time the first user in the queue is assigned to a resource and receiving zero reward if user access is not granted. The queue typically never ends, so this is a continuing task that has no episodes.</p>
			<p>As seen in previous chapters, the exploration versus exploitation trade-off is a very important subject, and again also in the case of temporal difference algorithms. They fall into two main classes: on-policy and off-policy methods. As we saw in the previous chapters, in on-policy methods, the same policy that is learned is used to explore the environment, while in off-policy ones, the two can be different: one if used for exploration, while the other one is the target to be learned. In the following sections, we will address the general problem of estimating the state value function for a given policy. Then, we will see how, by building upon it, we can obtain a complete RL algorithm to train both on-policy and off-policy methods to find the optimal policy for a given problem.</p>
			<p>Let's start with our first steps in the temporal difference methods world.</p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor242"/>TD(0) – SARSA and Q-Learning</h1>
			<p>TD methods are model-free, meaning they do not need a model of the environment to learn a state value representation. For a given policy, <img src="image/B16182_07_00a.png" alt="1"/>, they accumulate experience associated with it and update their estimate of the value function for every state encountered during the corresponding experience. In doing so, TD methods update a given state value, visited at time <strong class="source-inline">t</strong>, using the value of state (or states) encountered at the next few time steps, so for time <strong class="source-inline">t+1</strong>, <strong class="source-inline">t+2</strong>, ..., <strong class="source-inline">t+n</strong>. An abstract example is as follows: an agent is initialized in the environment and starts interacting with it by following a given policy, without any knowledge of what results are generated by which action. Following a certain number of steps, the agent will eventually reach a state associated with a reward. This reward signal is used to increment the values of previously visited states (or action-state pairs) with the TD learning rule. In fact, those states have allowed the agent to reach the goal, so they are to be associated with a high value. Repeating this process over and over will allow the agent to build a complete and meaningful value map of all states (or state-action pairs) so that it will exploit this acquired knowledge to select the best actions, thereby leading to states associated with a reward.</p>
			<p>This means that TD methods do not have to wait until the end of the episode to improve their policy; instead, they can build upon values of states they encounter, and the learning process can start right after initialization. </p>
			<p>In this section, we will focus on the so-called one-step method, also named TD(0). In this method, the only value considered to build the update for a given state value function is the one found at the next time step, nothing else. So, for example, the value function update for a state at time <strong class="source-inline">t</strong> looks as follows:</p>
			<div>
				<div id="_idContainer468" class="IMG---Figure">
					<img src="image/B16182_07_01.jpg" alt="Figure 7.1: Value function update for a state at time 't'&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1: Value function update for a state at time 't'</p>
			<p>Here, <img src="image/B16182_07_01a.png" alt="2"/> is the next state where the environment transitioned, <img src="image/B16182_07_01b.png" alt="b"/> is the reward obtained in the transition, <img src="image/B16182_07_01c.png" alt="c"/> is the learning rate, and <img src="image/B16182_07_01d.png" alt="d"/> is the discount factor. It is clear how TD methods "bootstrap": in order to update the value function for a state <strong class="source-inline">(t)</strong>, they use the current value function for the next state <strong class="source-inline">(t+1)</strong> without waiting until the end of the episode. It is worth noting that the quantity between square brackets in the previous equation can be interpreted as an error term. This error term measures the difference between the estimated value of state S<span class="subscript">t</span> and the new, better estimate, <img src="image/B16182_07_01e.png" alt="e"/> . This quantity is called the TD error, and we will encounter it many times in RL theory:</p>
			<div>
				<div id="_idContainer474" class="IMG---Figure">
					<img src="image/B16182_07_02.jpg" alt="Figure 7.2: TD error at time 't'&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2: TD error at time 't'</p>
			<p>This error is specific for the given time it has been calculated at, and it depends on the values at the next time step (that is, the error at time t depends on the values at time <strong class="source-inline">t+1</strong>).</p>
			<p>One important theory result for TD methods is their proof of convergence: in fact, it has been demonstrated that, for any fixed policy, <img src="image/B16182_07_02a.png" alt="f"/>, the algorithm TD(0) described in the preceding equation converges to the state (or action-state pair) value function, <img src="image/B16182_07_02b.png" alt="i"/>. Convergence is reached for a constant step size parameter, provided it is sufficiently small, and with probability <strong class="source-inline">1</strong> if the step size parameter decreases according to some specific (but easy to comply with) stochastic approximation conditions. These proofs mainly apply to the tabular version of the algorithm, which are the versions used for RL theory introduction and understanding. These deal with problems in which states and actions spaces are of limited dimensions so that they can be exhaustively represented by a finite combination of variables. </p>
			<p>However, the majority of these proofs can be easily extended to algorithm versions that rely on approximations when they are composed by general linear functions. These approximated versions are used when states and actions spaces are so large that they cannot be represented by a finite combination of variables (for example, when the state space is the space of RGB images).</p>
			<p>So far, we have been dealing with state value functions. In order to approach the problem of temporal difference control, we need to learn a state-action value function rather than a state-value function. In fact, in this way, we will be able to associate a value with state-action pairs, thereby building a value map that can then be used to define our policy. How we implement this specifically depends on the method class. First, let's take a look at the on-policy approach, which is implemented by the so-called SARSA algorithm, and then the off-policy one, which is implemented by the so-called Q-learning algorithm.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor243"/>SARSA – On-Policy Control</h2>
			<p>For an on-policy method, the goal is to estimate <img src="image/B16182_07_02c.png" alt="j"/>, that is, the state-action value function for the current behavior policy, <img src="image/B16182_07_02d.png" alt="k"/>, for all states and all actions. To do so, we simply need to apply the equation we saw for the state-value function to the state-action function. Since the two cases are identical (both being Markov chains with a reward process), the theorems stating the convergence of the state-value function to the one corresponding to the optimal policy (and so, solving the problem of finding the optimal policy) are valid in this new setting, where the value function regards state-action pairs. The update equation takes the following form:</p>
			<div>
				<div id="_idContainer479" class="IMG---Figure">
					<img src="image/B16182_07_03.jpg" alt="Figure 7.3: State-action value function at time 't'&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3: State-action value function at time 't'</p>
			<p>This update is supposedly performed after every transition from a non-terminal state, <img src="image/B16182_07_03a.png" alt="a"/>. If <img src="image/B16182_07_03b.png" alt="b"/> is a terminal state, then the <img src="image/B16182_07_03c.png" alt="c"/> value is set equal to <strong class="source-inline">0</strong>. As we can see, the update rule uses every element of the quintuple <img src="image/B16182_07_03d.png" alt="d"/>, which explains the transition from one state-action pair to the next, with the reward associated with the transition. This quintuple, written in this form, is the reason why the name <strong class="bold">SARSA</strong> was given to this algorithm. </p>
			<p>Using these elements, it is straightforward to design an on-policy control algorithm based on them. As we mentioned previously, all on-policy methods estimate <img src="image/B16182_07_03e.png" alt="g"/> for the behavior policy, <img src="image/B16182_07_03f.png" alt="h"/>, and at the same time, update <img src="image/B16182_07_03g.png" alt="formula"/> based on <img src="image/B16182_07_03h.png" alt="formula"/>. A scheme for the SARSA control algorithm can be depicted as follows:</p>
			<ol>
				<li>Choose the algorithm parameters; that is, the step size, <img src="image/B16182_07_03i.png" alt="formula"/>, which has to be contained in the interval <strong class="source-inline">(0, 1]</strong>, and the <strong class="source-inline">ε</strong> parameter of the ε-greedy policy, which has to be small and greater than 0, since it represents the probability of choosing the non-optimal action to favor exploration. This can be done with the following code:<p class="source-code">alpha = 0.02</p><p class="source-code">epsilon = 0.05</p></li>
				<li>Initialize <img src="image/B16182_07_03j.png" alt="formula"/>, for all values of <img src="image/B16182_07_03k.png" alt="formula"/>, <img src="image/B16182_07_03l.png" alt="formula"/>, arbitrarily, except that Q(terminal, ·) = 0, as shown by the following code snippet, in the case of an environment with <strong class="source-inline">16</strong> states and <strong class="source-inline">4 </strong>actions:<p class="source-code">q = np.ones((16,4))</p></li>
				<li>Create a loop for each episode. Initialize <img src="image/B16182_07_03m.png" alt="formula"/> and choose <img src="image/B16182_07_03n.png" alt="formula"/> from <img src="image/B16182_07_03o.png" alt="formula"/> using the policy derived from Q (for example, ε-greedy). This can be done using the following snippet, where the initial state is provided by the environment <strong class="source-inline">reset</strong> function and the action is selected using a dedicated ε-greedy function:<p class="source-code">for i in range(nb_episodes):</p><p class="source-code">        s = env.reset()</p><p class="source-code">        a = action_epsilon_greedy(q, s, epsilon=epsilon)</p></li>
				<li>Create a loop for each step of the episode. Take action <img src="image/B16182_07_03p.png" alt="formula"/> and observe <img src="image/B16182_07_03q.png" alt="formula"/>. Choose <img src="image/B16182_07_03r.png" alt="formula"/> from <img src="image/B16182_07_03s.png" alt="formula"/> using the policy derived from Q (for example, ε-greedy). Update the state-action value function for the selected state-action pair using the SARSA rule, which defines the new value as the sum of the current one, plus the TD error multiplied by the step size, <img src="image/B16182_07_03t.png" alt="formula"/>, as depicted in the following expression:<div id="_idContainer500" class="IMG---Figure"><img src="image/B16182_07_04.jpg" alt="Figure 7.4: Updating the state-action value function using the SARSA rule&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.4: Updating the state-action value function using the SARSA rule</p>
			<p>Then, update the state-action pair with the new one using <img src="image/B16182_07_04a.png" alt="formula"/> until <img src="image/B16182_07_04b.png" alt="formula"/> is a terminal state. All of this is done using the following code:</p>
			<p class="source-code">while not done:</p>
			<p class="source-code">            new_s, reward, done, info = env.step(a)</p>
			<p class="source-code">            new_a = action_epsilon_greedy(q, new_s, epsilon=epsilon)</p>
			<p class="source-code">            q[s, a] = q[s, a] + alpha * (reward + gamma \</p>
			<p class="source-code">                      * q[new_s, new_a] - q[s, a])</p>
			<p class="source-code">            s = new_s</p>
			<p class="source-code">            a = new_a</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The steps and code for this algorithm were originally developed and outlined by <em class="italic">Sutton, Richard S. Introduction to Reinforcement Learning. Cambridge, Mass: MIT Press, 2015</em>.</p>
			<p>The SARSA algorithm can converge to an optimal policy and an optimal action-value function with probability equal to <strong class="source-inline">1</strong> under the following conditions: </p>
			<ul>
				<li>All the state-action pairs need to be visited an infinite number of times.</li>
				<li>The policy converges in the limit to the greedy policy, which can be achieved with ε-greedy policies where <strong class="source-inline">ε</strong> vanishes in time (this can be done by setting <strong class="source-inline">ε = 1/t</strong>). </li>
			</ul>
			<p>This algorithm makes use of the ε-greedy algorithm. We will explain this in more detail in the next chapter, so we will only briefly recall what it is here. When learning policies by means of state-action value functions, the value associated with the state-action pairs is used to decide which is the best action to take. At convergence, the best action is chosen among the available ones for a given state, and we opt for the one that has the highest value: this is the greedy approach. This means that for every given state, the same action will always be chosen (if no actions have the same value). This is not a good choice for exploration, especially at the beginning of training. For this reason, the ε-greedy approach is preferred in this phase: the best action is chosen with a probability equal to <strong class="source-inline">1-ε</strong>, while in the other cases, a random action is selected. By making <strong class="source-inline">ε</strong> diminishing, the ε-greedy approach becomes the greedy one in the limit as the number of steps approaches infinity.</p>
			<p>In order to consolidate these concepts, let's apply the SARSA control algorithm right away. The following exercise will show you how to implement TD(0) SARSA to solve the FrozenLake-v0 environment, using its deterministic version first.</p>
			<p>The goal here is to see how the SARSA algorithm is able to recover the optimal policy, which we humans can estimate in advance, for a given configuration of the problem. Before jumping into it, let's quickly recap what the frozen lake problem is and the optimal policy we aim to make the agent find. The agent sees a grid world whose dimension is 4 x 4. </p>
			<p>The grid has a starting position, <strong class="source-inline">S</strong> (upper left-hand side), frozen tiles, <strong class="source-inline">F</strong>, holes, <strong class="source-inline">H</strong>, and a goal, <strong class="source-inline">G</strong> (lower right). The agent is rewarded with +1 when it reaches the terminal goal state, while the episode ends without a reward if it reaches the terminal states constituted by the holes. The following table represents the environment:</p>
			<div>
				<div id="_idContainer503" class="IMG---Figure">
					<img src="image/B16182_07_05.jpg" alt="Figure 7.5: The FrozenLake-v0 environment&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5: The FrozenLake-v0 environment</p>
			<p>As you can see in the preceding diagram, <strong class="source-inline">S</strong> is the starting position, <strong class="source-inline">F</strong> indicates frozen tiles, <strong class="source-inline">H</strong> means holes, and <strong class="source-inline">G</strong> is the goal. For the deterministic environment, the optimal policy is the one that allows the agent to reach the goal in the shortest possible time. To be 100% precise, in this case, since, in this specific environment, no penalty for intermediate steps is applied, there is no need for the optimal path to be the shortest one. Every path that eventually leads to the goal is equally optimal in terms of cumulative expected reward. However, we will see that by appropriately using the discount factor, we will be able to recover the optimal policy, which also accounts for the shortest path. Under this condition, the optimal policy is represented in the following diagram, where each of the four moves (Down, Right, Left, and Up) are represented by their initial letter. There are two tiles for which two actions would result in the same optimal path:</p>
			<div>
				<div id="_idContainer504" class="IMG---Figure">
					<img src="image/B16182_07_06.jpg" alt="Figure 7.6: Optimal policy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6: Optimal policy</p>
			<p>In the preceding diagram, <strong class="source-inline">D</strong> denotes Down, <strong class="source-inline">R</strong> denotes Right, <strong class="source-inline">U</strong> denotes Up, and <strong class="source-inline">L</strong> denotes Left.<strong class="source-inline">!</strong> stands for the goal, and <strong class="source-inline">–</strong> refers to the holes in the environment.</p>
			<p>We will use a decreasing <strong class="source-inline">ε</strong> value in order to anneal the exploration from large to small, thereby making it become, in the limit, greedy. </p>
			<p>This type of exercise is very useful when learning about classic reinforcement learning algorithms. Being tabular (this is a grid world example, meaning it can be represented by a 4x4 grid) allows us to keep track of everything that's happening in the domain, easily follow state-actions pairs values being updated during algorithm iterations, look at action choices according to the selected policy, and converge to the optimal policy. In this chapter, you will learn how to code a reference algorithm in the RL landscape and get deep hands-on experience with all these fundamental aspects.</p>
			<p>Let's now move on to the implementation.</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor244"/>Exercise 7.01: Using TD(0) SARSA to Solve FrozenLake-v0 Deterministic Transitions</h2>
			<p>In this exercise, we will implement the SARSA algorithm and use it to solve the FrozenLake-v0 environment, where only deterministic transitions are allowed. This means we will look for (and actually find) the optimal policy to retrieve the frisbee in this environment. </p>
			<p>The following steps will help you to complete this exercise:</p>
			<ol>
				<li value="1">Import the required modules:<p class="source-code">import numpy as np</p><p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">%matplotlib inline</p><p class="source-code">import gym</p></li>
				<li>Instantiate the <strong class="source-inline">gym</strong> environment called <strong class="source-inline">FrozenLake-v0</strong>. Set the <strong class="source-inline">is_slippery</strong> flag to <strong class="source-inline">False</strong> to disable its stochasticity:<p class="source-code">env = gym.make('FrozenLake-v0', is_slippery=False)</p></li>
				<li>Take a look at the action and the observation spaces:<p class="source-code">print("Action space = ", env.action_space)</p><p class="source-code">print("Observation space = ", env.observation_space)</p><p>This will print out the following:</p><p class="source-code">Action space =  Discrete(4)</p><p class="source-code">Observation space =  Discrete(16)</p></li>
				<li>Create two dictionaries to easily translate action numbers into moves:<p class="source-code">actionsDict = {}</p><p class="source-code">actionsDict[0] = " L "</p><p class="source-code">actionsDict[1] = " D "</p><p class="source-code">actionsDict[2] = " R "</p><p class="source-code">actionsDict[3] = " U "</p><p class="source-code">actionsDictInv = {}</p><p class="source-code">actionsDictInv["L"] = 0</p><p class="source-code">actionsDictInv["D"] = 1</p><p class="source-code">actionsDictInv["R"] = 2</p><p class="source-code">actionsDictInv["U"] = 3</p></li>
				<li>Reset the environment and render it to be able to take a look at the grid problem:<p class="source-code">env.reset()</p><p class="source-code">env.render()</p><p>The output will be as follows:</p><div id="_idContainer505" class="IMG---Figure"><img src="image/B16182_07_07.jpg" alt="Figure 7.7: Environment's initial state&#13;&#10;"/></div><p class="figure-caption">Figure 7.7: Environment's initial state</p></li>
				<li>Visualize the optimal policy for this environment:<p class="source-code">optimalPolicy = ["R/D"," R "," D "," L ", \</p><p class="source-code">                 " D "," - "," D "," - ", \</p><p class="source-code">                 " R ","R/D"," D "," - ", \</p><p class="source-code">                 " - "," R "," R "," ! ",]</p><p class="source-code">print("Optimal policy:")</p><p class="source-code">idxs = [0,4,8,12]</p><p class="source-code">for idx in idxs:</p><p class="source-code">    print(optimalPolicy[idx+0], optimalPolicy[idx+1], \</p><p class="source-code">          optimalPolicy[idx+2], optimalPolicy[idx+3])</p><p>The output will be as follows:</p><p class="source-code">Optimal policy:  </p><p class="source-code">R/D  R   D  L</p><p class="source-code"> D   -   D  -</p><p class="source-code"> R  R/D  D  -</p><p class="source-code"> -   R   R  !</p><p>This represents the optimal policy for this environment, showing, for each of the environment states represented in the 4x4 grid, the optimal action among the four available: <em class="italic">move Up</em>, <em class="italic">move Down</em>, <em class="italic">move Right</em>, and <em class="italic">move Left</em>. Except for two states, all the others have a single optimal action associated with them. In fact, as described previously, optimal actions here are those that bring the agent to the goal using the shortest possible path. Two different possibilities result in the same path length for two states, so they are both equally optimal.</p></li>
				<li>Define functions to take ε-greedy actions. The first function implements the ε-greedy policy with a probability of <strong class="source-inline">1 - ε</strong>. The chosen action is the one with the highest value associated with the state-action pair; otherwise, a random action is returned. The second function simply makes the first callable when it's passed as an argument by using a <strong class="source-inline">lambda</strong> function:<p class="source-code">def action_epsilon_greedy(q, s, epsilon=0.05):</p><p class="source-code">    if np.random.rand() &gt; epsilon:</p><p class="source-code">        return np.argmax(q[s])</p><p class="source-code">    return np.random.randint(4)</p><p class="source-code">def get_action_epsilon_greedy(epsilon):</p><p class="source-code">    return lambda q,s: action_epsilon_greedy\</p><p class="source-code">                       (q, s, epsilon=epsilon)</p></li>
				<li>Define a function to take greedy actions:<p class="source-code">def greedy_policy(q, s):</p><p class="source-code">    return np.argmax(q[s])</p></li>
				<li>Now, define a function that will calculate the mean of the agent's performances. First, we'll define the number of episodes used to calculate the average performance (in this case, <strong class="source-inline">500</strong>), and then execute all these episodes in a loop. We'll reset the environment and start the in-episode loop to do so. We then select an action according to the policy that we want to measure the performance of, step through the environment with the chosen action, and finally add the reward to the accumulated returns. We repeat these environment steps until the episode is complete:<p class="source-code">def average_performance(policy_fct, q):</p><p class="source-code">    acc_returns = 0.</p><p class="source-code">    n = 500</p><p class="source-code">    for i in range(n):</p><p class="source-code">        done = False</p><p class="source-code">        s = env.reset()</p><p class="source-code">        while not done:</p><p class="source-code">            a = policy_fct(q, s)</p><p class="source-code">            s, reward, done, info = env.step(a)</p><p class="source-code">            acc_returns += reward</p><p class="source-code">    return acc_returns/n</p></li>
				<li>Set the number of total episodes and number of steps specifying how often the agent's average performance is estimated, as well as the <strong class="source-inline">ε</strong> parameters, which determine its decrease. Use the starting value, minimum value, and range (in terms of the number of episodes) over which the decrease is spread:<p class="source-code">nb_episodes = 80000</p><p class="source-code">STEPS = 2000</p><p class="source-code">epsilon_param = [[0.2, 0.001, int(nb_episodes/2)]]</p></li>
				<li>Define the SARSA training algorithm as a function. In this step, the Q-table is initialized. All the values are equal to <strong class="source-inline">1</strong>, but the values at terminal states are set equal to <strong class="source-inline">0</strong>:<p class="source-code">def sarsa(alpha = 0.02, \</p><p class="source-code">          gamma = 1., \</p><p class="source-code">          epsilon_start = 0.1, \</p><p class="source-code">          epsilon_end = 0.001, \</p><p class="source-code">          epsilon_annealing_stop = int(nb_episodes/2), \</p><p class="source-code">          q = None, \</p><p class="source-code">          progress = None, \</p><p class="source-code">          env=env):</p><p class="source-code">    if q is None:</p><p class="source-code">        q = np.ones((16,4))</p><p class="source-code">        # Set q(terminal,*) equal to 0</p><p class="source-code">        q[5,:] = 0.0</p><p class="source-code">        q[7,:] = 0.0</p><p class="source-code">        q[11,:] = 0.0</p><p class="source-code">        q[12,:] = 0.0</p><p class="source-code">        q[15,:] = 0.0</p></li>
				<li>Start a <strong class="source-inline">for</strong> loop among all the episodes:<p class="source-code">    for i in range(nb_episodes):</p></li>
				<li>Inside the loop, first, the epsilon value is defined, depending on the current episode number:<p class="source-code">        inew = min(i,epsilon_annealing_stop)</p><p class="source-code">        epsilon = (epsilon_start \</p><p class="source-code">                   *(epsilon_annealing_stop - inew)\</p><p class="source-code">                   +epsilon_end * inew) / epsilon_annealing_stop</p></li>
				<li>Next, the environment is reset, and the first action is chosen with an ε-greedy policy:<p class="source-code">        done = False</p><p class="source-code">        s = env.reset()</p><p class="source-code">        a = action_epsilon_greedy(q, s, epsilon=epsilon)</p></li>
				<li>Then, we start an in-episode loop:<p class="source-code">        while not done:</p></li>
				<li>Inside the loop, the environment is stepped throughout using the selected action and the new state and the reward, and the done conditions are retrieved:<p class="source-code">            new_s, reward, done, info = env.step(a)</p></li>
				<li>Select a new action with the ε-greedy policy, update the Q-table with the SARSA TD(0) rule, and update the state and action with their new values:<p class="source-code">            new_a = action_epsilon_greedy\</p><p class="source-code">                    (q, new_s, epsilon=epsilon)</p><p class="source-code">            q[s, a] = q[s, a] + alpha * (reward + gamma \</p><p class="source-code">                      * q[new_s, new_a] - q[s, a])</p><p class="source-code">            s = new_s</p><p class="source-code">            a = new_a</p></li>
				<li>Finally, the agent's average performance is estimated:<p class="source-code">        if progress is not None and i%STEPS == 0:</p><p class="source-code">            progress[i//STEPS] = average_performance\</p><p class="source-code">                                 (get_action_epsilon_greedy\</p><p class="source-code">                                 (epsilon), q=q)</p><p class="source-code">    return q, progress</p><p>It may be useful to provide a brief description of the <strong class="source-inline">ε</strong> parameter's decrease. This is determined by three parameters: the starting value, minimum value, and decrease range (called <strong class="source-inline">epsilon_annealing_stop</strong>). They are used in the following way: <strong class="source-inline">ε</strong> starts at the starting value, and then it is decreased linearly across the number of episodes defined by the parameter's "range" until it reaches the minimum value, which is then kept constant.</p></li>
				<li>Define an array that will collect all agent performance evaluations during training and the execution of SARSA TD(0) training:<p class="source-code">sarsa_performance = np.ndarray(nb_episodes//STEPS)</p><p class="source-code">q, sarsa_performance = sarsa(alpha = 0.02, gamma = 0.9, \</p><p class="source-code">                             progress=sarsa_performance, \</p><p class="source-code">                             epsilon_start=epsilon_param[0][0],\</p><p class="source-code">                             epsilon_end=epsilon_param[0][1], \</p><p class="source-code">                             epsilon_annealing_stop = \</p><p class="source-code">                             epsilon_param[0][2])</p></li>
				<li>Plot the SARSA agent's average reward history during training:<p class="source-code">plt.plot(STEPS*np.arange(nb_episodes//STEPS), sarsa_performance)</p><p class="source-code">plt.xlabel("Epochs")</p><p class="source-code">plt.title("Learning progress for SARSA")</p><p class="source-code">plt.ylabel("Average reward of an epoch")</p><p>This generates the following output:</p><p class="source-code">Text(0, 0.5, 'Average reward of an epoch')</p><p>The plot for this can be visualized as follows. This shows the learning progress of the SARSA algorithm:</p><div id="_idContainer506" class="IMG---Figure"><img src="image/B16182_07_08.jpg" alt="Figure 7.8: Average reward of an epoch trend over training epochs&#13;&#10;"/></div><p class="figure-caption">Figure 7.8: Average reward of an epoch trend over training epochs</p><p>As we can see, SARSA's performance grows over time as the <strong class="source-inline">ε</strong> parameter is annealed, thus reaching the value of <strong class="source-inline">0</strong> in the limit, thereby obtaining the greedy policy. This also demonstrates that the algorithm is capable of reaching 100% success after learning.</p></li>
				<li>Evaluate the greedy policy's performance of the trained agent (Q-table):<p class="source-code">greedyPolicyAvgPerf = average_performance(greedy_policy, q=q)</p><p class="source-code">print("Greedy policy SARSA performance =", greedyPolicyAvgPerf)</p><p>The output will be as follows:</p><p class="source-code">Greedy policy SARSA performance = 1.0</p></li>
				<li>Display the Q-table values:<p class="source-code">q = np.round(q,3)</p><p class="source-code">print("(A,S) Value function =", q.shape)</p><p class="source-code">print("First row")</p><p class="source-code">print(q[0:4,:])</p><p class="source-code">print("Second row")</p><p class="source-code">print(q[4:8,:])</p><p class="source-code">print("Third row")</p><p class="source-code">print(q[8:12,:])</p><p class="source-code">print("Fourth row")</p><p class="source-code">print(q[12:16,:])</p><p>The output will be as follows:</p><p class="source-code">(A,S) Value function = (16, 4)</p><p class="source-code">First row </p><p class="source-code">[[0.505 0.59  0.54  0.506]</p><p class="source-code"> [0.447 0.002 0.619 0.494]</p><p class="source-code"> [0.49  0.706 0.487 0.562]</p><p class="source-code"> [0.57  0.379 0.53  0.532]]</p><p class="source-code">Second row</p><p class="source-code">[[0.564 0.656 0.    0.503]</p><p class="source-code"> [0.    0.    0.    0.   ]</p><p class="source-code"> [0.003 0.803 0.002 0.567]</p><p class="source-code"> [0.    0.    0.    0.   ]]</p><p class="source-code">Third row</p><p class="source-code">[[0.62  0.    0.728 0.555]</p><p class="source-code"> [0.63  0.809 0.787 0.   ]</p><p class="source-code"> [0.707 0.899 0.    0.699]</p><p class="source-code"> [0.    0.    0.    0.   ]]</p><p class="source-code">Fourth row</p><p class="source-code">[[0.    0.    0.    0.   ]</p><p class="source-code"> [0.    0.791 0.9   0.696]</p><p class="source-code"> [0.797 0.895 1.    0.782]</p><p class="source-code"> [0.    0.    0.    0.   ]]</p><p>This output shows the values of the complete state-action value function for our problem. These values are then used to generate the optimal policy by means of the greedy selection rule.</p></li>
				<li>Print out the greedy policy that was found and compare it with the optimal policy. Having calculated the state-action value function, we are able to retrieve the greedy policy from it. In fact, as explained previously, the greedy policy chooses the action that, for a given state, is associated with the maximum value of the Q-table. For this purpose, we are using the <strong class="source-inline">argmax</strong> function. When applied to each of the 16 states (from 0 to 15), it returns the index of the four actions (from 0 to 3) with the highest associated value for that state. Here, we also directly output the label associated with the action index using the pre-built dictionary:<p class="source-code">policyFound = [actionsDict[np.argmax(q[0,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[1,:])], \</p><p class="source-code">               actionsDict[np.argmax(q[2,:])], \</p><p class="source-code">               actionsDict[np.argmax(q[3,:])], \</p><p class="source-code">               actionsDict[np.argmax(q[4,:])], \</p><p class="source-code">               " - ",\</p><p class="source-code">               actionsDict[np.argmax(q[6,:])], \</p><p class="source-code">               " - ",\</p><p class="source-code">               actionsDict[np.argmax(q[8,:])], \</p><p class="source-code">               actionsDict[np.argmax(q[9,:])], \</p><p class="source-code">               actionsDict[np.argmax(q[10,:])], \</p><p class="source-code">               " - ",\</p><p class="source-code">               " - ",\</p><p class="source-code">               actionsDict[np.argmax(q[13,:])], \</p><p class="source-code">               actionsDict[np.argmax(q[14,:])], \</p><p class="source-code">               " ! "]</p><p class="source-code">print("Greedy policy found:")</p><p class="source-code">idxs = [0,4,8,12]</p><p class="source-code">for idx in idxs:</p><p class="source-code">    print(policyFound[idx+0], policyFound[idx+1], \</p><p class="source-code">          policyFound[idx+2], policyFound[idx+3])</p><p class="source-code">print(" ")</p><p class="source-code">print("Optimal policy:")</p><p class="source-code">idxs = [0,4,8,12]</p><p class="source-code">for idx in idxs:</p><p class="source-code">    print(optimalPolicy[idx+0], optimalPolicy[idx+1], \</p><p class="source-code">          optimalPolicy[idx+2], optimalPolicy[idx+3])</p><p>The output is as follows:</p><p class="source-code">Greedy policy found: </p><p class="source-code"> D   R   D  L</p><p class="source-code"> D   -   D  -</p><p class="source-code"> R   D   D  -</p><p class="source-code"> -   R   R  !  </p><p class="source-code"> </p><p class="source-code">Optimal policy:  </p><p class="source-code">R/D  R   D  L</p><p class="source-code"> D   -   D  -</p><p class="source-code"> R  R/D  D  -</p><p class="source-code"> -   R   R  !</p></li>
			</ol>
			<p>As the preceding output shows, the TD(0) SARSA algorithm we implemented has been able to successfully learn the optimal policy for this task just by interacting with the environment and collecting experience of it through episodes and then adopting the SARSA state-action pair value function update rule that was defined in the <em class="italic">SARSA – On-Policy Control</em> section. In fact, as we can see, for every state of the environment, the greedy policy that was obtained with the Q-table calculated by our algorithm prescribes an action that is in accordance with the optimal policy that was defined for analyzing the environment problem. As we already saw, there are two states in which there are two equally optimal actions and the agent correctly implements one of them.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3fJBLBh">https://packt.live/3fJBLBh</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/30XeOXj">https://packt.live/30XeOXj</a>.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor245"/>The Stochasticity Test</h2>
			<p>Now, let's take a look at what happens if the stochasticity is enabled in the FrozenLake-v0 environment. Enabling the stochasticity for this task means that every transition for a selected action is no longer deterministic. In particular, for a given action, there is a one in three chances that the action is executed as intended and 2 out of 3 equally distributed chances (1/3 and 1/3 each) for the two neighboring actions. Zero probability is assigned to the action in the opposite direction. So, for example, if the Down action is set, the agent will move down 1/3 of the time, move right 1/3 of the time, and move left the remaining 1/3 of the time, never going up, as shown in the following diagram:</p>
			<div>
				<div id="_idContainer507" class="IMG---Figure">
					<img src="image/B16182_07_09.jpg" alt="Figure 7.9: Percentages for the resulting states if the Down action &#13;&#10;is taken from the central tile&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9: Percentages for the resulting states if the Down action is taken from the central tile</p>
			<p>The environment setting is the very same as it was for the FrozenLake-v0 deterministic case we saw previously. Again, we want the SARSA algorithm to recover the optimal policy. This can be estimated in advance in this case as well. Just to make the reasoning for this easier, here's the table representing this environment:</p>
			<div>
				<div id="_idContainer508" class="IMG---Figure">
					<img src="image/B16182_07_10.jpg" alt="Figure 7.10: Problem setting&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.10: Problem setting</p>
			<p>In the preceding diagram, <strong class="source-inline">S</strong> is the starting position, <strong class="source-inline">F</strong> indicates frozen tiles, <strong class="source-inline">H</strong> indicate the holes, and <strong class="source-inline">G</strong> is the goal. For the stochastic environment, the optimal policy is very different with respect to the one that corresponds to the deterministic case, and it may even appear counter-intuitive. The key point is that in order to keep the possibility of obtaining a reward alive, our only chance is to avoid falling into the holes. Since there is no penalty for intermediate steps, we can keep going around for as long as we need to. And the only certain way to do so is as follows:</p>
			<ol>
				<li value="1">Move in the opposite direction of the hole we find next to us, even if this means moving away from the goal.</li>
				<li>Avoid, in every possible way, falling into those tiles where there is a chance greater than 0 of falling into a hole:</li>
			</ol>
			<div>
				<div id="_idContainer509" class="IMG---Figure">
					<img src="image/B16182_07_11.jpg" alt="Figure 7.11: Environment setup (A), action executed by the agent (B), and chances of ending near the starting state in each position (C)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.11: Environment setup (A), action executed by the agent (B), and chances of ending near the starting state in each position (C)</p>
			<p>For example, let's consider the first tile on the left, in the second row from the top, in our problem setting, as shown in table <strong class="source-inline">B</strong> in the preceding diagram. In the deterministic case, the optimal action was to go down because it would bring us closer to the goal. In this case, instead, the best action to choose is to move left, even if moving left means bouncing into the wall. This is because moving left is the only action that won't make us fall into the hole. In addition, there is a 33% probability that we will end up in the tile on the third row from above, thereby getting closer to the goal.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The preceding behavior follows a standard boundary implementation. In that tile, you execute the action "Move Left" (which is a completely legal action) and the environment will understand that this results in "bouncing." The algorithm simply sends a "move left" action to the environment, which, in turn, will take the prescribed action into account.</p>
			<p>Similar reasoning can be applied to all the other tiles while keeping the key point mentioned previously in mind. However, it is worth discussing a very peculiar case – one that's the only reason why we cannot achieve 100% success, even with the optimal policy:</p>
			<div>
				<div id="_idContainer510" class="IMG---Figure">
					<img src="image/B16182_07_12.jpg" alt="Figure 7.12: Environment setup (A), &quot;Move to the Left&quot; action executed by the agent (B), and chances of ending near the starting state in each position (C)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.12: Environment setup (A), "Move to the Left" action executed by the agent (B), and chances of ending near the starting state in each position (C)</p>
			<p>Now, let's take a look at the third tile from the left in the second row from the top in our problem setting, as shown in table B in the preceding diagram. This tile is between two holes, so there is no way to take an action that is 100% safe. Here, the best action is actually to move toward either the left or the right hole! This is because by moving left or right, we have a 66% chance of moving up or down, and only a 33% chance of falling into the hole. Moving up or down means we would have a 66% chance of moving right or left, falling into the hole, and only a 33% chance of actually moving up or down. And since this tile is the reason why we cannot achieve maximum performance 100% of the time, the best thing is to avoid reaching that tile. In order to do so, optimal actions of the very first row, apart from the starting tile, are all pointing up so that it is not possible to land on the problematic tile. </p>
			<p>All other values are constrained by the hole's proximity, except for the tile on the left of the goal: the optimal action choice for this tile is to move down since it maintains the chance of landing in the goal, while at the same time avoiding landing in the tile above it, where, in turn, the agent would be forced to move left to avoid the hole, thus risking landing on the tile between the two holes. The optimal policy is summarized in the following diagram:</p>
			<div>
				<div id="_idContainer511" class="IMG---Figure">
					<img src="image/B16182_07_13.jpg" alt="Figure 7.13: Optimal policy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.13: Optimal policy</p>
			<p>The preceding diagram displays the optimal policy of the environment explained previously, where <strong class="source-inline">D</strong> denotes a Down move, <strong class="source-inline">R</strong> denotes a Right move, <strong class="source-inline">U</strong> denotes an Up move, and <strong class="source-inline">L</strong> denotes a Left move.</p>
			<p>In the following example, we will use the SARSA algorithm to solve this new flavor of the FrozenLake-v0 environment. In order to obtain the optimal policy we just described, we need to adjust our hyperparameters – in particular, the discount factor, <img src="image/B16182_07_13a.png" alt="a"/>. In fact, we want to give the agent the freedom to make however many steps they need to. In order to do so, we have to propagate the value of the goal backward so that all the trajectories in the goal will benefit from it, even if those trajectories are not the shortest ones. For this reason, we will use a discount factor equal (or very close) to <strong class="source-inline">1</strong>. In code, this means that instead of using <strong class="source-inline">gamma = 0.9,</strong> we will use <strong class="source-inline">gamma = 1</strong>.</p>
			<p>Now, let's see our SARSA algorithm working in this stochastic environment. </p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor246"/>Exercise 7.02: Using TD(0) SARSA to Solve FrozenLake-v0 Stochastic Transitions</h2>
			<p>In this exercise, we'll use the TD(0) SARSA algorithm to solve the FrozenLake-v0 environment, with stochastic transitions enabled. As we just saw, the optimal policy looks completely different with respect to the previous exercise since it needs to take care of the stochasticity factor. This imposes a new challenge for the SARSA algorithm, and we will see how it will still be able to solve this task. This exercise will show us how these sound TD methods are able to deal with different challenges, demonstrating a notable robustness.</p>
			<p>Follow these steps to complete this exercise:</p>
			<ol>
				<li value="1">Import the required modules:<p class="source-code">import numpy as np</p><p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">%matplotlib inline</p><p class="source-code">import gym</p></li>
				<li>Instantiate the <strong class="source-inline">gym</strong> environment called <strong class="source-inline">FrozenLake-v0</strong> using the <strong class="source-inline">is_slippery</strong> flag set to <strong class="source-inline">True</strong> in order to enable stochasticity:<p class="source-code">env = gym.make('FrozenLake-v0', is_slippery=True)</p></li>
				<li>Take a look at the action and the observation spaces:<p class="source-code">print("Action space = ", env.action_space)</p><p class="source-code">print("Observation space = ", env.observation_space)</p><p>The output will be as follows:</p><p class="source-code">Action space =  Discrete(4)</p><p class="source-code">Observation space =  Discrete(16)</p></li>
				<li>Create two dictionaries to easily map the <strong class="source-inline">actions</strong> indices (from <strong class="source-inline">0</strong> to <strong class="source-inline">3</strong>) to the labels (Left, Down, Right, and Up):<p class="source-code">actionsDict = {}</p><p class="source-code">actionsDict[0] = "  L  "</p><p class="source-code">actionsDict[1] = "  D  "</p><p class="source-code">actionsDict[2] = "  R  "</p><p class="source-code">actionsDict[3] = "  U  "</p><p class="source-code">actionsDictInv = {}</p><p class="source-code">actionsDictInv["L"] = 0</p><p class="source-code">actionsDictInv["D"] = 1</p><p class="source-code">actionsDictInv["R"] = 2</p><p class="source-code">actionsDictInv["U"] = 3</p></li>
				<li>Reset the environment and render it to take a look at the grid problem:<p class="source-code">env.reset()</p><p class="source-code">env.render()</p><p>The output will be as follows:</p><div id="_idContainer513" class="IMG---Figure"><img src="image/B16182_07_14.jpg" alt="Figure 7.14: Environment's initial state&#13;&#10;"/></div><p class="figure-caption">Figure 7.14: Environment's initial state</p></li>
				<li>Visualize the optimal policy for this environment:<p class="source-code">optimalPolicy = ["L/R/D","  U  ","  U  ","  U  ",\</p><p class="source-code">                 "  L  ","  -  "," L/R ","  -  ",\</p><p class="source-code">                 "  U  ","  D  ","  L  ","  -  ",\</p><p class="source-code">                 "  -  ","  R  ","  D  ","  !  ",]</p><p class="source-code">print("Optimal policy:")</p><p class="source-code">idxs = [0,4,8,12]</p><p class="source-code">for idx in idxs:</p><p class="source-code">    print(optimalPolicy[idx+0], optimalPolicy[idx+1], \</p><p class="source-code">          optimalPolicy[idx+2], optimalPolicy[idx+3])</p><p>The output will be as follows:</p><p class="source-code">Optimal policy:  </p><p class="source-code">  L/R/D  U    U    U</p><p class="source-code">    L    -   L/R   -</p><p class="source-code">    U    D    L    -</p><p class="source-code">    -    R    D    !</p><p>This represents the optimal policy for this environment. Except from two states, all the other ones have a single optimal action associated with them. In fact, as described previously, optimal actions here are those that bring the agent away from the holes or from tiles that have a chance greater than zero of leading the agent to tiles placed near holes. Two states have multiple optimal actions associated with them that are all equally optimal, as intended for this task.</p></li>
				<li>Define functions that will take ε-greedy actions:<p class="source-code">def action_epsilon_greedy(q, s, epsilon=0.05):</p><p class="source-code">    if np.random.rand() &gt; epsilon:</p><p class="source-code">        return np.argmax(q[s])</p><p class="source-code">    return np.random.randint(4)</p><p class="source-code">def get_action_epsilon_greedy(epsilon):</p><p class="source-code">    return lambda q,s: action_epsilon_greedy\</p><p class="source-code">                       (q, s, epsilon=epsilon)</p><p>The first function implements the ε-greedy policy: with a probability of <strong class="source-inline">1 – ε</strong>, the chosen action is the one with the highest value associated with the state-action pair; otherwise, a random action is returned. The second function simply makes the first callable when passed as an argument using a <strong class="source-inline">lambda</strong> function.</p></li>
				<li>Define a function that will take greedy actions:<p class="source-code">def greedy_policy(q, s):</p><p class="source-code">    return np.argmax(q[s])</p></li>
				<li>Define a function that will calculate average agent performance:<p class="source-code">def average_performance(policy_fct, q):</p><p class="source-code">    acc_returns = 0.</p><p class="source-code">    n = 100</p><p class="source-code">    for i in range(n):</p><p class="source-code">        done = False</p><p class="source-code">        s = env.reset()</p><p class="source-code">        while not done:</p><p class="source-code">            a = policy_fct(q, s)</p><p class="source-code">            s, reward, done, info = env.step(a)</p><p class="source-code">            acc_returns += reward</p><p class="source-code">    return acc_returns/n</p></li>
				<li>Set the number of total episodes, the number of steps representing the interval by which the agent's average performance is evaluated and the <strong class="source-inline">ε</strong> parameters, ruling its decrease, that is, the starting value, minimum value, and range (in terms of the number of episodes) over which the decrease is spread:<p class="source-code">nb_episodes = 80000</p><p class="source-code">STEPS = 2000</p><p class="source-code">epsilon_param = [[0.2, 0.001, int(nb_episodes/2)]]</p></li>
				<li>Define the SARSA training algorithm as a function. Initialize the Q-table with all the values equal to <strong class="source-inline">1</strong>, but with the values at terminal states set equal to <strong class="source-inline">0</strong>:<p class="source-code">def sarsa(alpha = 0.02, \</p><p class="source-code">          gamma = 1., \</p><p class="source-code">          epsilon_start = 0.1,\</p><p class="source-code">          epsilon_end = 0.001,\</p><p class="source-code">          epsilon_annealing_stop = int(nb_episodes/2),\</p><p class="source-code">          q = None, \</p><p class="source-code">          progress = None, \</p><p class="source-code">          env=env):</p><p class="source-code">    if q is None:</p><p class="source-code">        q = np.ones((16,4))</p><p class="source-code">        # Set q(terminal,*) equal to 0</p><p class="source-code">        q[5,:] = 0.0</p><p class="source-code">        q[7,:] = 0.0</p><p class="source-code">        q[11,:] = 0.0</p><p class="source-code">        q[12,:] = 0.0</p><p class="source-code">        q[15,:] = 0.0</p></li>
				<li>Start a loop among all episodes:<p class="source-code">    for i in range(nb_episodes):</p></li>
				<li>Inside the loop, first, define the epsilon value, depending on the current episode number. Reset the environment and make sure that the first action is chosen with an ε-greedy policy: <p class="source-code">        inew = min(i,epsilon_annealing_stop)</p><p class="source-code">        epsilon = (epsilon_start \</p><p class="source-code">                   * (epsilon_annealing_stop - inew)\</p><p class="source-code">                   + epsilon_end * inew) \</p><p class="source-code">                   / epsilon_annealing_stop</p><p class="source-code">        done = False</p><p class="source-code">        s = env.reset()</p><p class="source-code">        a = action_epsilon_greedy(q, s, epsilon=epsilon)</p></li>
				<li>Then, start an in-episode loop:<p class="source-code">        while not done:</p></li>
				<li>Inside the loop, step throughout the environment using the selected action and ensure that the new state, the reward, and the done conditions are retrieved:<p class="source-code">            new_s, reward, done, info = env.step(a)</p></li>
				<li>Select a new action with the ε-greedy policy, update the Q-table with the SARSA TD(0) rule, and ensure that the state and action are updated with their new values:<p class="source-code">            new_a = action_epsilon_greedy\</p><p class="source-code">                    (q, new_s, epsilon=epsilon)</p><p class="source-code">            q[s, a] = q[s, a] + alpha \</p><p class="source-code">                      * (reward + gamma \</p><p class="source-code">                         * q[new_s, new_a] - q[s, a])</p><p class="source-code">            s = new_s</p><p class="source-code">            a = new_a</p></li>
				<li>Finally, estimate the agent's average performance:<p class="source-code">        if progress is not None and i%STEPS == 0:</p><p class="source-code">            progress[i//STEPS] = average_performance\</p><p class="source-code">                                 (get_action_epsilon_greedy\</p><p class="source-code">                                 (epsilon), q=q)</p><p class="source-code">    return q, progress</p><p>It may be useful to provide a brief description of the <strong class="source-inline">ε </strong>parameter's decrease. It is ruled by three parameters: starting value, minimum value, and decrease range. They are used in the following way: <strong class="source-inline">ε</strong> starts at the starting value, and then it is decreased linearly across the number of episodes defined by the parameter's "range" until it reaches the minimum value, which is then kept constant.</p></li>
				<li>Define an array that will collect all agent performance evaluations during training and the execution of SARSA TD(0) training:<p class="source-code">sarsa_performance = np.ndarray(nb_episodes//STEPS)</p><p class="source-code">q, sarsa_performance = sarsa(alpha = 0.02, gamma = 1,\</p><p class="source-code">                             progress=sarsa_performance, \</p><p class="source-code">                             epsilon_start=epsilon_param[0][0],\</p><p class="source-code">                             epsilon_end=epsilon_param[0][1], \</p><p class="source-code">                             epsilon_annealing_stop = \</p><p class="source-code">                             epsilon_param[0][2])</p></li>
				<li>Plot the SARSA agent's mean reward history during training:<p class="source-code">plt.plot(STEPS*np.arange(nb_episodes//STEPS), sarsa_performance)</p><p class="source-code">plt.xlabel("Epochs")</p><p class="source-code">plt.title("Learning progress for SARSA")</p><p class="source-code">plt.ylabel("Average reward of an epoch")</p><p>This generates the following output, showing the learning progress for the SARSA algorithm:</p><p class="source-code">Text(0, 0.5, 'Average reward of an epoch')</p><p>The plot will be as follows:</p><div id="_idContainer514" class="IMG---Figure"><img src="image/B16182_07_15.jpg" alt="Figure 7.15: Average reward of an epoch trend over training epochs&#13;&#10;"/></div><p class="figure-caption">Figure 7.15: Average reward of an epoch trend over training epochs</p><p>This plot clearly shows us how the performance of the SARSA algorithm improves over epochs, even when stochastic dynamics are considered. The sudden performance drop around 60k epochs is completely normal when dealing with methods in which random exploration plays a major role, and especially when random transition dynamics are part of the environment, as in this case.</p></li>
				<li>Evaluate the greedy policy's performance regarding the trained agent (Q-table):<p class="source-code">greedyPolicyAvgPerf = average_performance(greedy_policy, q=q)</p><p class="source-code">print("Greedy policy SARSA performance =", greedyPolicyAvgPerf)</p><p>The output will be as follows:</p><p class="source-code">Greedy policy SARSA performance = 0.75</p></li>
				<li>Display the Q-table values:<p class="source-code">q = np.round(q,3)</p><p class="source-code">print("(A,S) Value function =", q.shape)</p><p class="source-code">print("First row")</p><p class="source-code">print(q[0:4,:])</p><p class="source-code">print("Second row")</p><p class="source-code">print(q[4:8,:])</p><p class="source-code">print("Third row")</p><p class="source-code">print(q[8:12,:])</p><p class="source-code">print("Fourth row")</p><p class="source-code">print(q[12:16,:])</p><p>The following output will be generated:</p><p class="source-code">(A,S) Value function = (16, 4)</p><p class="source-code">First row</p><p class="source-code">[[0.829 0.781 0.785 0.785]</p><p class="source-code"> [0.416 0.394 0.347 0.816]</p><p class="source-code"> [0.522 0.521 0.511 0.813]</p><p class="source-code"> [0.376 0.327 0.378 0.811]]</p><p class="source-code">Second row</p><p class="source-code">[[0.83  0.552 0.568 0.549]</p><p class="source-code"> [0.    0.    0.    0.   ]</p><p class="source-code"> [0.32  0.195 0.535 0.142]</p><p class="source-code"> [0.    0.    0.    0.   ]]</p><p class="source-code">Third row</p><p class="source-code">[[0.55  0.59  0.546 0.831]</p><p class="source-code"> [0.557 0.83  0.441 0.506]</p><p class="source-code"> [0.776 0.56  0.397 0.342]</p><p class="source-code"> [0.    0.    0.    0.   ]]</p><p class="source-code">Fourth row</p><p class="source-code">[[0.    0.    0.    0.   ]</p><p class="source-code"> [0.528 0.619 0.886 0.506]</p><p class="source-code"> [0.814 0.943 0.877 0.844]</p><p class="source-code"> [0.    0.    0.    0.   ]]</p><p>This output shows the values of the complete state-action value function for our problem. These values are then used to generate the optimal policy by means of the greedy selection rule.</p></li>
				<li>Print out the greedy policy that was found and compare it with the optimal policy. Having calculated the state-action value function, we are able to retrieve the greedy policy from it. In fact, as explained previously, the greedy policy chooses the action that, for a given state, is associated with the maximum value of the Q-table. For this purpose, we are using the <strong class="source-inline">argmax</strong> function. When applied to each of the 16 states (from 0 to 15), it returns the index of the action that, among the four available (from 0 to 3), has the highest associated value for that state. Here, we also directly output the label associated with the action index using the pre-built dictionary:<p class="source-code">policyFound = [actionsDict[np.argmax(q[0,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[1,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[2,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[3,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[4,:])],\</p><p class="source-code">               "  -  ",\</p><p class="source-code">               actionsDict[np.argmax(q[6,:])],\</p><p class="source-code">               "  -  ",\</p><p class="source-code">               actionsDict[np.argmax(q[8,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[9,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[10,:])],\</p><p class="source-code">               "  -  ",\</p><p class="source-code">               "  -  ",\</p><p class="source-code">               actionsDict[np.argmax(q[13,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[14,:])],\</p><p class="source-code">               "  !  "]</p><p class="source-code">print("Greedy policy found:")</p><p class="source-code">idxs = [0,4,8,12]</p><p class="source-code">for idx in idxs:</p><p class="source-code">    print(policyFound[idx+0], policyFound[idx+1], \</p><p class="source-code">          policyFound[idx+2], policyFound[idx+3])</p><p class="source-code">print(" ")</p><p class="source-code">print("Optimal policy:")</p><p class="source-code">idxs = [0,4,8,12]</p><p class="source-code">for idx in idxs:</p><p class="source-code">    print(optimalPolicy[idx+0], optimalPolicy[idx+1], \</p><p class="source-code">          optimalPolicy[idx+2], optimalPolicy[idx+3])</p><p>The output will be as follows:</p><p class="source-code">Greedy policy found:</p><p class="source-code">    L    U    U    U</p><p class="source-code">    L    -    R    -</p><p class="source-code">    U    D    L    -</p><p class="source-code">    -    R    D    !</p><p class="source-code">Optimal policy:  </p><p class="source-code">  L/R/D  U    U    U</p><p class="source-code">    L    -   L/R   -</p><p class="source-code">    U    D    L    -</p><p class="source-code">    -    R    D    !</p></li>
			</ol>
			<p>As you can see, as in the previous exercise, our algorithm has been able to find the optimal policy by simply exploring the environment, and even in the context of stochastic environment transitions. As anticipated, for this setting, it is not possible to achieve the maximum reward 100% of the time. In fact, as we can see, for every state of the environment the greedy policy obtained with the Q-table that is calculated by our algorithm, it prescribes an action that is in accordance with the optimal policy that was defined by analyzing the environment problem. As we already saw, there are two states in which there are many different actions that are equally optimal, and the agent correctly implements one of them.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3eicsGr">https://packt.live/3eicsGr</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2Z4L1JV">https://packt.live/2Z4L1JV</a>.</p>
			<p>Now that we've become familiar with on-policy control, it is time for us to change track and look at off-policy control, an early breakthrough in reinforcement learning dating back to 1989 known as Q-learning.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Q-learning algorithm was first formulated by <em class="italic">Watkins in Mach Learn 8, 279–292 (1992)</em>. Here, we are presenting only an intuitive understanding, along with a brief mathematical description of it. For a much more detailed mathematical discussion, please refer to the original paper at <a href="https://link.springer.com/article/10.1007/BF00992698">https://link.springer.com/article/10.1007/BF00992698</a>.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor247"/>Q-Learning – Off-Policy Control</h2>
			<p>Q-learning is a name that identifies the family of off-policy control temporal difference algorithms. From a mathematical/implementation point of view, the only difference compared with on-policy algorithms is in the rule used to update the Q-table (or function for approximated methods), which is defined as follows:</p>
			<div>
				<div id="_idContainer515" class="IMG---Figure">
					<img src="image/B16182_07_16.jpg" alt="Figure 7.16: Function for approximated methods&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.16: Function for approximated methods</p>
			<p>The key point regards how the action for the next state, <img src="image/B16182_07_16a.png" alt="a"/><span class="subscript">,</span> is chosen. In fact, choosing the action with the maximum state-action value directly approximates what happens when the optimal Q value is found and the optimal policy is followed. Moreover, it is independent of the policy used to collect experience while interacting with the environment. The exploration policy can be entirely different to the optimal one; for example, it can be an ε-greedy policy to encourage exploration, and, under some easy-to-satisfy assumptions, it has been proven that Q converges to the optimal values. </p>
			<p>In <em class="italic">Chapter 9, What Is Deep Q-Learning?</em>, you will look at the extension of this approach to non-tabular methods where we use deep neural networks as function approximators. This method is called deep Q-learning. A scheme for the Q-learning control algorithm can be depicted as follows:</p>
			<ol>
				<li value="1">Choose the algorithm parameters: the step size, <img src="image/B16182_07_16b.png" alt="d"/>, which has to be contained in the interval (0, 1], and the <strong class="source-inline">ε</strong> parameter of the ε-greedy policy, which has to be small and greater than <strong class="source-inline">0</strong> since it represents the probability of choosing the non-optimal action in order to favor exploration:<p class="source-code">alpha = 0.02</p><p class="source-code">epsilon_expl = 0.2</p></li>
				<li>Initialize <img src="image/B16182_07_16c.png" alt="b"/>, for all <img src="image/B16182_07_16d.png" alt="c"/>, <img src="image/B16182_07_16e.png" alt="e"/>, arbitrarily, except that Q(terminal, *) = 0:<p class="source-code">q = np.ones((16, 4))</p><p class="source-code"># Set q(terminal,*) equal to 0</p><p class="source-code">q[5,:] = 0.0</p><p class="source-code">q[7,:] = 0.0</p><p class="source-code">q[11,:] = 0.0</p><p class="source-code">q[12,:] = 0.0</p><p class="source-code">q[15,:] = 0.0</p></li>
				<li>Create a loop among all episodes. In the loop, initialize <strong class="source-inline">s</strong>:<p class="source-code">for i in range(nb_episodes):</p><p class="source-code">    done = False</p><p class="source-code">    s = env.reset()</p></li>
				<li>Create a loop for each step of the episode. Within that loop, choose <img src="image/B16182_07_16f.png" alt="g"/> from <img src="image/B16182_07_16g.png" alt="f"/> using the policy derived from Q (for example, ε-greedy):<p class="source-code">    while not done:</p><p class="source-code">        # behavior policy</p><p class="source-code">        a = action_epsilon_greedy(q, s, epsilon=epsilon_expl)</p></li>
				<li>Taking action, <img src="image/B16182_07_16h.png" alt="h"/>, observe <img src="image/B16182_07_16i.png" alt="i"/>. Update the state-action value function for the selected state-action pair using the Q-learning rule, which defines the new value as the sum of the current one, plus the off-policy-specific TD error multiplied by the step size, <img src="image/B16182_07_16j.png" alt="j"/>. This can be expressed as follows:<div id="_idContainer526" class="IMG---Figure"><img src="image/B16182_07_17.jpg" alt="Figure 7.17: Expression for the updated state-action value function&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.17: Expression for the updated state-action value function</p>
			<p>The preceding explanation translates into code as follows:</p>
			<p class="source-code">        new_s, reward, done, info = env.step(a)</p>
			<p class="source-code">        a_max = np.argmax(q[new_s]) # estimation policy </p>
			<p class="source-code">        q[s, a] = q[s, a] + alpha \</p>
			<p class="source-code">                  * (reward + gamma \</p>
			<p class="source-code">                     * q[new_s, a_max] -q[s, a])</p>
			<p class="source-code">        s = new_s</p>
			<p>As we can see, we just substituted the random choice of the action to be taken on the new state with the action associated with the maximum q-value. This (apparently) minor change, which can be easily implemented by adapting the SARSA algorithm, has a relevant impact on the nature of the method. We'll see it at work in the following exercise. </p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor248"/>Exercise 7.03: Using TD(0) Q-Learning to Solve FrozenLake-v0 Deterministic Transitions</h2>
			<p>In this exercise, we'll implement the TD(0) Q-learning algorithm to solve the FrozenLake-v0 environment, where only deterministic transitions are allowed. In this exercise, we will consider the same task of retrieving the frisbee with the optimal policy we addressed in <em class="italic">Exercise 7.01, Using TD(0) SARSA to Solve FrozenLake-v0 Deterministic Transitions</em>, but this time, instead of using the SARSA algorithm (on-policy), we will implement Q-learning (off-policy). We will see how this algorithm behaves and train ourselves in implementing a new approach to estimate a q-value table by means of recovering an optimal policy for our agent.</p>
			<p>Follow these steps to complete this exercise:</p>
			<ol>
				<li value="1">Import the required modules, as follows:<p class="source-code">import numpy as np</p><p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">%matplotlib inline</p><p class="source-code">import gym</p></li>
				<li>Instantiate the <strong class="source-inline">gym</strong> environment called <strong class="source-inline">FrozenLake-v0</strong> using the <strong class="source-inline">is_slippery</strong> flag set to <strong class="source-inline">False</strong> in order to disable stochasticity:<p class="source-code">env = gym.make('FrozenLake-v0', is_slippery=False)</p></li>
				<li>Take a look at the action and the observation spaces:<p class="source-code">print("Action space = ", env.action_space)</p><p class="source-code">print("Observation space = ", env.observation_space)</p><p>The output will be as follows:</p><p class="source-code">Action space =  Discrete(4)</p><p class="source-code">Observation space =  Discrete(16)</p></li>
				<li>Create two dictionaries to easily translate the <strong class="source-inline">actions</strong> numbers into moves:<p class="source-code">actionsDict = {}</p><p class="source-code">actionsDict[0] = " L "</p><p class="source-code">actionsDict[1] = " D "</p><p class="source-code">actionsDict[2] = " R "</p><p class="source-code">actionsDict[3] = " U "</p><p class="source-code">actionsDictInv = {}</p><p class="source-code">actionsDictInv["L"] = 0</p><p class="source-code">actionsDictInv["D"] = 1</p><p class="source-code">actionsDictInv["R"] = 2</p><p class="source-code">actionsDictInv["U"] = 3</p></li>
				<li>Reset the environment and render it to take a look at the grid problem:<p class="source-code">env.reset()</p><p class="source-code">env.render()</p><p>The output will be as follows:</p><div id="_idContainer527" class="IMG---Figure"><img src="image/B16182_07_18.jpg" alt="Figure 7.18: Environment's initial state&#13;&#10;"/></div><p class="figure-caption">Figure 7.18: Environment's initial state</p></li>
				<li>Visualize the optimal policy for this environment:<p class="source-code">optimalPolicy = ["R/D"," R "," D "," L ",\</p><p class="source-code">                 " D "," - "," D "," - ",\</p><p class="source-code">                 " R ","R/D"," D "," - ",\</p><p class="source-code">                 " - "," R "," R "," ! ",]</p><p class="source-code">print("Optimal policy:")</p><p class="source-code">idxs = [0,4,8,12]</p><p class="source-code">for idx in idxs:</p><p class="source-code">    print(optimalPolicy[idx+0], optimalPolicy[idx+1], \</p><p class="source-code">          optimalPolicy[idx+2], optimalPolicy[idx+3])</p><p>The output will be as follows:</p><p class="source-code">Optimal policy:  </p><p class="source-code">R/D  R   D  L</p><p class="source-code"> D   -   D  -</p><p class="source-code"> R  R/D  D  -</p><p class="source-code"> -   R   R  !</p><p>This represents the optimal policy for this environment and shows, for each of the environment states represented in the 4x4 grid, the optimal action among the four available: move Up, move Down, move Right, and move Left. Except for two states, all the others have a single optimal action associated with them. In fact, as described previously, optimal actions here are those that bring the agent to the goal in the shortest possible path. Two different possibilities result in the same path length for two states, so they are both equally optimal.</p></li>
				<li>Next, define functions that will take ε-greedy actions:<p class="source-code">def action_epsilon_greedy(q, s, epsilon=0.05):</p><p class="source-code">    if np.random.rand() &gt; epsilon:</p><p class="source-code">        return np.argmax(q[s])</p><p class="source-code">    return np.random.randint(4)</p></li>
				<li>Define a function that will take greedy actions:<p class="source-code">def greedy_policy(q, s):</p><p class="source-code">    return np.argmax(q[s])</p></li>
				<li>Define a function that will calculate the mean of the agent's performance:<p class="source-code">def average_performance(policy_fct, q):</p><p class="source-code">    acc_returns = 0.</p><p class="source-code">    n = 500</p><p class="source-code">    for i in range(n):</p><p class="source-code">        done = False</p><p class="source-code">        s = env.reset()</p><p class="source-code">        while not done:</p><p class="source-code">            a = policy_fct(q, s)</p><p class="source-code">            s, reward, done, info = env.step(a)</p><p class="source-code">            acc_returns += reward</p><p class="source-code">    return acc_returns/n</p></li>
				<li>Initialize the Q-table so that all the values equal <strong class="source-inline">1</strong>, except for the values at terminal states:<p class="source-code">q = np.ones((16, 4))</p><p class="source-code"># Set q(terminal,*) equal to 0</p><p class="source-code">q[5,:] = 0.0</p><p class="source-code">q[7,:] = 0.0</p><p class="source-code">q[11,:] = 0.0</p><p class="source-code">q[12,:] = 0.0</p><p class="source-code">q[15,:] = 0.0</p></li>
				<li>Set the number of total episodes, the number of steps representing the interval by which we evaluate the agent's average performance, the learning rate, the discounting factor, and the <strong class="source-inline">ε</strong> value for the exploration policy and define an array to collect all agent performance evaluations during training:<p class="source-code">nb_episodes = 40000</p><p class="source-code">STEPS = 2000</p><p class="source-code">alpha = 0.02</p><p class="source-code">gamma = 0.9</p><p class="source-code">epsilon_expl = 0.2</p><p class="source-code">q_performance = np.ndarray(nb_episodes//STEPS)</p></li>
				<li>Train the agent using the Q-learning algorithm: the external loop takes care of generating the desired number of episodes. Then, the in-episode loop completes the following steps: first, it selects an exploration action with an ε-greedy policy, then the environment is stepped with the selected exploration action, and the <strong class="source-inline">new_s</strong>, <strong class="source-inline">reward</strong>, and <strong class="source-inline">done</strong> condition are retrieved. The new action for the new state is selected with the greedy policy, the Q-table is updated with the Q-learning TD(0) rule, and the state is updated with the new value. Every predefined number of steps, the agent's average performance is estimated:<p class="source-code">for i in range(nb_episodes):</p><p class="source-code">    done = False</p><p class="source-code">    s = env.reset()</p><p class="source-code">    while not done:</p><p class="source-code">        # behavior policy</p><p class="source-code">        a = action_epsilon_greedy(q, s, epsilon=epsilon_expl)</p><p class="source-code">        new_s, reward, done, info = env.step(a)</p><p class="source-code">        a_max = np.argmax(q[new_s]) # estimation policy </p><p class="source-code">        q[s, a] = q[s, a] + alpha \</p><p class="source-code">                  * (reward + gamma \</p><p class="source-code">                     * q[new_s, a_max] - q[s, a])</p><p class="source-code">        s = new_s</p><p class="source-code">    # for plotting the performance</p><p class="source-code">    if i%STEPS == 0:</p><p class="source-code">        q_performance[i//STEPS] = average_performance\</p><p class="source-code">                                  (greedy_policy, q)</p></li>
				<li>Plot the Q-learning agent's mean reward history during training:<p class="source-code">plt.plot(STEPS * np.arange(nb_episodes//STEPS), q_performance)</p><p class="source-code">plt.xlabel("Epochs")</p><p class="source-code">plt.ylabel("Average reward of an epoch")</p><p class="source-code">plt.title("Learning progress for Q-Learning")</p><p>This generates the following output, showing the learning progress of the Q-learning algorithm:</p><p class="source-code">Text(0.5, 1.0, 'Learning progress for Q-Learning')</p><p>The plot will be as follows:</p><div id="_idContainer528" class="IMG---Figure"><img src="image/B16182_07_19.jpg" alt="Figure 7.19: Average reward of an epoch trend over training epochs&#13;&#10;"/></div><p class="figure-caption">Figure 7.19: Average reward of an epoch trend over training epochs</p><p>As we can see, the plot shows how quickly Q-learning performance grows over epochs as the agent collects more and more experience. It also demonstrates that the algorithm is capable of reaching 100% success after learning. It's also evident how, in this case, compared to the SARSA method, the measured algorithm performance increases steadily and much faster.</p></li>
				<li>Evaluate the greedy policy's performance of the trained agent (Q-table):<p class="source-code">greedyPolicyAvgPerf = average_performance(greedy_policy, q=q)</p><p class="source-code">print("Greedy policy Q-learning performance =", \</p><p class="source-code">      greedyPolicyAvgPerf)</p><p>The output will be as follows:</p><p class="source-code">Greedy policy Q-learning performance = 1.0</p></li>
				<li>Display the Q-table values:<p class="source-code">q = np.round(q,3)</p><p class="source-code">print("(A,S) Value function =", q.shape)</p><p class="source-code">print("First row")</p><p class="source-code">print(q[0:4,:])</p><p class="source-code">print("Second row")</p><p class="source-code">print(q[4:8,:])</p><p class="source-code">print("Third row")</p><p class="source-code">print(q[8:12,:])</p><p class="source-code">print("Fourth row")</p><p class="source-code">print(q[12:16,:])</p><p>The following output will be generated:</p><p class="source-code">(A,S) Value function = (16, 4)</p><p class="source-code">First row</p><p class="source-code">[[0.531 0.59  0.59  0.531]</p><p class="source-code"> [0.617 0.372 0.656 0.628]</p><p class="source-code"> [0.672 0.729 0.694 0.697]</p><p class="source-code"> [0.703 0.695 0.703 0.703]]</p><p class="source-code">Second row</p><p class="source-code">[[0.59  0.656 0.    0.531]</p><p class="source-code"> [0.    0.    0.    0.   ]</p><p class="source-code"> [0.455 0.81  0.474 0.754]</p><p class="source-code"> [0.    0.    0.    0.   ]]</p><p class="source-code">Third row</p><p class="source-code">[[0.656 0.    0.729 0.59 ]</p><p class="source-code"> [0.656 0.81  0.81  0.   ]</p><p class="source-code"> [0.778 0.9   0.286 0.777]</p><p class="source-code"> [0.    0.    0.    0.   ]]</p><p class="source-code">Fourth row</p><p class="source-code">[[0.    0.    0.    0.   ]</p><p class="source-code"> [0.    0.81  0.9   0.729]</p><p class="source-code"> [0.81  0.9   1.    0.81 ]</p><p class="source-code"> [0.    0.    0.    0.   ]]</p><p>This output shows the values of the complete state-action value function for our problem. These values are then used to generate the optimal policy by means of the greedy selection rule.</p></li>
				<li>Print out the greedy policy that was found and compare it with the optimal policy:<p class="source-code">policyFound = [actionsDict[np.argmax(q[0,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[1,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[2,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[3,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[4,:])],\</p><p class="source-code">               " - ",\</p><p class="source-code">               actionsDict[np.argmax(q[6,:])],\</p><p class="source-code">               " - ",\</p><p class="source-code">               actionsDict[np.argmax(q[8,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[9,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[10,:])],\</p><p class="source-code">               " - ",\</p><p class="source-code">               " - ",\</p><p class="source-code">               actionsDict[np.argmax(q[13,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[14,:])],\</p><p class="source-code">               " ! "]</p><p class="source-code">print("Greedy policy found:")</p><p class="source-code">idxs = [0,4,8,12]</p><p class="source-code">for idx in idxs:</p><p class="source-code">    print(policyFound[idx+0], policyFound[idx+1], \</p><p class="source-code">          policyFound[idx+2], policyFound[idx+3])</p><p class="source-code">print(" ")</p><p class="source-code">print("Optimal policy:")</p><p class="source-code">idxs = [0,4,8,12]</p><p class="source-code">for idx in idxs:</p><p class="source-code">    print(optimalPolicy[idx+0], optimalPolicy[idx+1], \</p><p class="source-code">          optimalPolicy[idx+2], optimalPolicy[idx+3])</p><p>The output will be as follows:</p><p class="source-code">Greedy policy found: </p><p class="source-code"> D   R   D  L</p><p class="source-code"> D   -   D  -</p><p class="source-code"> R   D   D  -</p><p class="source-code"> -   R   R  !  </p><p class="source-code">Optimal policy:  </p><p class="source-code">R/D  R   D  L</p><p class="source-code"> D   -   D  -</p><p class="source-code"> R  R/D  D  -</p><p class="source-code"> -   R   R  !</p></li>
			</ol>
			<p>As these outputs demonstrate, the Q-learning algorithm has been able to retrieve the optimal policy too, just like SARSA did in <em class="italic">Exercise 07.01, Using TD(0) SARSA to solve FrozenLake-v0 Deterministic Transitions</em>, only by means of experience and interaction with the environment. </p>
			<p>As we can see, for every state of the grid world the greedy policy obtained with the Q-table calculated by our algorithm, this prescribes an action that is in accordance with the optimal policy that was defined by analyzing the environment problem. As we already saw, there are two states in which there are many different actions that are equally optimal, and the agent correctly implements one of them.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2AUlzym">https://packt.live/2AUlzym</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fJCnH5">https://packt.live/3fJCnH5</a>.</p>
			<p>As for SARSA, it would be interesting to see how Q-learning behaves if we turn on stochastic transitions. This will be the goal of the activity at the end of this chapter. The procedure that the two algorithms follow is the very same one we adopted with SARSA: the same Q-learning algorithm used for the deterministic transition case is applied, and you are expected to adapt hyperparameters (especially the discount factor and the number of episodes) until you obtain convergence to the optimal policy under the stochastic transition dynamics.</p>
			<p>To complete the landscape of TD(0) algorithms, we will introduce another specific approach that's obtained by applying very simple modifications of the previous ones: Expected SARSA.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor249"/>Expected SARSA</h2>
			<p>Now, let's consider a learning algorithm that is quite similar to Q-learning, with the only difference being the substitution of the maximum over next state-action pairs with the expected value. This is computed by taking into account the probability of each action under the current policy. This modified algorithm can be represented by the following update rule:</p>
			<div>
				<div id="_idContainer529" class="IMG---Figure">
					<img src="image/B16182_07_20.jpg" alt="Figure 7.20: State-action value function update rule&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.20: State-action value function update rule</p>
			<p>The additional computational complexity with respect to SARSA provides the advantage of eliminating variance due to the random selection of <strong class="source-inline">A</strong><span class="subscript">t+1</span>, which is a very powerful trick for improving learning and robustness considerably. It can be used both in an on-policy and off-policy fashion, thus becoming an abstraction of both SARSA and Q-learning with, in general, a performance that dominates both of them. An example of the update rule's implementation is provided in the following snippet:</p>
			<p class="source-code">q[s, a] = q[s, a] + alpha * (reward + gamma * </p>
			<p class="source-code">    (np.dot(pi[new_s, :],q[new_s, :]) - q[s, a])</p>
			<p>In the preceding code, the <strong class="source-inline">pi</strong> variable contains all the probabilities for each action in each state. The dot product involving <strong class="source-inline">pi</strong> and <strong class="source-inline">q</strong> is the operation needed to compute the expected value for the new state, taking into account all the actions for that state with their respective probabilities.</p>
			<p>Now that we've studied the TD(0) methods, let's start learning about the N-step TD and TD(λ) algorithms.</p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor250"/>N-Step TD and TD(λ) Algorithms</h1>
			<p>In the previous chapter, we looked at Monte Carlo methods, while in the previous sections of this chapter, we learned about TD(0) ones, which, as we will discover soon, are also known as one-step temporal difference methods. In this section, we'll unify them: in fact, they are at the extreme of a spectrum of algorithms (TD(0) on one side, with MC methods at the other end), and often, the best performing methods are somewhere in the middle of this spectrum. </p>
			<p>N-step temporal difference algorithms extend one-step TD methods. More specifically, they generalize Monte Carlo and TD approaches, making it possible to smoothly transition between the two. As we already saw, MC methods must wait until the episode finishes to back the reward up into the previous states. One-step TD methods, on the other hand, make direct use of the first available future step to bootstrap and start updating the value function of states or state-action pairs. These extremes are rarely the optimal choices. The optimal choices generally fall in the middle of this broad range. Using N-step methods allows us to adjust the number of steps to consider when updating the value function, thereby distributing the bootstrapping approach to multiple steps.</p>
			<p>A similar notion can be recalled in the context of eligibility traces, but they are more general, allowing us to distribute and spread bootstrapping over multiple time intervals at the same time. These two topics will be treated separately for clarity and, so as to enable you to build your knowledge incrementally, we will start with N-step methods first, before moving on to eligibility traces.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor251"/>N-Step TD</h2>
			<p>As we have already seen for one-step TD methods, the first step to approaching the N-step method is to focus on the estimation of the state-value function for sample episodes generated using the policy, <img src="image/B16182_07_20a.png" alt="a"/>. We already recalled that the Monte Carlo algorithm must wait until the end of an episode before performing an update by using the entire sequence of rewards from a given state. On the other hand, one-step methods just need the next reward. N-step methods use an intermediate rule: instead of relying on just the next reward, or on all future rewards until the episode ends, they use a value in between these two. For example, a three-steps update would use the first three rewards and the estimated state value reached three steps ahead. This can be formalized for a generic number of steps.</p>
			<p>This approach gives birth to a family of methods that are still temporal difference ones since they use the N-steps that were encountered after the target state to update its value. It is clear that the methods that we encountered at the beginning of this chapter are a special case of N-step methods. For this reason, they are called "one-step TD methods."</p>
			<p>In order to define them more formally, we can consider the estimated value of the state, <img src="image/B16182_07_20b.png" alt="a"/> as a result of the state-reward sequence, <img src="image/B16182_07_20c.png" alt="b"/>, <img src="image/B16182_07_20d.png" alt="c"/>, <img src="image/B16182_07_20e.png" alt="d"/>, <img src="image/B16182_07_20f.png" alt="e"/>, ..., <img src="image/B16182_07_20g.png" alt="f"/>, <img src="image/B16182_07_20h.png" alt="g"/> (except the actions). In MC methods, this estimate is updated only once the episode is complete, and in one-step methods, right after the next step. In N-step methods, on the other hand, the state-value estimate is updated after N-steps using a quantity that discounts <strong class="source-inline">n</strong> future rewards and the value of the state encountered after N-steps in the future. This quantity, called N-step return, can be defined in an expression, as follows:</p>
			<div>
				<div id="_idContainer538" class="IMG---Figure">
					<img src="image/B16182_07_21.jpg" alt="Figure 7.21: N-step return equation (with the state-value function)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.21: N-step return equation (with the state-value function)</p>
			<p>A key point to note here is that in order to calculate this N-step return, we have to wait to reach the time <strong class="source-inline">t+1</strong> so that all the terms in the equation are available. By using the N-step return, it is straightforward to formalize the state-value function update rule, as follows:</p>
			<div>
				<div id="_idContainer539" class="IMG---Figure">
					<img src="image/B16182_07_22.jpg" alt="Figure 7.22: Expression for the natural state-value learning algorithm &#13;&#10;for using N-step returns&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.22: Expression for the natural state-value learning algorithm for using N-step returns</p>
			<p>Note that the values of all the other states remain unchanged, as shown in the following expression: </p>
			<div>
				<div id="_idContainer540" class="IMG---Figure">
					<img src="image/B16182_07_23.jpg" alt="Figure 7.23: Expression specifying that all the other values are kept constant&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.23: Expression specifying that all the other values are kept constant</p>
			<p>This is the equation that formalizes the N-step TD algorithm. It is worth noting again that no changes are made during the first <strong class="source-inline">n-1</strong> steps before we can estimate the N-step return. This needs to be compensated for at the end of the episode, when the remaining <strong class="source-inline">n-1</strong> updates are performed all at once after reaching the terminal state.</p>
			<p>Similar to what we already saw for TD(0) methods, and without talking about this in too much data, the state-value function estimation of the N-step TD methods converges to the optimal value under appropriate technical conditions.</p>
			<h3 id="_idParaDest-212"><a id="_idTextAnchor252"/>N-step SARSA</h3>
			<p>It is quite straightforward to extend the SARSA algorithm, which we looked at when we introduced one-step methods, to its N-step version. As we did previously, the only thing we need to do is substitute the state-action pairs for states in the value function's N-step return and in the update formulations just seen, coupling them with an ε-greedy policy. The definition of the N-step return (update targets) can be described by the following equation:</p>
			<div>
				<div id="_idContainer541" class="IMG---Figure">
					<img src="image/B16182_07_24.jpg" alt="Figure 7.24: N-step return equation (with the state-action value function)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.24: N-step return equation (with the state-action value function)</p>
			<p>Here, <img src="image/B16182_07_24a.png" alt="a"/> if <img src="image/B16182_07_24b.png" alt="b"/>. The update rule for the state-action value function is expressed as follows:</p>
			<div>
				<div id="_idContainer544" class="IMG---Figure">
					<img src="image/B16182_07_25.jpg" alt="Figure 7.25: Update rule for the state-action value function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.25: Update rule for the state-action value function</p>
			<p>Note that the values of all the other state-action pairs remain unchanged: <img src="image/B16182_07_25a.png" alt="c"/>, for all values of <strong class="source-inline">s</strong>, so that <img src="image/B16182_07_25b.png" alt="d"/> or <img src="image/B16182_07_25c.png" alt="e"/>. A scheme for the N-step SARSA control algorithm can be depicted as follows:</p>
			<ol>
				<li value="1">Choose the algorithm's parameters: the step size, <img src="image/B16182_07_25d.png" alt="f"/>, which has to be contained in the interval (0, 1], and the <strong class="source-inline">ε</strong> parameter of the ε-greedy policy, which has to be small and greater than <strong class="source-inline">0</strong> since it represents the probability of choosing the non-optimal action to favor exploration. A value for the number of steps, <strong class="source-inline">n</strong>, has to be chosen. This can be done, for example, with the following code:<p class="source-code">alpha = 0.02</p><p class="source-code">n = 4</p><p class="source-code">epsilon = 0.05</p></li>
				<li>Initialize <img src="image/B16182_07_25e.png" alt="g"/>, for all <img src="image/B16182_07_25f.png" alt="h"/>, <img src="image/B16182_07_25g.png" alt="i"/>, arbitrarily, except that Q(terminal, ·) = 0:<p class="source-code">q = np.ones((16,4))</p></li>
				<li>Create a loop for each episode. Initialize and store the S0 ≠ terminal. Select and store an action using the ε-greedy policy and initialize time, <strong class="source-inline">T</strong>, as a very high value:<p class="source-code">for i in range(nb_episodes):</p><p class="source-code">        s = env.reset()</p><p class="source-code">        a = action_epsilon_greedy(q, s, epsilon=epsilon)</p><p class="source-code">        T = 1e6</p></li>
				<li>Create a loop for t = 0, 1, 2, .... If t &lt; T, then perform action <img src="image/B16182_07_25h.png" alt="j"/>. Observe and store the next reward as <img src="image/B16182_07_25i.png" alt="k"/> and the next state as <img src="image/B16182_07_25j.png" alt="l"/><span class="subscript"> </span>If <img src="image/B16182_07_25k.png" alt="m"/> is terminal, then set <strong class="source-inline">T</strong> equal to <strong class="source-inline">t+1</strong>:<p class="source-code">while True:</p><p class="source-code">            new_s, reward, done, info = env.step(a)</p><p class="source-code">            if done:</p><p class="source-code">                T = t+1</p></li>
				<li>If <img src="image/B16182_07_25l.png" alt="n"/> is not terminal, select and store a new action for the new state:<p class="source-code">        new_a = action_epsilon_greedy(q, new_s, epsilon=epsilon)</p></li>
				<li>Define the time for which the estimate is being updated, <strong class="source-inline">tau</strong>, equal to <strong class="source-inline">t-n+1</strong>:<p class="source-code">tau = t-n+1</p></li>
				<li>If <strong class="source-inline">tau</strong> is greater than 0, calculate the N-step return by summing the discounted returns of the previous n steps and adding the discounted value of the next step-next action pair and update the state-action value function:<p class="source-code">G = sum_n(q, tau, T, t, gamma, R, new_s, new_a)</p><p class="source-code">q[s, a] = q[s, a] + alpha * (G- q[s, a]) </p></li>
			</ol>
			<p>With a few minor changes, this can easily be extended to accommodate Expected SARSA as well. As seen previously in this chapter, it only requires us to substitute the expected approximate value of the state using the estimated action values at time, t, under the target policy at the last step of the N-steps. When the state in question is terminal, its expected approximate value is defined as 0.</p>
			<h3 id="_idParaDest-213"><a id="_idTextAnchor253"/>N-Step Off-Policy Learning</h3>
			<p>To define off-policy learning for N-step methods, we will be taking very similar steps as the ones we did for one-step methods. The key point is that, as in all off-policy methods, we are learning the value function for a policy, <img src="image/B16182_07_25m.png" alt="a"/>, while following a different exploration policy; say, <strong class="source-inline">b</strong>. Typically, <img src="image/B16182_07_25n.png" alt="b"/> is the greedy policy for the current state-action value function estimate, and b has more randomness so that it effectively explores the environment; for example, ε-greedy. The main difference with respect to what we already saw for one-step off-policy methods is that now, we need to take into account the fact that we are selecting actions using a different policy than the one we want to learn, and we are doing it for more than one step. So, we need to properly weigh the selected actions measuring the relative probability under the two policies of taking those actions.</p>
			<p>By means of this correction, it is possible to define the rule for a simple off-policy version of N-step TD: the update for time <strong class="source-inline">t</strong> (actually made at time <strong class="source-inline">t + n</strong>) can simply be weighted by <img src="image/B16182_07_25o.png" alt="c"/>:</p>
			<div>
				<div id="_idContainer560" class="IMG---Figure">
					<img src="image/B16182_07_26.jpg" alt="Figure 7.26: N-step TD off-policy update rule at time 't'&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.26: N-step TD off-policy update rule at time 't'</p>
			<p>Here, <strong class="source-inline">V</strong> is the value function, <img src="image/B16182_07_26a.png" alt="e"/> is the step size, <strong class="source-inline">G</strong> is the N-step return, and <img src="image/B16182_07_26b.png" alt="d"/> is called the importance sampling ratio. The importance sampling ratio is the relative probability under the two policies of taking <strong class="source-inline">n</strong> actions from <img src="image/B16182_07_26c.png" alt="f"/> to <img src="image/B16182_07_26d.png" alt="f"/>, which can be expressed as follows: </p>
			<div>
				<div id="_idContainer565" class="IMG---Figure">
					<img src="image/B16182_07_27.jpg" alt="Figure 7.27: Sampling ratio equation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.27: Sampling ratio equation</p>
			<p>Here, <img src="image/B16182_07_27a.png" alt="i"/> is the agent policy, <img src="image/B16182_07_27b.png" alt="g"/> is the exploration policy, <img src="image/B16182_07_27c.png" alt="h"/> is the action, and <img src="image/B16182_07_27d.png" alt="h"/> is the state.</p>
			<p>By this definition, it is evident that actions that would never be selected under the policy we want to learn (that is, their probability is <strong class="source-inline">0</strong>) would be ignored (weight equal to 0). If, on the other hand, an action under the policy we are learning has more probability with respect to the exploratory policy, the weight assigned to it should be higher than <strong class="source-inline">1</strong> since it will be encountered more often. It is also evident that for the on-policy case, the sampling ratio is always equal to <strong class="source-inline">1</strong>, given the fact that <img src="image/B16182_07_27e.png" alt="b"/> and <img src="image/B16182_07_27f.png" alt="b"/> are the same policy. For this reason, the N-step SARSA on-policy update can be seen as a special case of the off-policy update. The general form of the update, from which it is possible to derive both on-policy and off-policy methods, is as follows:</p>
			<div>
				<div id="_idContainer572" class="IMG---Figure">
					<img src="image/B16182_07_28.jpg" alt="Figure 7.28: State-action value function for the off-policy N-step TD algorithm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.28: State-action value function for the off-policy N-step TD algorithm</p>
			<p>As you can see, <img src="image/B16182_07_28a.png" alt="a"/> is the state-action value function, <img src="image/B16182_07_28b.png" alt="b"/> is the step size, <img src="image/B16182_07_28c.png" alt="c"/> is the N-step return, and <img src="image/B16182_07_28d.png" alt="d"/> is the importance sampling ratio. The scheme for the full algorithm is as follows:</p>
			<ol>
				<li value="1">Select an arbitrary behavior policy, <img src="image/B16182_07_28e.png" alt="e"/>, so that the probability for each action of each state is greater than 0 for all states and actions. Choose the algorithm parameters: the step size, <img src="image/B16182_07_28f.png" alt="f"/>, which has to be contained in the interval (0, 1], and a value for the number of steps, <strong class="source-inline">n</strong>. This can be done, for example, with the following code:<p class="source-code">alpha = 0.02</p><p class="source-code">n = 4</p></li>
				<li>Initialize <img src="image/B16182_07_28g.png" alt="h"/>, for all <img src="image/B16182_07_28h.png" alt="g"/>, <img src="image/B16182_07_28i.png" alt="h"/>, arbitrarily, except that Q(terminal, ·) = 0:<p class="source-code">q = np.ones((16,4))</p></li>
				<li>Initialize the policy, <img src="image/B16182_07_28j.png" alt="i"/>, to be greedy with respect to Q, or to a fixed given policy. Create a loop for each episode. Initialize and store the S<span class="subscript">0</span> ≠ terminal. Select and store an action using the b policy and initialize time, <strong class="source-inline">T</strong>, as a very high value:<p class="source-code">for i in range(nb_episodes):</p><p class="source-code">        s = env.reset()</p><p class="source-code">        a = action_b_policy(q, s)</p><p class="source-code">        T = 1e6</p></li>
				<li>Create a loop for t = 0, 1, 2, .... If t &lt; T, then perform action <img src="image/B16182_07_28k.png" alt="k"/>. Observe and store the next reward as <img src="image/B16182_07_28l.png" alt="j"/> and the next state as <img src="image/B16182_07_28m.png" alt="l"/> <span class="subscript">. </span>If <img src="image/B16182_07_28n.png" alt="m"/> is terminal, then set <strong class="source-inline">T</strong> equal to <strong class="source-inline">t+1</strong>:<p class="source-code">while True:</p><p class="source-code">            new_s, reward, done, info = env.step(a)</p><p class="source-code">            if done:</p><p class="source-code">                T = t+1</p></li>
				<li>If <img src="image/B16182_07_28o.png" alt="m"/> is not terminal, select and store a new action for the new state:<p class="source-code">        new_a = action_b_policy(q, new_s)</p></li>
				<li>Define the time for which the estimate is being updated, <strong class="source-inline">tau</strong>, equal to <strong class="source-inline">t-n+1</strong>:<p class="source-code">tau = t-n+1</p></li>
				<li>If <strong class="source-inline">tau</strong> is greater than or equal to <strong class="source-inline">0</strong>, calculate the sampling ratio. Calculate the N-step return by summing the discounted returns of the previous n steps and adding the discounted value of the next step-next action pair and update the state-action value function:<p class="source-code">rho = product_n(q, tau, T, t, R, new_s, new_a)</p><p class="source-code">G = sum_n(q, tau, T, t, gamma, R, new_s, new_a)</p><p class="source-code">q[s, a] = q[s, a] + alpha * rho * (G- q[s, a]) </p></li>
			</ol>
			<p>Now that we've studied the N-step methods, it is time to proceed to the most general and most performant declination of temporal difference methods, TD(λ).</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor254"/>TD(λ)</h2>
			<p>The popular TD(λ) algorithm is a temporal difference algorithm that makes use of the eligibility trace concept, which, as we will soon see, is a procedure that allows us to appropriately weight contributions to the state's (or state-action pair's) value function using any possible number of steps. The <strong class="source-inline">lambda</strong> term introduced in the name is a parameter that defines and parameterizes this family of algorithms. As we will see shortly, it is a weighting factor that will allow us to appropriately weight different contributing terms involved in the estimation of the algorithm's return. </p>
			<p>It is possible to combine any temporal difference method, such as those we already saw (Q-learning and SARSA), with the eligibility traces concept, which we will implement shortly. This allows us to obtain a more general method, which is also more efficient. This approach, as we already anticipated previously, realizes the final unification and generalization of the TD and Monte Carlo methods. Similarly, regarding what we observed for N-step TD methods, in this case also, we have one-step TD methods on one extreme (<strong class="source-inline">λ = 0</strong>) and Monte Carlo methods on the other (<strong class="source-inline">λ = 1</strong>). The space between these two boundaries contains intermediate methods (as is the case for N-step methods with finite <strong class="source-inline">n &gt; 1</strong>). In addition to that, eligibility traces allow us to use extended Monte Carlo methods for the so-called online implementation, meaning they become applicable to non-episodic problems.</p>
			<p>With respect to what we already saw for N-step TD methods, eligibility traces have an additional advantage, allowing us to generalize these families with significant computational improvement. As we mentioned earlier, choosing the correct value of n for N-step methods can be anything but a straightforward task. Eligibility traces, on the other hand, allow us to "fuse" together the updates corresponding to different timesteps. </p>
			<p>To achieve this goal, we need to define a method to weigh the N-step return, <img src="image/B16182_07_28p.png" alt="c"/>, using a weight that decays exponentially with time. This is done by introducing a factor, <img src="image/B16182_07_28q.png" alt="d"/>, and weighting the n<span class="superscript">th</span> return with <img src="image/B16182_07_28r.png" alt="b"/>. </p>
			<p>The goal is to define a weighted average so that all these weights must total to <strong class="source-inline">1</strong>. The normalization constant is the limit value of the convergent geometric series: <img src="image/B16182_07_28s.png" alt="a"/>. With this, we can define the so-called <img src="image/B16182_07_28t.png" alt="a"/>-return as follows:</p>
			<div>
				<div id="_idContainer593" class="IMG---Figure">
					<img src="image/B16182_07_29.jpg" alt="Figure 7.29: Expression for the lambda return&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.29: Expression for the lambda return</p>
			<p>This equation defines how our choice of <img src="image/B16182_07_29a.png" alt="a"/> influences the speed at which a given return drops exponentially as a function of the number of steps.</p>
			<p>We can now use this new return as a target for the state (or state-action pair) value function, thus creating a new value function update rule. It may seem that, at this point, in order to consider all contributes, we should wait until the end of the episode, thus collecting all future returns. This problem is solved by means of the second fundamental novelty introduced by eligibility traces: instead of looking forward in time, the point of view is reversed, and the agent updates all states (state-action pairs) visited in the past according to the eligibility traces rule and using current return and values information.</p>
			<p>The eligibility trace is initialized equal to 0 for every state (or state-action pair), is incremented on each time step with a value equal to 1 for the state (or state-action pair), visited so that it gives it the highest weight in contributing to the value function update, and fades away by the <img src="image/B16182_07_29b.png" alt="b"/> factor. This factor is the combination of decay in time that's typical of eligibility traces, as explained previously (<img src="image/B16182_07_29c.png" alt="b"/>), and the familiar reward discount <img src="image/B16182_07_29d.png" alt="c"/> we've encountered many times in this chapter. With this new concept, we can now build the new value function update. First, we have the equation that regulates the eligibility trace evolution:</p>
			<div>
				<div id="_idContainer598" class="IMG---Figure">
					<img src="image/B16182_07_30.jpg" alt="Figure 7.30: Eligibility traces initialization and update rule at time 't' (for states)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.30: Eligibility traces initialization and update rule at time 't' (for states)</p>
			<p>Then, we have the new definition of the TD error (or δ). The state-value function update will be as follows:</p>
			<div>
				<div id="_idContainer599" class="IMG---Figure">
					<img src="image/B16182_07_31.jpg" alt="Figure 7.31: State-value function update rule using eligibility traces&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.31: State-value function update rule using eligibility traces</p>
			<p>Now, let's see how this idea is implemented in the SARSA algorithm to obtain an on-policy TD control algorithm with eligibility traces.</p>
			<h3 id="_idParaDest-215"><a id="_idTextAnchor255"/>SARSA(λ)</h3>
			<p>Directly translating a state-value update into a state-action-value update allows us to add the eligibility traces feature to our previously seen SARSA algorithm. The eligibility trace equation can be modified as follows:</p>
			<div>
				<div id="_idContainer600" class="IMG---Figure">
					<img src="image/B16182_07_32.jpg" alt="Figure 7.32: Eligibility trace initialization and update rule at time 't' (for state-actions pairs)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.32: Eligibility trace initialization and update rule at time 't' (for state-actions pairs)</p>
			<p>The TD error and the state-action value function updates are written as follows:</p>
			<div>
				<div id="_idContainer601" class="IMG---Figure">
					<img src="image/B16182_07_33.jpg" alt="Figure 7.33: State-action pair's value function update rule using eligibility traces&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.33: State-action pair's value function update rule using eligibility traces</p>
			<p>A schema that perfectly summarizes all these steps and presents the complete algorithm is as follows:</p>
			<ol>
				<li value="1">Choose the algorithm's parameters: the step size <img src="image/B16182_07_33a.png" alt="a"/>, which has to be contained in the interval (0, 1], and the <strong class="source-inline">ε</strong> parameter of the ε-greedy policy, which has to be small and greater than 0, since it represents the probability of choosing the non-optimal action, to favor exploration. A value for the <strong class="source-inline">lambda</strong> parameter has to be chosen. This can be done, for example, with the following code:<p class="source-code">alpha = 0.02</p><p class="source-code">lambda = 0.3</p><p class="source-code">epsilon = 0.05</p></li>
				<li>Initialize <img src="image/B16182_07_33b.png" alt="a"/>, for all <img src="image/B16182_07_33c.png" alt="b"/>, <img src="image/B16182_07_33d.png" alt="c"/>, arbitrarily, except that Q(terminal, ·) = 0:<p class="source-code">q = np.ones((16,4))</p></li>
				<li>Create a loop for each episode. Initialize the eligibility traces table to <strong class="source-inline">0</strong>:<p class="source-code">E = np.zeros((16, 4))</p></li>
				<li>Initialize the state as it is not terminal and select an action using the ε-greedy policy. Then, initiate the in-episode loop:<p class="source-code">    state = env.reset()</p><p class="source-code">    action = action_epsilon_greedy(q, state, epsilon)</p><p class="source-code">    while True:</p></li>
				<li>Create a loop for each step of the episode, update the eligibility traces, and assign a value equal to <strong class="source-inline">1</strong> to the last visited state:<p class="source-code">        E = eligibility_decay * gamma * E </p><p class="source-code">        E[state, action] += 1</p></li>
				<li>Step through the environment and choose the next action using the ε-greedy policy:<p class="source-code">        new_state, reward, done, info = env.step(action)</p><p class="source-code">        new_action = action_epsilon_greedy\</p><p class="source-code">                     (q, new_state, epsilon)</p></li>
				<li>Calculate the <img src="image/B16182_07_33e.png" alt="b"/> update and update the Q-table using the SARSA TD(<img src="image/B16182_07_33f.png" alt="a"/>) rule:<p class="source-code">        delta = reward + gamma \</p><p class="source-code">                * q[new_state, new_action] - q[state, action]</p><p class="source-code">        q = q + alpha * delta * E </p></li>
				<li>Update the state and action with new state and action values:<p class="source-code">        state, action = new_state, new_action</p><p class="source-code">        if done:</p><p class="source-code">            break</p></li>
			</ol>
			<p>We are now ready to test this new algorithm on the environment we already solved with one-step SARSA and Q-learning.</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor256"/>Exercise 7.04: Using TD(λ) SARSA to Solve FrozenLake-v0 Deterministic Transitions</h2>
			<p>In this exercise, we will implement our SARSA(λ) algorithm to solve the FrozenLake-v0 environment under the deterministic environment dynamics. In this exercise, we will consider the same task we addressed in <em class="italic">Exercise 7.01, Using TD(0) SARSA to Solve FrozenLake-v0 Deterministic Transitions</em>, and <em class="italic">Exercise 7.03, Using TD(0) Q-Learning to Solve FrozenLake-v0 Deterministic Transitions</em>, but this time, instead of using one-step TD methods such as SARSA (on-policy) and Q-learning (off-policy), we will implement TD(λ), a temporal difference method coupled with the power of eligibility traces. We will see how this algorithm behaves and train ourselves in implementing a new approach to estimate a Q-value table by means of which we'll recover an optimal policy for our agent.</p>
			<p>Follow these steps to complete this exercise:</p>
			<ol>
				<li value="1">Import the required modules:<p class="source-code">import numpy as np</p><p class="source-code">from numpy.random import random, choice</p><p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">%matplotlib inline</p><p class="source-code">import gym</p></li>
				<li>Instantiate the <strong class="source-inline">gym</strong> environment called <strong class="source-inline">FrozenLake-v0</strong> using the <strong class="source-inline">is_slippery</strong> flag set to <strong class="source-inline">False</strong> in order to disable stochasticity:<p class="source-code">env = gym.make('FrozenLake-v0', is_slippery=False)</p></li>
				<li>Take a look at the action and the observation spaces:<p class="source-code">print("Action space = ", env.action_space)</p><p class="source-code">print("Observation space = ", env.observation_space)</p><p>The output will be as follows:</p><p class="source-code">Action space =  Discrete(4)</p><p class="source-code">Observation space =  Discrete(16)</p></li>
				<li>Create two dictionaries to easily translate the <strong class="source-inline">actions</strong> numbers into moves:<p class="source-code">actionsDict = {}</p><p class="source-code">actionsDict[0] = " L "</p><p class="source-code">actionsDict[1] = " D "</p><p class="source-code">actionsDict[2] = " R "</p><p class="source-code">actionsDict[3] = " U "</p><p class="source-code">actionsDictInv = {}</p><p class="source-code">actionsDictInv["L"] = 0</p><p class="source-code">actionsDictInv["D"] = 1</p><p class="source-code">actionsDictInv["R"] = 2</p><p class="source-code">actionsDictInv["U"] = 3</p></li>
				<li>Reset the environment and render it to take a look at the grid:<p class="source-code">env.reset()</p><p class="source-code">env.render()</p><p>The output will be as follows:</p><div id="_idContainer608" class="IMG---Figure"><img src="image/B16182_07_34.jpg" alt="Figure 7.34: Environment's initial state &#13;&#10;"/></div><p class="figure-caption">Figure 7.34: Environment's initial state </p></li>
				<li>Visualize the optimal policy for this environment:<p class="source-code">optimalPolicy = ["R/D"," R "," D "," L ",\</p><p class="source-code">                 " D "," - "," D "," - ",\</p><p class="source-code">                 " R ","R/D"," D "," - ",\</p><p class="source-code">                 " - "," R "," R "," ! ",]</p><p class="source-code">print("Optimal policy:")</p><p class="source-code">idxs = [0,4,8,12]</p><p class="source-code">for idx in idxs:</p><p class="source-code">    print(optimalPolicy[idx+0], optimalPolicy[idx+1], \</p><p class="source-code">          optimalPolicy[idx+2], optimalPolicy[idx+3])</p><p>The output will be printed as follows:</p><p class="source-code">Optimal policy:  </p><p class="source-code">R/D  R   D  L</p><p class="source-code"> D   -   D  -</p><p class="source-code"> R  R/D  D  -</p><p class="source-code"> -   R   R  !</p><p>This is the optimal policy for the deterministic case we already encountered when dealing with one-step TD methods. It shows the optimal actions we hope our agent will learn within this environment.</p></li>
				<li>Define the functions that will take ε-greedy actions:<p class="source-code">def action_epsilon_greedy(q, s, epsilon=0.05):</p><p class="source-code">    if np.random.rand() &gt; epsilon:</p><p class="source-code">        return np.argmax(q[s])</p><p class="source-code">    return np.random.randint(4)</p><p class="source-code">def get_action_epsilon_greedy(epsilon):</p><p class="source-code">    return lambda q,s: action_epsilon_greedy\</p><p class="source-code">                       (q, s, epsilon=epsilon)</p></li>
				<li>Define a function that will take greedy actions:<p class="source-code">def greedy_policy(q, s):</p><p class="source-code">    return np.argmax(q[s])</p></li>
				<li>Define a function that will calculate the agent's average performance:<p class="source-code">def average_performance(policy_fct, q):</p><p class="source-code">    acc_returns = 0.</p><p class="source-code">    n = 500</p><p class="source-code">    for i in range(n):</p><p class="source-code">        done = False</p><p class="source-code">        s = env.reset()</p><p class="source-code">        while not done:</p><p class="source-code">            a = policy_fct(q, s)</p><p class="source-code">            s, reward, done, info = env.step(a)</p><p class="source-code">            acc_returns += reward</p><p class="source-code">    return acc_returns/n</p></li>
				<li>Set the number of total episodes, the number of steps representing the interval by which we evaluate the agent's average performance, the discount factor, the learning rate, and the <strong class="source-inline">ε</strong> parameters ruling its decrease – the starting value, minimum value, and range (in terms of the number of episodes) – over which the decrease is spread, as well as the eligibility trace's decay parameter:<p class="source-code"># parameters for sarsa(lambda)</p><p class="source-code">episodes = 30000</p><p class="source-code">STEPS = 500</p><p class="source-code">gamma = 0.9</p><p class="source-code">alpha = 0.05</p><p class="source-code">epsilon_start = 0.2</p><p class="source-code">epsilon_end = 0.001</p><p class="source-code">epsilon_annealing_stop = int(episodes/2)</p><p class="source-code">eligibility_decay = 0.3</p></li>
				<li>Initialize the Q-table, set all values equal to <strong class="source-inline">1</strong> except for terminal states, and set an array that will collect all the agent's performance evaluations during training:<p class="source-code">q = np.zeros((16, 4))</p><p class="source-code"># Set q(terminal,*) equal to 0</p><p class="source-code">q[5,:] = 0.0</p><p class="source-code">q[7,:] = 0.0</p><p class="source-code">q[11,:] = 0.0</p><p class="source-code">q[12,:] = 0.0</p><p class="source-code">q[15,:] = 0.0</p><p class="source-code">performance = np.ndarray(episodes//STEPS)</p></li>
				<li>Start the SARSA training loop by looping among all episodes:<p class="source-code">for episode in range(episodes):</p></li>
				<li>Define an epsilon value based on the current episode's run:<p class="source-code">    inew = min(episode,epsilon_annealing_stop)</p><p class="source-code">    epsilon = (epsilon_start * (epsilon_annealing_stop - inew) \</p><p class="source-code">               + epsilon_end * inew) / epsilon_annealing_stop</p></li>
				<li>Initialize the eligibility traces table to <strong class="source-inline">0</strong>:<p class="source-code">    E = np.zeros((16, 4))</p></li>
				<li>Reset the environment, choose the first action with an ε-greedy policy, and start the in-episode loop:<p class="source-code">    state = env.reset()</p><p class="source-code">    action = action_epsilon_greedy(q, state, epsilon)</p><p class="source-code">    while True:</p></li>
				<li>Update the eligibility traces and assign a weight of <strong class="source-inline">1</strong> to the last visited state:<p class="source-code">        E = eligibility_decay * gamma * E</p><p class="source-code">        E[state, action] += 1</p></li>
				<li>Step through the environment with the selected action and retrieve the new state, reward, and done conditions:<p class="source-code">        new_state, reward, done, info = env.step(action)</p></li>
				<li>Select the new action with the ε-greedy policy:<p class="source-code">        new_action = action_epsilon_greedy\</p><p class="source-code">                     (q, new_state, epsilon)</p></li>
				<li>Calculate the <img src="image/B16182_07_33e.png" alt="b"/> update and update the Q-table using the SARSA TD(<img src="image/B16182_07_33h.png" alt="a"/>) rule:<p class="source-code">        delta = reward + gamma \</p><p class="source-code">                * q[new_state, new_action] - q[state, action]</p><p class="source-code">        q = q + alpha * delta * E </p></li>
				<li>Update the state and action with new state and action values:<p class="source-code">        state, action = new_state, new_action</p><p class="source-code">        if done:</p><p class="source-code">            break</p></li>
				<li>Evaluate the agent's average performance:<p class="source-code">    if episode%STEPS == 0:</p><p class="source-code">        performance[episode//STEPS] = average_performance\</p><p class="source-code">                                      (get_action_epsilon_greedy\</p><p class="source-code">                                      (epsilon), q=q)</p></li>
				<li>Plot the SARSA agent's mean reward history during training:<p class="source-code">plt.plot(STEPS*np.arange(episodes//STEPS), performance)</p><p class="source-code">plt.xlabel("Epochs")</p><p class="source-code">plt.title("Learning progress for SARSA")</p><p class="source-code">plt.ylabel("Average reward of an epoch")</p><p>This generates the following output:</p><p class="source-code">Text(0, 0.5, 'Average reward of an epoch')</p><p>The plot for this can be visualized as follows:</p><div id="_idContainer611" class="IMG---Figure"><img src="image/B16182_07_35.jpg" alt="Figure 7.35: Average reward of an epoch trend over training epochs&#13;&#10;"/></div><p class="figure-caption">Figure 7.35: Average reward of an epoch trend over training epochs</p><p>As we can see, SARSA's TD(<img src="image/B16182_07_35a.png" alt="a"/>) performance grows over time as the <strong class="source-inline">ε</strong> parameter is annealed, thus reaching the value of 0 in the limit, and thereby obtaining the greedy policy. It also demonstrates that the algorithm is capable of reaching 100% success after learning. With respect to the one-step SARSA model, as seen in <em class="italic">Figure 7.8</em>, here, we can see that it reaches maximum performance faster, showing a notable improvement.</p></li>
				<li>Evaluate the greedy policy's performance for the trained agent (Q-table):<p class="source-code">greedyPolicyAvgPerf = average_performance(greedy_policy, q=q)</p><p class="source-code">print("Greedy policy SARSA performance =", greedyPolicyAvgPerf)</p><p>The output will be as follows:</p><p class="source-code">Greedy policy SARSA performance = 1.0</p></li>
				<li>Display the Q-table values:<p class="source-code">q = np.round(q,3)</p><p class="source-code">print("(A,S) Value function =", q.shape)</p><p class="source-code">print("First row")</p><p class="source-code">print(q[0:4,:])</p><p class="source-code">print("Second row")</p><p class="source-code">print(q[4:8,:])</p><p class="source-code">print("Third row")</p><p class="source-code">print(q[8:12,:])</p><p class="source-code">print("Fourth row")</p><p class="source-code">print(q[12:16,:])</p><p>This generates the following output:</p><p class="source-code">(A,S) Value function = (16, 4)</p><p class="source-code">First row</p><p class="source-code">[[0.499 0.59  0.519 0.501]</p><p class="source-code"> [0.474 0.    0.615 0.518]</p><p class="source-code"> [0.529 0.699 0.528 0.589]</p><p class="source-code"> [0.608 0.397 0.519 0.517]]</p><p class="source-code">Second row</p><p class="source-code">[[0.553 0.656 0.    0.489]</p><p class="source-code"> [0.    0.    0.    0.   ]</p><p class="source-code"> [0.    0.806 0.    0.593]</p><p class="source-code"> [0.    0.    0.    0.   ]]</p><p class="source-code">Third row</p><p class="source-code">[[0.619 0.    0.729 0.563]</p><p class="source-code"> [0.613 0.77  0.81  0.   ]</p><p class="source-code"> [0.712 0.9   0.    0.678]</p><p class="source-code"> [0.    0.    0.    0.   ]]</p><p class="source-code">Fourth row</p><p class="source-code">[[0.    0.    0.    0.   ]</p><p class="source-code"> [0.003 0.8   0.9   0.683]</p><p class="source-code"> [0.76  0.892 1.    0.787]</p><p class="source-code"> [0.    0.    0.    0.   ]]</p><p>This output shows the values of the complete state-action value function for our problem. These values are then used to generate the optimal policy by means of the greedy selection rule.</p></li>
				<li>Print out the greedy policy that was found and compare it with the optimal policy:<p class="source-code">policyFound = [actionsDict[np.argmax(q[0,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[1,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[2,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[3,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[4,:])],\</p><p class="source-code">               " - ",\</p><p class="source-code">               actionsDict[np.argmax(q[6,:])],\</p><p class="source-code">               " - ",\</p><p class="source-code">               actionsDict[np.argmax(q[8,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[9,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[10,:])],\</p><p class="source-code">               " - ",\</p><p class="source-code">               " - ",\</p><p class="source-code">               actionsDict[np.argmax(q[13,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[14,:])],\</p><p class="source-code">               " ! "]</p><p class="source-code">print("Greedy policy found:")</p><p class="source-code">idxs = [0,4,8,12]</p><p class="source-code">for idx in idxs:</p><p class="source-code">    print(policyFound[idx+0], policyFound[idx+1], \</p><p class="source-code">          policyFound[idx+2], policyFound[idx+3])</p><p class="source-code">print(" ")</p><p class="source-code">print("Optimal policy:")</p><p class="source-code">idxs = [0,4,8,12]</p><p class="source-code">for idx in idxs:</p><p class="source-code">    print(optimalPolicy[idx+0], optimalPolicy[idx+1], \</p><p class="source-code">          optimalPolicy[idx+2], optimalPolicy[idx+3])</p><p>This produces the following output:</p><p class="source-code">Greedy policy found:</p><p class="source-code"> R   R   D   L </p><p class="source-code"> D   -   D   - </p><p class="source-code"> R   D   D   - </p><p class="source-code"> -   R   R   ! </p><p class="source-code">Optimal policy:</p><p class="source-code">R/D  R   D   L </p><p class="source-code"> D   -   D   - </p><p class="source-code"> R  R/D  D   - </p><p class="source-code"> -   R   R   !</p></li>
			</ol>
			<p>As you can see, our SARSA algorithm has been able to correctly solve the FrozenLake-v0 environment by being able to learn the optimal policy under the deterministic transition dynamics. In fact, as we can see, for every state of the grid world, the greedy policy that was obtained with the Q-table that was calculated by our algorithm prescribes an action that is in accordance with the optimal policy that was defined by analyzing the environment problem. As we already saw, there are two states in which there are two equally optimal actions, and the agent correctly implements one of them.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YdePoa">https://packt.live/2YdePoa</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3ek4ZXa">https://packt.live/3ek4ZXa</a>.</p>
			<p>We can now proceed and test how it behaves when exposed to stochastic dynamics. We'll do this in the next exercise. Just like when using one-step SARSA, in this case, we want to give the agent the freedom to take advantage of the 0 penalty for intermediate steps to minimize risk of falling into the holes, so in this case, we have to set the discount factor's gamma equal to 1. This means that instead of using <strong class="source-inline">gamma = 0.9</strong>, we will use <strong class="source-inline">gamma = 1.0</strong>.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor257"/>Exercise 7.05: Using TD(λ) SARSA to Solve FrozenLake-v0 Stochastic Transitions</h2>
			<p>In this exercise, we will implement our SARSA(λ) algorithm to solve the FrozenLake-v0 environment under the deterministic environment dynamics. As we saw earlier in this chapter, when talking about one-step TD methods, the optimal policy looks completely different with respect to the previous exercise since it needs to take care of the stochasticity factor. This imposes a new challenge for the SARSA(λ) algorithm. We will see how it will still be able to solve this task in this exercise.</p>
			<p>Follow these steps to complete this exercise:</p>
			<ol>
				<li value="1">Import the required modules:<p class="source-code">import numpy as np</p><p class="source-code">from numpy.random import random, choice</p><p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">%matplotlib inline</p><p class="source-code">import gym</p></li>
				<li>Instantiate the <strong class="source-inline">gym</strong> environment called <strong class="source-inline">FrozenLake-v0</strong> using the <strong class="source-inline">is_slippery</strong> flag set to <strong class="source-inline">True</strong> in order to enable stochasticity:<p class="source-code">env = gym.make('FrozenLake-v0', is_slippery=True)</p></li>
				<li>Take a look at the action and observation spaces:<p class="source-code">print("Action space = ", env.action_space)</p><p class="source-code">print("Observation space = ", env.observation_space)</p><p>This will print out the following:</p><p class="source-code">Action space =  Discrete(4)</p><p class="source-code">Observation space =  Discrete(16)</p></li>
				<li>Create two dictionaries to easily translate the <strong class="source-inline">actions</strong> numbers into moves:<p class="source-code">actionsDict = {}</p><p class="source-code">actionsDict[0] = "  L  "</p><p class="source-code">actionsDict[1] = "  D  "</p><p class="source-code">actionsDict[2] = "  R  "</p><p class="source-code">actionsDict[3] = "  U  "</p><p class="source-code">actionsDictInv = {}</p><p class="source-code">actionsDictInv["L"] = 0</p><p class="source-code">actionsDictInv["D"] = 1</p><p class="source-code">actionsDictInv["R"] = 2</p><p class="source-code">actionsDictInv["U"] = 3</p></li>
				<li>Reset the environment and render it to take a look at the grid problem:<p class="source-code">env.reset()</p><p class="source-code">env.render()</p><p>The output will be as follows:</p><div id="_idContainer613" class="IMG---Figure"><img src="image/B16182_07_36.jpg" alt="Figure 7.36: Environment's initial state&#13;&#10;"/></div><p class="figure-caption">Figure 7.36: Environment's initial state</p></li>
				<li>Visualize the optimal policy for this environment:<p class="source-code">optimalPolicy = ["L/R/D","  U  ","  U  ","  U  ",\</p><p class="source-code">                 "  L  ","  -  "," L/R ","  -  ",\</p><p class="source-code">                 "  U  ","  D  ","  L  ","  -  ",\</p><p class="source-code">                 "  -  ","  R  ","  D  ","  !  ",]</p><p class="source-code">print("Optimal policy:")</p><p class="source-code">idxs = [0,4,8,12]</p><p class="source-code">for idx in idxs:</p><p class="source-code">    print(optimalPolicy[idx+0], optimalPolicy[idx+1], \</p><p class="source-code">          optimalPolicy[idx+2], optimalPolicy[idx+3])</p><p>This prints out the following output:</p><p class="source-code">Optimal policy:  </p><p class="source-code">  L/R/D  U    U    U</p><p class="source-code">    L    -   L/R   -</p><p class="source-code">    U    D    L    -</p><p class="source-code">    -    R    D    !</p><p>This represents the optimal policy for this environment. Except for two states, all the others have a single optimal action associated with them. In fact, as described earlier in this chapter, optimal actions here are those that bring the agent away from the holes, or from tiles that have a chance greater than zero to lead the agent into tiles placed near holes. Two states have multiple optimal actions associated with them that are all equally optimal, as intended for this task.</p></li>
				<li>Define the functions that will take ε-greedy actions:<p class="source-code">def action_epsilon_greedy(q, s, epsilon=0.05):</p><p class="source-code">    if np.random.rand() &gt; epsilon:</p><p class="source-code">        return np.argmax(q[s])</p><p class="source-code">    return np.random.randint(4)</p><p class="source-code">def get_action_epsilon_greedy(epsilon):</p><p class="source-code">    return lambda q,s: action_epsilon_greedy\</p><p class="source-code">                       (q, s, epsilon=epsilon)</p></li>
				<li>Define a function that will take greedy actions:<p class="source-code">def greedy_policy(q, s):</p><p class="source-code">    return np.argmax(q[s])</p></li>
				<li>Define a function that will calculate the agent's average performance:<p class="source-code">def average_performance(policy_fct, q):</p><p class="source-code">    acc_returns = 0.</p><p class="source-code">    n = 500</p><p class="source-code">    for i in range(n):</p><p class="source-code">        done = False</p><p class="source-code">        s = env.reset()</p><p class="source-code">        while not done:</p><p class="source-code">            a = policy_fct(q, s)</p><p class="source-code">            s, reward, done, info = env.step(a)</p><p class="source-code">            acc_returns += reward</p><p class="source-code">    return acc_returns/n</p></li>
				<li>Set the number of total episodes, the number of steps representing the interval by which we will evaluate the agent's average performance, the discount factor, the learning rate, and the <strong class="source-inline">ε </strong>parameters ruling its decrease – the starting value, minimum value, and range (in terms of the number of episodes) – over which the decrease is spread, as well as the eligibility trace's decay parameter:<p class="source-code"># parameters for sarsa(lambda)</p><p class="source-code">episodes = 80000</p><p class="source-code">STEPS = 2000</p><p class="source-code">gamma = 1</p><p class="source-code">alpha = 0.02</p><p class="source-code">epsilon_start = 0.2</p><p class="source-code">epsilon_end = 0.001</p><p class="source-code">epsilon_annealing_stop = int(episodes/2)</p><p class="source-code">eligibility_decay = 0.3</p></li>
				<li>Initialize the Q-table, set all the values equal to one except for terminal states, and set an array so that it collects all agent performance evaluations during training:<p class="source-code">q = np.zeros((16, 4))</p><p class="source-code"># Set q(terminal,*) equal to 0</p><p class="source-code">q[5,:] = 0.0</p><p class="source-code">q[7,:] = 0.0</p><p class="source-code">q[11,:] = 0.0</p><p class="source-code">q[12,:] = 0.0</p><p class="source-code">q[15,:] = 0.0</p><p class="source-code">performance = np.ndarray(episodes//STEPS)</p></li>
				<li>Start the SARSA training loop by looping among all episodes:<p class="source-code">for episode in range(episodes):</p></li>
				<li>Define the epsilon value based on the current episode run:<p class="source-code">    inew = min(episode,epsilon_annealing_stop)</p><p class="source-code">    epsilon = (epsilon_start * (epsilon_annealing_stop - inew) \</p><p class="source-code">               + epsilon_end * inew) / epsilon_annealing_stop</p></li>
				<li>Initialize the eligibility traces table to 0:<p class="source-code">    E = np.zeros((16, 4))</p></li>
				<li>Reset the environment and state your choice for the first action with an ε-greedy policy. Then, start the in-episode loop:<p class="source-code">    state = env.reset()</p><p class="source-code">    action = action_epsilon_greedy(q, state, epsilon)</p><p class="source-code">    while True:</p></li>
				<li>Update the eligibility traces by applying decay and making the last state-action pair the most important one:<p class="source-code">        E = eligibility_decay * gamma * E</p><p class="source-code">        E[state, action] += 1</p></li>
				<li>Define the environment step with the selected action and retrieval of the new state, reward, and done conditions:<p class="source-code">        new_state, reward, done, info = env.step(action)</p></li>
				<li>Select a new action with the ε-greedy policy:<p class="source-code">        new_action = action_epsilon_greedy(q, new_state, epsilon)</p></li>
				<li>Calculate the <img src="image/B16182_07_36a.png" alt="b"/> update and update the Q-table with the SARSA TD(<img src="image/B16182_07_36b.png" alt="a"/>) rule:<p class="source-code">        delta = reward + gamma \</p><p class="source-code">                * q[new_state, new_action] - q[state, action]</p><p class="source-code">        q = q + alpha * delta * E </p></li>
				<li>Update the state and action with new values:<p class="source-code">        state, action = new_state, new_action</p><p class="source-code">        if done:</p><p class="source-code">            break</p></li>
				<li>Evaluate the average agent performance:<p class="source-code">    if episode%STEPS == 0:</p><p class="source-code">        performance[episode//STEPS] = average_performance\</p><p class="source-code">                                      (get_action_epsilon_greedy\</p><p class="source-code">                                      (epsilon), q=q)</p></li>
				<li>Plot the SARSA agent's mean reward history during training:<p class="source-code">plt.plot(STEPS*np.arange(episodes//STEPS), performance)</p><p class="source-code">plt.xlabel("Epochs")</p><p class="source-code">plt.title("Learning progress for SARSA")</p><p class="source-code">plt.ylabel("Average reward of an epoch")</p><p>This generates the following output:</p><p class="source-code">Text(0, 0.5, 'Average reward of an epoch')</p><p>The plot for this can be visualized as follows:</p><div id="_idContainer616" class="IMG---Figure"><img src="image/B16182_07_37.jpg" alt="Figure 7.37: Average reward of an epoch trend over training epochs&#13;&#10;"/></div><p class="figure-caption">Figure 7.37: Average reward of an epoch trend over training epochs</p><p>Again, in comparison to the previous TD(0) SARSA case seen in <em class="italic">Figure 7.15</em>, this plot clearly shows us how the algorithm's performance improves over epochs, even when stochastic dynamics are considered. The behavior is very similar, and it also shows that, in the case of stochastic dynamics, it is not possible to obtain a perfect performance, in other words, reaching the goal 100% of the time.</p></li>
				<li>Evaluate the greedy policy's performance of the trained agent (Q-table):<p class="source-code">greedyPolicyAvgPerf = average_performance(greedy_policy, q=q)</p><p class="source-code">print("Greedy policy SARSA performance =", greedyPolicyAvgPerf)</p><p>This prints out the following output:</p><p class="source-code">Greedy policy SARSA performance = 0.734</p></li>
				<li>Display the Q-table values:<p class="source-code">q = np.round(q,3)</p><p class="source-code">print("(A,S) Value function =", q.shape)</p><p class="source-code">print("First row")</p><p class="source-code">print(q[0:4,:])</p><p class="source-code">print("Second row")</p><p class="source-code">print(q[4:8,:])</p><p class="source-code">print("Third row")</p><p class="source-code">print(q[8:12,:])</p><p class="source-code">print("Fourth row")</p><p class="source-code">print(q[12:16,:])</p><p>This generates the following output:</p><p class="source-code">(A,S) Value function = (16, 4)</p><p class="source-code">First row</p><p class="source-code">[[0.795 0.781 0.79  0.786]</p><p class="source-code"> [0.426 0.386 0.319 0.793]</p><p class="source-code"> [0.511 0.535 0.541 0.795]</p><p class="source-code"> [0.341 0.416 0.393 0.796]]</p><p class="source-code">Second row</p><p class="source-code">[[0.794 0.515 0.541 0.519]</p><p class="source-code"> [0.    0.    0.    0.   ]</p><p class="source-code"> [0.321 0.211 0.469 0.125]</p><p class="source-code"> [0.    0.    0.    0.   ]]</p><p class="source-code">Third row</p><p class="source-code">[[0.5   0.514 0.595 0.788]</p><p class="source-code"> [0.584 0.778 0.525 0.46 ]</p><p class="source-code"> [0.703 0.54  0.462 0.365]</p><p class="source-code"> [0.    0.    0.    0.   ]]</p><p class="source-code">Fourth row</p><p class="source-code">[[0.    0.    0.    0.   ]</p><p class="source-code"> [0.563 0.557 0.862 0.508]</p><p class="source-code"> [0.823 0.94  0.878 0.863]</p><p class="source-code"> [0.    0.    0.    0.   ]]</p><p>This output shows the values of the complete state-action value function for our problem. These values are then used to generate the optimal policy by means of the greedy selection rule.</p></li>
				<li>Print out the greedy policy that was found and compare it with the optimal policy:<p class="source-code">policyFound = [actionsDict[np.argmax(q[0,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[1,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[2,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[3,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[4,:])],\</p><p class="source-code">               " - ",\</p><p class="source-code">               actionsDict[np.argmax(q[6,:])],\</p><p class="source-code">               " - ",\</p><p class="source-code">               actionsDict[np.argmax(q[8,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[9,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[10,:])],\</p><p class="source-code">               " - ",\</p><p class="source-code">               " - ",\</p><p class="source-code">               actionsDict[np.argmax(q[13,:])],\</p><p class="source-code">               actionsDict[np.argmax(q[14,:])],\</p><p class="source-code">               " ! "]</p><p class="source-code">print("Greedy policy found:")</p><p class="source-code">idxs = [0,4,8,12]</p><p class="source-code">for idx in idxs:</p><p class="source-code">    print(policyFound[idx+0], policyFound[idx+1], \</p><p class="source-code">          policyFound[idx+2], policyFound[idx+3])</p><p class="source-code">print(" ")</p><p class="source-code">print("Optimal policy:")</p><p class="source-code">idxs = [0,4,8,12]</p><p class="source-code">for idx in idxs:</p><p class="source-code">    print(optimalPolicy[idx+0], optimalPolicy[idx+1], \</p><p class="source-code">          optimalPolicy[idx+2], optimalPolicy[idx+3])</p><p>This produces the following output:</p><p class="source-code">Greedy policy found: </p><p class="source-code">    L    U    U    U</p><p class="source-code">    L    -    R    -</p><p class="source-code">    U    D    L    -</p><p class="source-code">    -    R    D    !</p><p class="source-code">Optimal policy:  </p><p class="source-code">  L/R/D  U    U    U</p><p class="source-code">    L    -   L/R   -</p><p class="source-code">    U    D    L    -</p><p class="source-code">    -    R    D    !</p></li>
			</ol>
			<p>Also, as in the case of stochastic environment dynamics, the SARSA algorithm with eligibility traces has been able to correctly learn the optimal policy.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2CiyZVf">https://packt.live/2CiyZVf</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2Np7zQ9">https://packt.live/2Np7zQ9</a>.</p>
			<p>With this exercise, we've completed our study of temporal difference methods and covered many of the aspects, from their most simple one-step formulation to the most advanced ones. We are now able to combine multi-step methods without the restriction of having to wait until the end of the episode to update the state-value (or state-action pair) function. To complete our journey, we'll conclude with a quick comparison of the methods we explained in this chapter with those explained in <em class="italic">Chapter 5, Dynamic Programming</em>, and <em class="italic">Chapter 6, Monte Carlo Methods</em>.</p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor258"/>The Relationship between DP, Monte-Carlo, and TD Learning</h1>
			<p>From what we've learned in this chapter, and as we've stated multiple times, it is clear how temporal difference learning has characteristics in common with both Monte Carlo methods and dynamic programming ones. Like the former, it learns directly from experience, without leveraging a model of the environment representing transition dynamics or knowledge of the reward function involved in the task. Like the latter, it bootstraps, meaning that it updates the value function estimate partially based on other estimates, thereby circumventing the need to wait until the end of the episode. This point is particularly important since, in practice, very long episodes (or even infinite ones) can be encountered, making MC methods impractical and too slow. This strict relation plays a central role in reinforcement learning theory.</p>
			<p>We have also learned about N-step methods and eligibility traces, two different but related topics that allow us to frame TD method's theory as a general picture capable of fusing together MC and TD methods. In particular, the eligibility traces concept allowed us to formally represent both of them, with the additional advantage of implementing a perspective change from a forward view to a more efficient incremental backward view, which allows us to extend MC methods even to non-episodic problems.</p>
			<p>When bringing TD and MC methods under the same theory umbrella, eligibility traces demonstrate their value in making TD methods more robust to non-Markovian tasks, a typical problem in which MC algorithms behave better than TD ones. Thus, eligibility traces, even if typically coupled with an increased computational overhead, offer a better learning capability in general since they are both faster and more robust.</p>
			<p>It is now time for us to tackle the final activity of this chapter, where we will apply what we have learned from the theory and exercises we've covered on TD methods.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor259"/>Activity 7.01: Using TD(0) Q-Learning to Solve FrozenLake-v0 Stochastic Transitions</h2>
			<p>The goal of this activity is for you to adapt the TD(0) Q-learning algorithm to solve the FrozenLake-v0 environment under the stochastic transition dynamics. We have already seen that the optimal policy appears as follows:</p>
			<div>
				<div id="_idContainer617" class="IMG---Figure">
					<img src="image/B16182_07_38.jpg" alt="Figure 7.38: Optimal policy –  D = Down move, R = Right move, U = Up move, &#13;&#10;and L = Left move&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.38: Optimal policy –  D = Down move, R = Right move, U = Up move, and L = Left move</p>
			<p>Making Q-learning converge on this environment is not a simple task, but it is possible. In order to make this a little bit easier, we can use a value for the discount factor gamma that's equal to <strong class="source-inline">0.99</strong>. The following steps will help you to complete this exercise:</p>
			<ol>
				<li value="1">Import all the required modules.</li>
				<li>Instantiate the gym environment and print out the observation and action spaces.</li>
				<li>Reset the environment and render the starting state.</li>
				<li>Define and print out the optimal policy for reference.</li>
				<li>Define the functions for implementing the greedy and ε-greedy policies.</li>
				<li>Define a function that will evaluate the agent's average performance and initialize the Q-table.</li>
				<li>Define the learning method hyperparameters (ε, discount factor, total number of episodes, and so on).</li>
				<li>Implement the Q-learning algorithm.</li>
				<li>Train the agent and plot the average performance as a function of training epochs.</li>
				<li>Display the Q-values found and print out the greedy policy while comparing it with the optimal one.</li>
			</ol>
			<p>The final output of this activity is very similar to the ones you've encountered for all of the exercises in this chapter. We want to compare the policy found by our agent that was trained using the prescribed method with the optimal one to make sure we succeeded in making it learn the optimal policy correctly.</p>
			<p>The optimal policy should be as follows:</p>
			<p class="source-code">Greedy policy found:</p>
			<p class="source-code">    L    U    U    U</p>
			<p class="source-code">    L    -    R    -</p>
			<p class="source-code">    U    D    L    -</p>
			<p class="source-code">    -    R    D    !</p>
			<p class="source-code">Optimal policy:  </p>
			<p class="source-code">  L/R/D  U    U    U</p>
			<p class="source-code">    L    -   L/R   -</p>
			<p class="source-code">    U    D    L    -</p>
			<p class="source-code">    -    R    D    !</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 726.</p>
			<p>By completing this activity, we've learned how to correctly implement and set up a one-step Q-learning algorithm by appropriately tuning its hyperparameters to solve an environment with stochastic transition dynamics. We monitored the agent's performance during training, and we confronted ourselves with the role of the reward discount factor. We selected a value for it, allowing us to make our agent learn the optimal policy for this specific task, even if the maximum reward for this environment is bound and there is no possibility of completing the episode 100% of the time.</p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor260"/>Summary</h1>
			<p>This chapter dealt with temporal difference learning. We started by studying one-step methods in both their on-policy and off-policy implementations, leading to us learning about the SARSA and Q-learning algorithms, respectively. We tested these algorithms on the FrozenLake-v0 problem and covered both deterministic and stochastic transition dynamics. Then, we moved on to the N-step temporal difference methods, the first step toward the unification of TD and MC methods. We saw how on-policy and off-policy methods are extended to this case. Finally, we studied TD methods with eligibility traces, which constitute the most relevant step toward the formalization of a unique theory describing both TD and MC algorithms. We extended SARSA to eligibility tracing, too, and learned about this through implementing two exercises where it has been implemented and applied to the FrozenLake-v0 environment under both deterministic and stochastic transition dynamics. With this, we have been able to successfully learn about the optimal policy in all cases, thereby demonstrating how these methods are sound and robust.</p>
			<p>Now, it is time to move on to the next chapter, in which we will address the multi-armed bandit problem, a classic setting that's often encountered when studying reinforcement learning theory and the application of RL algorithms.</p>
		</div>
		<div>
			<div id="_idContainer619" class="Content">
			</div>
		</div>
	</body></html>