["```py\nimport numpy as np\n```", "```py\nnp.array([1,3,5,7])\n```", "```py\narray([1, 3, 5, 7])\n```", "```py\nA = np.mat([[1,2],[3,3]])\nA\n```", "```py\nmatrix([[1, 2],\n        [3, 3]])\n```", "```py\nA + A\n```", "```py\nmatrix([[2, 4],\n        [6, 6]])\n```", "```py\nA - A\n```", "```py\nmatrix([[0, 0],\n        [0, 0]])\n```", "```py\nA * A\n```", "```py\nmatrix([[ 7,  8],\n        [12, 15]])\n```", "```py\nnp.linalg.det( A )\n```", "```py\n-3.0000000000000004\n```", "```py\nnp.matrix.transpose(A)\n```", "```py\nmatrix([[1, 3],\n        [2, 3]])\n```", "```py\n    import numpy as np\n    ```", "```py\n    A = np.mat([[1,2,3],[4,5,6],[7,8,9]])\n    A\n    ```", "```py\n    matrix([[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]])\n    ```", "```py\n    matmult = A * A\n    matmult\n    ```", "```py\n    matrix([[ 30, 36, 42],\n            [ 66, 81, 96],\n            [102, 126, 150]])\n    ```", "```py\n    1 * 1 + 2 * 4 + 3 * 7\n    ```", "```py\n    30\n    ```", "```py\n    det = np.linalg.det( A )\n    det\n    ```", "```py\n    0.0\n    ```", "```py\n    transpose = np.matrix.transpose(A)\n    transpose\n    ```", "```py\n    matrix([[1, 4, 7],\n            [2, 5, 8],\n            [3, 6, 9]])\n    ```", "```py\n\\ ) to split the logic across multiple lines. When the code is executed, Python will ignore the backslash, and treat the code on the next line as a direct continuation of the current line.\nroot = {'value': 1, 'depth': 1}\ndef succ(node):\n    if node['value'] == 5:\n        return []\n    elif node['value'] == 4:\n        return [{'value': 5,'depth': node['depth']+1}]\n    else:\n        return [{'value': node['value']+1, \\\n                 'depth':node['depth']+1}, \\\n                {'value': node['value']+2, \\\n                 'depth':node['depth']+1}]\n```", "```py\ndef bfs_tree(node):\n    nodes_to_visit = [node]\n    visited_nodes = []\n    while len(nodes_to_visit) > 0:\n        current_node = nodes_to_visit.pop(0)\n        visited_nodes.append(current_node)\n        nodes_to_visit.extend(succ(current_node))\n    return visited_nodes\nbfs_tree(root)\n```", "```py\n[{'value': 1, 'depth': 1},\n {'value': 2, 'depth': 2},\n {'value': 3, 'depth': 2},\n {'value': 3, 'depth': 3},\n {'value': 4, 'depth': 3},\n {'value': 4, 'depth': 3},\n {'value': 5, 'depth': 3},\n {'value': 4, 'depth': 4},\n {'value': 5, 'depth': 4},\n {'value': 5, 'depth': 4},\n {'value': 5, 'depth': 4},\n {'value': 5, 'depth': 5}]\n```", "```py\ndef dfs_tree(node):\n    nodes_to_visit = [node]\n    visited_nodes = []\n    while len(nodes_to_visit) > 0:\n        current_node = nodes_to_visit.pop()\n        visited_nodes.append(current_node)\n        nodes_to_visit.extend(succ(current_node))\n    return visited_nodes\ndfs_tree(root)\n```", "```py\n[{'value': 1, 'depth': 1},\n {'value': 3, 'depth': 2},\n {'value': 5, 'depth': 3},\n {'value': 4, 'depth': 3},\n {'value': 5, 'depth': 4},\n {'value': 2, 'depth': 2},\n {'value': 4, 'depth': 3},\n {'value': 5, 'depth': 4},\n {'value': 3, 'depth': 3},\n {'value': 5, 'depth': 4},\n {'value': 4, 'depth': 4},\n {'value': 5, 'depth': 5}]\n```", "```py\nfrom random import choice\nchoice([2, 4, 6, 8])\n```", "```py\n    from random import choice\n    ```", "```py\n    combo_indices = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], \\\n                     [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]\n    ```", "```py\n    EMPTY_SIGN = '.'\n    AI_SIGN = 'X'\n    OPPONENT_SIGN = 'O'\n    ```", "```py\n    def print_board(board):\n        print(\" \")\n        print(' '.join(board[:3]))\n        print(' '.join(board[3:6]))\n        print(' '.join(board[6:]))\n        print(\" \")\n    ```", "```py\n    def opponent_move(board, row, column):\n        index = 3 * (row - 1) + (column - 1)\n        if board[index] == EMPTY_SIGN:\n            return board[:index] + OPPONENT_SIGN + board[index+1:]\n        return board\n    ```", "```py\n    def all_moves_from_board(board, sign):\n        move_list = []\n        for i, v in enumerate(board):\n            if v == EMPTY_SIGN:\n                move_list.append(board[:i] + sign + board[i+1:])\n        return move_list\n    def ai_move(board):\n        return choice(all_moves_from_board(board, AI_SIGN))\n    ```", "```py\n    def game_won_by(board):\n        for index in combo_indices:\n            if board[index[0]] == board[index[1]] == \\\n               board[index[2]] != EMPTY_SIGN:\n                return board[index[0]]\n        return EMPTY_SIGN\n    ```", "```py\n    def game_loop():\n        board = EMPTY_SIGN * 9\n        empty_cell_count = 9\n        is_game_ended = False\n        while empty_cell_count > 0 and not is_game_ended:\n            if empty_cell_count % 2 == 1:\n                board = ai_move(board)\n            else:\n                row = int(input('Enter row: '))\n                col = int(input('Enter column: '))\n                board = opponent_move(board, row, col)\n            print_board(board)\n            is_game_ended = game_won_by(board) != EMPTY_SIGN\n            empty_cell_count = sum(1 for cell in board \\\n                                   if cell == EMPTY_SIGN)\n        print('Game has been ended.')\n    ```", "```py\n    game_loop()\n    ```", "```py\nstep 0\\. Moves: 1\nstep 1\\. Moves: 9\nstep 2\\. Moves: 72\nstep 3\\. Moves: 504\nstep 4\\. Moves: 3024\nstep 5\\. Moves: 13680\nstep 6\\. Moves: 49402\nstep 7\\. Moves: 111109\nstep 8\\. Moves: 156775\nFirst player wins: 106279\nSecond player wins: 68644\nDraw 91150\nTotal 266073\n```", "```py\n    def ai_move(board):\n        new_boards = all_moves_from_board(board, AI_SIGN)\n        for new_board in new_boards:\n            if game_won_by(new_board) == AI_SIGN:\n                return new_board\n        return choice(new_boards)\n    ```", "```py\n    game_loop()\n    ```", "```py\n    def all_moves_from_board(board, sign):\n        move_list = []\n        for i, v in enumerate(board):\n            if v == EMPTY_SIGN:\n                new_board = board[:i] + sign + board[i+1:]\n                move_list.append(new_board)\n                if game_won_by(new_board) == AI_SIGN:\n                    return [new_board]\n        return move_list\n    ```", "```py\n    first_player, second_player, \\\n    draw, total = count_possibilities()\n    ```", "```py\n    step 0\\. Moves: 1\n     step 1\\. Moves: 9\n     step 2\\. Moves: 72\n     step 3\\. Moves: 504\n     step 4\\. Moves: 3024\n     step 5\\. Moves: 8525\n     step 6\\. Moves: 28612\n     step 7\\. Moves: 42187\n     step 8\\. Moves: 55888\n     First player wins: 32395\n     Second player wins: 23445\n     Draw 35544\n     Total 91384\n    ```", "```py\nstep 0\\. Moves: 1\nstep 1\\. Moves: 9\nstep 2\\. Moves: 72\nstep 3\\. Moves: 504\nstep 4\\. Moves: 3024\nstep 5\\. Moves: 5197\nstep 6\\. Moves: 18606\nstep 7\\. Moves: 19592\nstep 8\\. Moves: 30936\nFirst player wins: 20843\nSecond player wins: 962\nDraw 20243\nTotal 42048\n```", "```py\nstep 0\\. Moves: 1\nstep 1\\. Moves: 1\nstep 2\\. Moves: 8\nstep 3\\. Moves: 8\nstep 4\\. Moves: 48\nstep 5\\. Moves: 38\nstep 6\\. Moves: 108\nstep 7\\. Moves: 76\nstep 8\\. Moves: 90\nFirst player wins: 128\nSecond player wins: 0\nDraw 60\nTotal 188\n```", "```py\n    def init_utility_matrix(board):\n        return [0 if cell == EMPTY_SIGN \\\n                else -1 for cell in board]\n    ```", "```py\n    def generate_add_score(utilities, i, j, k):\n        def add_score(points):\n            if utilities[i] >= 0:\n                utilities[i] += points\n            if utilities[j] >= 0:\n                utilities[j] += points\n            if utilities[k] >= 0:\n                utilities[k] += points\n        return add_score\n    ```", "```py\n    def utility_matrix(board):\n        utilities = init_utility_matrix(board)\n        for [i, j, k] in combo_indices:\n            add_score = generate_add_score(utilities, i, j, k)\n            triple = [board[i], board[j], board[k]]\n            if triple.count(EMPTY_SIGN) == 1:\n                if triple.count(AI_SIGN) == 2:\n                    add_score(1000)\n                elif triple.count(OPPONENT_SIGN) == 2:\n                    add_score(100)\n            elif triple.count(EMPTY_SIGN) == 2 and \\\n                              triple.count(AI_SIGN) == 1:\n                add_score(10)\n            elif triple.count(EMPTY_SIGN) == 3:\n                add_score(1)\n        return utilities\n    ```", "```py\n    def best_moves_from_board(board, sign):\n        move_list = []\n        utilities = utility_matrix(board)\n        max_utility = max(utilities)\n        for i, v in enumerate(board):\n            if utilities[i] == max_utility:\n                move_list.append(board[:i] \\\n                                 + sign \\\n                                 + board[i+1:])\n        return move_list\n    def all_moves_from_board_list(board_list, sign):\n        move_list = []\n        get_moves = best_moves_from_board if sign \\\n                    == AI_SIGN else all_moves_from_board\n        for board in board_list:\n            move_list.extend(get_moves(board, sign))\n        return move_list\n    ```", "```py\n    first_player, second_player, \\\n    draw, total = count_possibilities()\n    ```", "```py\n    step 0\\. Moves: 1\n    step 1\\. Moves: 1\n    step 2\\. Moves: 8\n    step 3\\. Moves: 24\n    step 4\\. Moves: 144\n    step 5\\. Moves: 83\n    step 6\\. Moves: 214\n    step 7\\. Moves: 148\n    step 8\\. Moves: 172\n    First player wins: 504\n    Second player wins: 12\n    Draw 91\n    Total 607\n    ```", "```py\n    import math\n    ```", "```py\n    size = (7, 9)\n    start = (5, 3)\n    end = (6, 9)\n    obstacles = {(3, 4), (3, 5), (3, 6), (3, 7), (3, 8), \\\n                 (4, 5), (5, 5), (5, 7), (5, 9), (6, 2), \\\n                 (6, 3), (6, 4), (6, 5), (6, 7),(7, 7)}\n    ```", "```py\n    def successors(state, visited_nodes):\n        (row, col) = state\n        (max_row, max_col) = size\n        succ_states = []\n        if row > 1:\n            succ_states += [(row-1, col)]\n        if col > 1:\n            succ_states += [(row, col-1)]\n        if row < max_row:\n            succ_states += [(row+1, col)]\n        if col < max_col:\n            succ_states += [(row, col+1)]\n        return [s for s in succ_states if s not in \\\n                visited_nodes if s not in obstacles]\n    ```", "```py\n    def initialize_costs(size, start):\n        (h, w) = size\n        costs = [[math.inf] * w for i in range(h)]\n        (x, y) = start\n        costs[x-1][y-1] = 0\n        return costs\n    ```", "```py\n    def update_costs(costs, current_node, successor_nodes):\n        new_cost = costs[current_node[0]-1]\\\n                   [current_node[1]-1] + 1\n        for (x, y) in successor_nodes:\n            costs[x-1][y-1] = min(costs[x-1][y-1], new_cost)\n    ```", "```py\n    def bfs_tree(node):\n        nodes_to_visit = [node]\n        visited_nodes = []\n        costs = initialize_costs(size, start)\n        while len(nodes_to_visit) > 0:\n            current_node = nodes_to_visit.pop(0)\n            visited_nodes.append(current_node)\n            successor_nodes = successors(current_node, \\\n                                         visited_nodes)\n            update_costs(costs, current_node, successor_nodes)\n            nodes_to_visit.extend(successor_nodes)\n        return costs\n    bfs = bfs_tree(start)\n    bfs\n    ```", "```py\n    [[6, 5, 4, 5, 6, 7, 8, 9, 10],\n     [5, 4, 3, 4, 5, 6, 7, 8, 9],\n     [4, 3, 2, inf, inf, inf, inf, inf, 10],\n     [3, 2, 1, 2, inf, 12, 13, 12, 11],\n     [2, 1, 0, 1, inf, 11, inf, 13, inf],\n     [3, inf, inf, inf, inf, 10, inf, 14, 15],\n     [4, 5, 6, 7, 8, 9, inf, 15, 16]]\n    ```", "```py\n    def bfs_tree_verbose(node):\n        nodes_to_visit = [node]\n        visited_nodes = []\n        costs = initialize_costs(size, start)\n        step_counter = 0\n        while len(nodes_to_visit) > 0:\n            step_counter += 1\n            current_node = nodes_to_visit.pop(0)\n            visited_nodes.append(current_node)\n            successor_nodes = successors(current_node, \\\n                                         visited_nodes)\n            update_costs(costs, current_node, successor_nodes)\n            nodes_to_visit.extend(successor_nodes)\n            if current_node == end:\n                print('End node has been reached in ', \\\n                      step_counter, ' steps')\n                return costs\n        return costs\n    bfs_v = bfs_tree_verbose(start)\n    bfs_v\n    ```", "```py\n    End node has been reached in 110 steps\n    [[6, 5, 4, 5, 6, 7, 8, 9, 10],\n     [5, 4, 3, 4, 5, 6, 7, 8, 9],\n     [4, 3, 2, inf, inf, inf, inf, inf, 10],\n     [3, 2, 1, 2, inf, 12, 13, 12, 11],\n     [2, 1, 0, 1, inf, 11, inf, 13, inf],\n     [3, inf, inf, inf, inf, 10, inf, 14, 15],\n     [4, 5, 6, 7, 8, 9, inf, 15, 16]]\n    ```", "```py\n\"\"\" ) shown in the code snippet below are used to denote the start and end points of a multi-line code comment. Comments are added into code to help explain specific bits of logic.\n```", "```py\nfrontier = [start], internal = {}\n# Initialize the costs matrix with each cell set to infinity.\n# Set the value of distance_from_start(start) to 0\\. \nwhile frontier is not empty: \n    \"\"\"\n    notice n has the lowest estimated total \n    distance between start and end.\n    \"\"\"\n    n = frontier.pop()\n    # We'll learn later how to reconstruct the shortest path\n    if n == end: \n        return the shortest path. \n    internal.add(n) \n    for successor s in succ(n): \n        if s in internal: \n            continue # The node was already examined\n        new_distance = distance_from_start(n) + distance(n, s) \n        if new_distance >= distance_from_start(s): \n            \"\"\"\n            This path is not better than the path we have \n            already examined.\n            \"\"\"\n            continue \n        if s is a member of frontier:\n            update the priority of s\n        else:\n            Add s to frontier.\n```", "```py\npath = [end_node], distance = get_distance_from_start( end_node )\nwhile the distance of the last element in the path is not 0:\n    for each neighbor of the last node in path:\n        new_distance = get_distance_from_start( neighbor )\n        if new_distance < distance: \n            add neighbor to path, and break out from the for loop\nreturn path\n```", "```py\n# Import heapq to access the priority queue\nimport heapq\n# Create a list to store the data\ndata = []\n\"\"\"\nUse heapq.heappush to push (priorityInt, value) \npairs to the queue\n\"\"\"\nheapq.heappush(data, (2, 'first item'))\nheapq.heappush(data, (1, 'second item'))\n\"\"\"\nThe tuples are stored in data in the order \nof ascending priority\n\"\"\"\n[(1, 'second item'), (2, 'first item')]\n\"\"\"\nheapq.heappop pops the item with the lowest score \nfrom the queue\n\"\"\"\nheapq.heappop(data)\n```", "```py\n(1, 'second item')\n```", "```py\ndata\n```", "```py\n[(2, 'first item')]\n```", "```py\nimport math\nimport heapq\n```", "```py\nfrontier = []\ninternal = set()\nheapq.heappush(frontier, (0, start))\ncosts = initialize_costs(size, start)\n```", "```py\ndef distance_heuristic(node, goal):\n    (x, y) = node\n    (u, v) = goal\n    return math.sqrt(abs(x - u) ** 2 + abs(y - v) ** 2)\n```", "```py\ndef astar(start, end):\n    frontier = []\n    internal = set()\n    heapq.heappush(frontier, (0, start))\n    costs = initialize_costs(size, start)\n    def get_distance_from_start(node):\n       return costs[node[0] - 1][node[1] - 1]\n    def set_distance_from_start(node, new_distance):\n        costs[node[0] - 1][node[1] - 1] = new_distance\n    while len(frontier) > 0:\n        (priority, node) = heapq.heappop(frontier)\n        if node == end:\n            return priority\n        internal.add(node)\n        successor_nodes = successors(node, internal)\n        for s in successor_nodes:\n            new_distance = get_distance_from_start(node) + 1\n            if new_distance < get_distance_from_start(s):\n                set_distance_from_start(s, new_distance)\n                # Filter previous entries of s\n                frontier = [n for n in frontier if s != n[1]]\n                heapq.heappush(frontier, \\\n                              (new_distance \\\n                              + distance_heuristic(s, end), s))\nastar(start, end)\n```", "```py\n15.0\n```", "```py\ndef astar_verbose(start, end):\n    frontier = []\n    internal = set()\n    heapq.heappush(frontier, (0, start))\n    costs = initialize_costs(size, start)\n    def get_distance_from_start(node):\n        return costs[node[0] - 1][node[1] - 1]\n    def set_distance_from_start(node, new_distance):\n        costs[node[0] - 1][node[1] - 1] = new_distance\n    steps = 0\n    while len(frontier) > 0:\n        steps += 1\n        print('step ', steps, '. frontier: ', frontier)\n        (priority, node) = heapq.heappop(frontier)\n        print('node ', node, \\\n              'has been popped from frontier with priority', \\\n              priority)\n        if node == end:\n            print('Optimal path found. Steps: ', steps)\n            print('Costs matrix: ', costs)\n            return priority\n        internal.add(node)\n        successor_nodes = successors(node, internal)\n        print('successor_nodes', successor_nodes)\n        for s in successor_nodes:\n            new_distance = get_distance_from_start(node) + 1\n            print('s:', s, 'new distance:', new_distance, \\\n                  ' old distance:', get_distance_from_start(s))\n            if new_distance < get_distance_from_start(s):\n                set_distance_from_start(s, new_distance)\n                # Filter previous entries of s\n                frontier = [n for n in frontier if s != n[1]]\n                new_priority = new_distance \\\n                               + distance_heuristic(s, end)\n                heapq.heappush(frontier, (new_priority, s))\n                print('Node', s, \\\n                      'has been pushed to frontier with priority', \\\n                      new_priority)\n    print('Frontier', frontier)\n    print('Internal', internal)\n    print(costs)\nastar_verbose(start, end)\n```", "```py\ndef get_shortest_path(end_node):\n    path = [end_node]\n    distance = get_distance_from_start(end_node)\n    while distance > 0:\n        for neighbor in successors(path[-1], []):\n            new_distance = get_distance_from_start(neighbor)\n            if new_distance < distance:\n                path += [neighbor]\n                distance = new_distance\n                break  # for\n    return path\n```", "```py\ndef astar_with_path(start, end):\n    frontier = []\n    internal = set()\n    heapq.heappush(frontier, (0, start))\n    costs = initialize_costs(size, start)\n    def get_distance_from_start(node):\n        return costs[node[0] - 1][node[1] - 1]\n    def set_distance_from_start(node, new_distance):\n        costs[node[0] - 1][node[1] - 1] = new_distance\n    def get_shortest_path(end_node):\n        path = [end_node]\n        distance = get_distance_from_start(end_node)\n        while distance > 0:\n            for neighbor in successors(path[-1], []):\n                new_distance = get_distance_from_start(neighbor)\n                if new_distance < distance:\n                    path += [neighbor]\n                    distance = new_distance\n                    break  # for\n        return path\n    while len(frontier) > 0:\n        (priority, node) = heapq.heappop(frontier)\n        if node == end:\n            return get_shortest_path(end)\n        internal.add(node)\n        successor_nodes = successors(node, internal)\n        for s in successor_nodes:\n            new_distance = get_distance_from_start(node) + 1\n            if new_distance < get_distance_from_start(s):\n                set_distance_from_start(s, new_distance)\n                # Filter previous entries of s\n                frontier = [n for n in frontier if s != n[1]]\n                heapq.heappush(frontier, \\\n                              (new_distance \\\n                              + distance_heuristic(s, end), s))\nastar_with_path( start, end )\n```", "```py\npip install simpleai\n```", "```py\nfrom simpleai.search import SearchProblem, astar\n```", "```py\nimport math\nfrom simpleai.search import SearchProblem, astar\nclass ShortestPath(SearchProblem):\n    def __init__(self, size, start, end, obstacles):\n        self.size = size\n        self.start = start\n        self.end = end\n        self.obstacles = obstacles\n        super(ShortestPath, \\\n              self).__init__(initial_state=self.start)\n    def actions(self, state):\n        (row, col) = state\n        (max_row, max_col) = self.size\n        succ_states = []\n        if row > 1:\n            succ_states += [(row-1, col)]\n        if col > 1:\n            succ_states += [(row, col-1)]\n        if row < max_row:\n            succ_states += [(row+1, col)]\n        if col < max_col:\n            succ_states += [(row, col+1)]\n        return [s for s in succ_states \\\n                if s not in self.obstacles]\n    def result(self, state, action):\n        return action\n    def is_goal(self, state):\n        return state == end\n    def cost(self, state, action, new_state):\n        return 1\n    def heuristic(self, state):\n        (x, y) = state\n        (u, v) = self.end\n        return math.sqrt(abs(x-u) ** 2 + abs(y-v) ** 2)\nsize = (7, 9)\nstart = (5, 3)\nend = (6, 9)\nobstacles = {(3, 4), (3, 5), (3, 6), (3, 7), (3, 8), \\\n             (4, 5), (5, 5), (5, 7), (5, 9), (6, 2), \\\n             (6, 3), (6, 4), (6, 5), (6, 7), (7, 7)} \nsearchProblem = ShortestPath(size, start, end, obstacles)\nresult = astar(searchProblem, graph_search=True)\nresult.path()\n```", "```py\ndef min_max( state, depth, is_maximizing):\n    if depth == 0 or is_end_state( state ):\n        return utility( state )\n    if is_maximizing:\n        utility = 0\n        for s in successors( state ):\n            score = MinMax( s, depth - 1, false )\n            utility = max( utility, score )\n        return utility\n    else:\n        utility = infinity\n        for s in successors( state ):\n            score = MinMax( s, depth - 1, true )\n            utility = min( utility, score )\n        return utility\n```", "```py\ndef min_max(state, depth, is_maximizing, alpha, beta):\n    if depth == 0 or is_end_state(state):\n        return utility(state)\n    if is_maximizing:\n        utility = 0\n        for s in successors(state):\n            score = MinMax(s, depth - 1, false, alpha, beta)\n            utility = max(utility, score)\n            alpha = max(alpha, score)\n            if beta <= alpha:\n                break\n        return utility\n    else:\n        utility = infinity\n        for s in successors(state):\n            score = MinMax(s, depth - 1, true, alpha, beta)\n            utility = min(utility, score)\n        return utility\n```", "```py\ndef min_max(state, depth, is_maximizing, alpha, beta):\n    if depth == 0 or is_end_state( state ):\n        return utility(state)\n    if is_maximizing:\n        utility = 0\n        for s in successors(state):\n            score = min_max(s, depth - 1, false, alpha, beta)\n            utility = max(utility, score)\n            alpha = max(alpha, score)\n            if beta <= alpha: break\n        return utility\n    else:\n        utility = infinity\n        for s in successors(state):\n            score = min_max(s, depth - 1, true, alpha, beta)\n            utility = min(utility, score)\n            beta = min(beta, score)\n            if beta <= alpha: break\n        return utility\n```", "```py\nalpha = infinity\nbeta = -infinity\n```", "```py\ndef Negamax(state, depth, is_players_point_of_view):\n    if depth == 0 or is_end_state(state):\n        return utility(state, is_players_point_of_view)\n    utility = 0\n    for s in successors(state):\n        score = Negamax(s,depth-1,not is_players_point_of_view)\n    return score\n```", "```py\n!pip install easyAI\n```"]