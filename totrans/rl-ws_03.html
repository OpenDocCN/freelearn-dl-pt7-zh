<html><head></head><body>
		<div>
			<div id="_idContainer354" class="Content">
			</div>
		</div>
		<div id="_idContainer355" class="Content">
			<h1 id="_idParaDest-93"><a id="_idTextAnchor131"/>3. Deep Learning in Practice with TensorFlow 2</h1>
		</div>
		<div id="_idContainer385" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter will introduce you to TensorFlow and Keras and provide an overview of their key features and applications, as well as how they work in synergy. You will be able to implement a deep neural network with TensorFlow by addressing the main topics, from model creation, training, and validation, to testing. You will perform a regression task and solve a classification problem, thereby gaining hands-on experience with the frameworks. Finally, you will build and train a model to classify clothes images with high accuracy. By the end of this chapter, you will be able to design, build, and train deep learning models using the most advanced machine learning frameworks available.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor132"/>Introduction</h1>
			<p>In the previous chapter, we covered the theory behind Reinforcement Learning (RL), explaining topics such as Markov chains and Markov Decision Processes (MDPs), Bellman equations, and a number of techniques we can use to solve MDPs. In this chapter, we will be looking at deep learning methods, all of which will play a primary role in building approximate functions for reinforcement learning. Specifically, we will look at different families of deep neural networks: fully connected, convolutional, and recurrent networks. These algorithms have the key capability of encoding knowledge that's been learned through examples in a compact and effective representation. In RL, they are typically used to approximate the so-called policy functions and value functions, which encode how the RL agent chooses its action, given the current state and the value associated with the current state, respectively. We will study the policy and value functions in the upcoming chapters.</p>
			<p><em class="italic">Data is the new oil</em>: This famous quote is being heard more and more frequently these days, especially in tech and economic industries. With the great amount of data available today, techniques to leverage such enormous quantities of information, thereby creating value and opportunities, are becoming key competitive factors and skills to have. All products and platforms that are provided to users for free (from social networks to apps related to wearable devices) use data that is provided by the users to generate revenues: think about the huge quantity of information they collect every day relating to our habits, preferences, or even body weight trends. These provide high-value insights that can be leveraged by advertisers, insurance companies, and local businesses to improve their offers so that they fit the market.</p>
			<p>Thanks to the relevant increase in computational power availability and theory breakthroughs such as backpropagation-based training, deep learning has seen an explosion in the last 10 years, achieving unprecedented results in many fields, from image processing to speech recognition to natural language processing and understanding. In fact, it is now possible to successfully train large and deep neural networks by leveraging huge amounts of data and overcoming practical roadblocks that impeded their adoption in past decades. These models demonstrated the capability to exceed human performances in terms of both speed and accuracy. This chapter will teach you how to adopt deep learning to solve real-world problems by taking advantage of the top machine learning frameworks. TensorFlow and Keras, are the de facto production standards in the industry. Their success is mainly related to two aspects: TensorFlow's unrivaled performance in production environments in terms of both speed and scalability, and Keras' ease of use, which provides a very powerful, high-level interface that can be used to create deep learning models.</p>
			<p>Now, let's take a look at the frameworks.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor133"/>An Introduction to TensorFlow and Keras</h1>
			<p>In this section, both frameworks will be presented, thus providing you with a general overview of their architecture, the fundamental elements they are composed of, and listing some of their typical applications.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor134"/>TensorFlow</h2>
			<p>TensorFlow is an open source numerical computation software library that leverages data flow computational graphs. Its architecture allows users to run it on a wide variety of hardware: from CPUs to <strong class="bold">Tensor Processing Units</strong> (<strong class="bold">TPUs</strong>), including GPUs as well as mobile and embedded platforms. The main difference between the three is the speed and the type of data they are able to perform computations with (multiplications and additions), which, of course, is of primary importance when aiming for maximum performance. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">We will be looking at various code implementation examples for TensorFlow in the <em class="italic">Keras</em> section of this chapter.</p>
			<p class="callout">You can refer to the official documentation of TensorFlow for more information here: <a href="https://www.tensorflow.org/">https://www.tensorflow.org/</a></p>
			<p class="callout">The following article is a very good reference if you wish to find out more about the differences between GPUs and TPUs: <a href="https://iq.opengenus.org/cpu-vs-gpu-vs-tpu/">https://iq.opengenus.org/cpu-vs-gpu-vs-tpu/</a></p>
			<p>TensorFlow is based on a high-performance core implemented in C++ that's provided by a distributed execution engine that works as an abstraction toward the many devices it supports. We will be using TensorFlow 2, which has recently been released. It represents a major milestone for TensorFlow. Its main differences with respect to version 1 are related to its greater ease of use, in particular for model building. In fact, Keras has become the lead tool that's used to easily create models and experiment with them. TensorFlow 2 uses eager execution by default. This allowed the creators of TensorFlow to eliminate the previous complex workflow, which was based on the construction of a computational graph that's then run in a session. With eager execution, this is no longer required. Finally, the data pipeline has been simplified by means of the TensorFlow dataset, which is a common interface that's used to ingest standard or custom datasets with no need to define placeholders.</p>
			<p>The execution engine is then interfaced with Python and C++ frontends, which, in turn, are the basis for the Layers API, which provides a simple interface for common layers in deep learning models. This hierarchical structure continues with higher-level APIs, including Keras (which we will describe later in this section). Finally, a set of common models are provided and can be used out of the box.</p>
			<p>The following diagram provides an overview of how different TensorFlow modules are hierarchically organized, starting from the low level (bottom) up to the highest level (top):</p>
			<div>
				<div id="_idContainer356" class="IMG---Figure">
					<img src="image/B16182_03_01.jpg" alt="Figure 3.1: TensorFlow architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1: TensorFlow architecture</p>
			<p>The historical execution model of TensorFlow was based on computational graphs. Using this approach, the first step when building a model is to create a computation graph that fully describes the calculations we want to perform. The second step is to execute it. This approach has the drawback of being less intuitive with respect to common implementations, where the graph doesn't have to be completed before it can be executed. At the same time, it provides several advantages, making the algorithm highly portable, deployable on different types of hardware platforms, and capable of running in parallel on multiple instances. </p>
			<p>In the latest version of TensorFlow (starting with v. 1.7), a new execution model called "eager execution" has been introduced. This is an imperative style for writing code. With eager execution enabled, all algorithmic operations can be run immediately, with no need to build a graph first and then execute it. This new approach has been greeted with enthusiasm and has some very important pros: first, it is much simpler to inspect and debug algorithms and access intermediate values; it is possible to directly use a Python control flow inside TensorFlow APIs; and it makes building and training complex algorithms very easy. </p>
			<p>In addition, once the model that has been created using eager execution satisfies requirements, it is possible to automatically convert it into a graph, which makes it possible to leverage all the advantages we looked at previously, such as saving, porting, and distributing models optimally.</p>
			<p>Like other machine learning frameworks, TensorFlow provides a large number of ready-to-use models and for many of them, it also provides trained model weights along with the model graph, meaning we can run such models out of the box, and even tune them for a specific use case to take advantage of techniques such as transfer learning with fine tuning. We will cover these in the following sections.</p>
			<p>The models provided cover a wide range of different applications, for example:</p>
			<ul>
				<li><strong class="bold">Image classification</strong>: Able to classify images into categories.</li>
				<li><strong class="bold">Object detection</strong>: Capable of detecting and localizing multiple objects in images.</li>
				<li><strong class="bold">Language understanding and translation</strong>: Performing natural language processing for tasks such as word prediction and translation.</li>
				<li><strong class="bold">Patch harmonization and style transfer</strong>: The algorithm is able to apply a given style (represented, for example, through a painting) to a given photo (refer to the following example).</li>
			</ul>
			<p>As we mentioned previously, many of the models include trained weights and examples explaining how to use them. Thus, it is very straightforward to adopt "transfer learning," that is, to take advantage of these pretrained models by creating new ones, retraining only a part of the network on a new dataset. This can be significantly smaller with respect to the one used to train the entire network from scratch. </p>
			<p>TensorFlow models can also be deployed on mobile devices. After being trained on large systems, they are optimized to reduce their footprint, which cannot be too big to meet platform limitations. For example, the TensorFlow project known as <strong class="bold">MobileNet</strong> is developing a set of computer vision models specifically designed with optimal speed/accuracy trade-offs in mind. These are typically considered for embedded devices and mobile applications.</p>
			<p>The following image represents a typical example of an object detection application where the input image is processed and three objects have been detected, localized, and classified:</p>
			<div>
				<div id="_idContainer357" class="IMG---Figure">
					<img src="image/B16182_03_02.jpg" alt="Figure 3.2: Object detection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2: Object detection</p>
			<p>The following image shows how style transfer works: the style of the famous painting "<em class="italic">The Great Wave off Kanagawa</em>" has been applied to a photo of the Seattle skyline. The results keep the key parts of the picture (the majority of the buildings are there, mountains, and so on), but it is represented through stylistic elements that have been extrapolated from the reference image:</p>
			<div>
				<div id="_idContainer358" class="IMG---Figure">
					<img src="image/B16182_03_03.jpg" alt="Figure 3.3: Style transfer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3: Style transfer</p>
			<p>Now, let's learn about Keras.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor135"/>Keras</h2>
			<p>Building deep learning models is quite complex, especially when we have to deal with all the typical low-level aspects of major frameworks, and this is one of the most relevant barriers for newcomers in the machine learning field. As an example, the following code shows how to create a simple neural network (one hidden layer with an input size of <strong class="source-inline">100</strong> and an output size of <strong class="source-inline">10</strong>) with a low-level TensorFlow API.</p>
			<p>In the following code snippet, two functions are being defined. The first builds the weights matrix of a network layer, while the second one creates the bias vector:</p>
			<p class="source-code">def weight_variable(shape):</p>
			<p class="source-code">    shape = tf.TensorShape(shape)</p>
			<p class="source-code">    initial_values = tf.truncated_normal(shape, stddev=0.1)</p>
			<p class="source-code">    return tf.Variable(initial_values)</p>
			<p class="source-code">def bias_variable(shape):</p>
			<p class="source-code">    initial_values = tf.zeros(tf.TensorShape(shape))</p>
			<p class="source-code">    return tf.Variable(initial_values)</p>
			<p>Next, the placeholders for the input (<strong class="source-inline">X</strong>) and labels (<strong class="source-inline">y</strong>) are created. They will contain the training samples that will be used to fit the model:</p>
			<p class="source-code"># Define placeholders</p>
			<p class="source-code">X = tf.placeholder(tf.float32, shape=[None, 100])</p>
			<p class="source-code">y = tf.placeholder(tf.int32, shape=[None, 10])</p>
			<p>Two matrices and two vectors are created, one couple for each of the two hidden layers of the network to be created, with the functions previously defined. These will contain trainable parameters (network weights):</p>
			<p class="source-code"># Define variables</p>
			<p class="source-code">w1 = weight_variable([X_input.shape[1], 64])</p>
			<p class="source-code">b1 = bias_variable([64])</p>
			<p class="source-code">w2 = weight_variable([64, 10])</p>
			<p class="source-code">b2 = bias_variable([10])</p>
			<p>The two network layers are defined via their mathematical definition: matrix multiplication, plus the bias sum and activation function applied to the result:</p>
			<p class="source-code"># Define network</p>
			<p class="source-code"># Hidden layer</p>
			<p class="source-code">z1 = tf.add(tf.matmul(X, w1), b1)</p>
			<p class="source-code">a1 = tf.nn.relu(z1)</p>
			<p class="source-code"># Output layer</p>
			<p class="source-code">z2 = tf.add(tf.matmul(a1, w2), b2)</p>
			<p class="source-code">y_pred = tf.nn.softmax(z2)</p>
			<p class="source-code">y_one_hot = tf.one_hot(y, 10)</p>
			<p>The <strong class="source-inline">loss</strong> function is defined, the optimizer is initialized, and the training metrics are chosen. Finally, the graph is run to perform training:</p>
			<p class="source-code"># Define loss function</p>
			<p class="source-code">loss = tf.losses.softmax_cross_entropy(y, y_pred, \</p>
			<p class="source-code">       reduction=tf.losses.Reduction.MEAN)</p>
			<p class="source-code"># Define optimizer</p>
			<p class="source-code">optimizer = tf.train.AdamOptimizer(0.01).minimize(loss)</p>
			<p class="source-code"># Metric</p>
			<p class="source-code">accuracy = tf.reduce_mean(tf.cast(tf.equal(tf.argmax(y, axis=1), \</p>
			<p class="source-code">           tf.argmax(y_pred, axis=1)), tf.float32))</p>
			<p class="source-code">for _ in range(n_epochs):</p>
			<p class="source-code">    sess.run(optimizer, feed_dict={X: X_train, y: y_train})</p>
			<p>As you can see, we need to manually manage many different aspects: variable declaration, weights initialization, layer creation, layer-related mathematical operations, and the definition of the loss function, optimizers, and metrics. For comparison, the same neural network will be created using Keras later in this section.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The preceding code snippet is an example that demonstrates how to implement a simple fully connected neural network with a TensorFlow low-level API. In <em class="italic">Exercise 3.01, Building a Sequential Model with the Keras High-Level API</em>, you will see how much more straightforward it is to do the same job using a Keras high-level API.</p>
			<p>Among many different proposals, Keras has become one of the main references for high-level APIs, especially the context of those targeted at creating neural networks. It is written in Python and can be interfaced with different backend computation engines, one of which is, of course, TensorFlow.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can refer to the official documentation for further reading on Keras here: <a href="https://keras.io/">https://keras.io/</a>.</p>
			<p>Keras' conception has been driven by some clear principles, in particular, modularity, user friendliness, easy extendibility, and its straightforward integration with Python. Its aim is to favor adoption by newcomers and non-experienced users, and it presents a very gentle learning curve. It provides many different standalone modules, ranging from neural network layers to optimizers, from initialization schemes to cost functions. These can be easily created to create deep learning models quickly and to code them directly in Python, with no need to use separate configuration files. Given these features, its wide adoption, the fact that it can be interfaced with a large number of different backend engines (for example, TensorFlow, CNTK, Theano, MXNet, and PlaidML) and its wide choice of deployment options, it has risen to become the standard choice in the field.</p>
			<p>Since it doesn't have its own low-level implementation, Keras needs to rely on an external element. This can be easily modified by editing (for Linux users) the <strong class="source-inline">$HOME/.keras/keras.json</strong> file, where it is possible to specify the backend name. It is also possible to specify it by means of the <strong class="source-inline">KERAS_BACKEND</strong> environment variable.</p>
			<p>Keras' fundamental class is <strong class="source-inline">Model</strong>. There are two different types of model available: The sequential model (which we will use extensively), and the <strong class="source-inline">Model</strong> class, which is used with the functional API.</p>
			<p>The sequential model can be seen as a linear stack of layers, piled one after the other in a very simple way, and these layers can be described very easily. The following exercise shows how short a Python script in Keras that builds a deep neural network using <strong class="source-inline">model.add()</strong> can be in order to define two dense layers in a sequential model.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor136"/>Exercise 3.01: Building a Sequential Model with the Keras High-Level API</h2>
			<p>This exercise shows how to easily build a sequential model, composed of two dense layers, with the Keras high-level API, step by step:</p>
			<ol>
				<li>Import the TensorFlow module and print its version:<p class="source-code">import tensorflow as tf</p><p class="source-code">from __future__ import absolute_import, division, \</p><p class="source-code">print_function, unicode_literals</p><p class="source-code">import tensorflow as tf</p><p class="source-code">print("TensorFlow version: {}".format(tf.__version__))</p><p>This outputs the following line:</p><p class="source-code">TensorFlow version: 2.1.0</p></li>
				<li>Build the model using Keras' <strong class="source-inline">sequential</strong> and <strong class="source-inline">add</strong> methods and print a network summary. To continue in parallel with a low-level API, the same activation functions are used. We are using <strong class="source-inline">ReLu</strong> here, which is a typical activation function that's used for hidden layers. It is a key element that provides nonlinearity to the model thanks to its nonlinear shape. We also use <strong class="source-inline">Softmax</strong>, which is the activation function typically used for output layers in classification problems. It receives the output values (so-called "logits") from the previous layer and performs a weighting of them, defining all the probabilities of the output classes. The <strong class="source-inline">input_dim</strong> is the dimension of the input feature vector; it is assumed to have a dimension of <strong class="source-inline">100</strong>:<p class="source-code">model = tf.keras.Sequential()</p><p class="source-code">model.add(tf.keras.layers.Dense(units=64, \</p><p class="source-code">                                activation='relu', input_dim=100))</p><p class="source-code">model.add(tf.keras.layers.Dense(units=10, activation='softmax'))</p></li>
				<li>Print the standard model architecture: <p class="source-code">model.summary()</p><p>In our case, the network model summary is as follows:</p><p class="source-code">Model: "sequential_1"</p><p class="source-code">_________________________________________________________________</p><p class="source-code">Layer (type)                 Output Shape              Param #   </p><p class="source-code">=================================================================</p><p class="source-code">dense_2 (Dense)              (None, 64)                6464      </p><p class="source-code">_________________________________________________________________</p><p class="source-code">dense_3 (Dense)              (None, 10)                650       </p><p class="source-code">=================================================================</p><p class="source-code">Total params: 7,114</p><p class="source-code">Trainable params: 7,114</p><p class="source-code">Non-trainable params: 0</p><p class="source-code">_________________________________________________________________</p><p>The preceding output is a useful visualization that gives us a clear understanding of layers, their type and shape, and the number of network parameters.</p><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/30A9Dw9">https://packt.live/30A9Dw9</a>.</p><p class="callout">You can also run this example online at <a href="https://packt.live/3cT0cKL">https://packt.live/3cT0cKL</a>.</p></li>
			</ol>
			<p>As anticipated, this exercise showed us how to create a sequential model and how to add two layers to it in a very straightforward way. </p>
			<p>We will deal with the remaining aspects later on, but it is still worth noting that training the model we just created and performing inference only requires very few lines of code, as presented in the following snippet, which needs to be appended to the snippet of <em class="italic">Exercise 3.01, Building a Sequential Model with the Keras High-Level API</em>: </p>
			<p class="source-code">model.compile(loss='categorical_crossentropy', optimizer='sgd', \</p>
			<p class="source-code">              metrics=['accuracy'])</p>
			<p class="source-code">model.fit(x_train, y_train, epochs=5, batch_size=32)</p>
			<p class="source-code">loss_and_metrics = model.evaluate(x_test, y_test, batch_size=128)</p>
			<p class="source-code">classes = model.predict(x_test, batch_size=128)</p>
			<p>If more complex models are required, the sequential API is too limited. For these needs, Keras provides the functional API, which allows us to create models that are able to manage complex networks graphs, such as networks with multiple inputs and/or multiple outputs, recurrent neural networks where data processing is not sequential but instead is cyclic, and context, where layers' weights are shared among different parts of the network. For this purpose, Keras allows us to leverage the same set of layers as the sequential model, but provides more flexibility in putting them together. First, we have to define the layers and put them together. An example is presented in the following snippet.</p>
			<p>First, after importing TensorFlow, an input layer of dimension <strong class="source-inline">784</strong> is created:</p>
			<p class="source-code">import tensorflow as tf</p>
			<p class="source-code">inputs = tf.keras.layers.Input(shape=(784,))</p>
			<p>Inputs are processed by the first hidden layer. They go through the ReLu activation function and are returned as output. This output then becomes the input for the second hidden layer, which is exactly the same as the first one, and returns another output, again stored in the <strong class="source-inline">x</strong> variable:</p>
			<p class="source-code">x = tf.keras.layers.Dense(64, activation='relu')(inputs)</p>
			<p class="source-code">x = tf.keras.layers.Dense(64, activation='relu')(x)</p>
			<p>Finally, the <strong class="source-inline">x</strong> variable goes as input to the final output layer, which has a <strong class="source-inline">softmax</strong> activation function, and returns predictions:</p>
			<p class="source-code">predictions = tf.keras.layers.Dense(10, activation='softmax')(x)</p>
			<p>Once all the passages have been completed, the model can be created by telling Keras where it starts (input variable) and where it ends (predictions variable):</p>
			<p class="source-code">model = tf.keras.models.Model(inputs=inputs, outputs=predictions)</p>
			<p>After the model has been built, it is compiled by specifying the optimizer, the loss, and the metrics. Finally, it is fitted onto the training data:</p>
			<p class="source-code">model.compile(optimizer='rmsprop', \</p>
			<p class="source-code">              loss='categorical_crossentropy', \</p>
			<p class="source-code">              metrics=['accuracy'])</p>
			<p class="source-code">model.fit(data, labels)  # starts training</p>
			<p>Keras provides a large number of predefined layers, as well as the possibility to code custom ones. Among those, the following are the already available layers:</p>
			<ul>
				<li>Dense layers, which are typically used for fully connected neural networks. They consist of a matrix of weights and a bias.</li>
				<li>Convolution layers are filters that are defined by specific kernels, which are then convolved with the inputs they are applied to. There are layers available for different input dimensions, from 1D to 3D, including the possibility to embed in them complex operations, such as cropping or transposition.</li>
				<li>Locally connected layers are similar to convolution layers in the sense that they act only on a subgroup of the input features, but, unlike convolution layers, they don't share weights.</li>
				<li>Pooling layers are layers that are used to downscale the input. As convolutional layers, they are available for inputs with dimensionality ranging from 1D to 3D. They include most of the common variants, such as max and average pooling.</li>
				<li>Recurrent layers are used for recurrent neural networks, where the output of a layer is also fed backward in the network. They support state-of-the-art units such as <strong class="bold">Gated Recurrent Units</strong> (<strong class="bold">GRUs</strong>), <strong class="bold">Long Short-Term Memory</strong> (<strong class="bold">LSTM</strong>) units, and others.</li>
				<li>Activation functions are also available in the form of layers. These are functions that are applied to layer outputs, such as <strong class="source-inline">ReLu</strong>, <strong class="source-inline">Elu</strong>, <strong class="source-inline">Linear</strong>, <strong class="source-inline">Tanh</strong>, and <strong class="source-inline">Softmax</strong>. </li>
				<li>Lambda layers are layers for embedding arbitrary, user-defined expressions.</li>
				<li>Dropout layers are special objects that randomly set a fraction of the input units to <strong class="source-inline">0</strong> at each training update to avoid overfitting (more on this later).</li>
				<li>Noise layers are additional layers, such as dropout, that are used to avoid overfitting.</li>
			</ul>
			<p>Keras also provides common datasets, as well as famous models. For image-related applications, many networks are available, such as Xception, VGG16, VGG19, ResNet50, InceptionV3, InceptionResNetV2, MobileNet, DenseNet, NASNet, and MobileNetV2TK, all of which are pretrained on ImageNet. Keras also provides text and sequences and generative models, making a total of more than 40 algorithms.</p>
			<p>As we saw for TensorFlow, Keras models have a vast choice of deployment platforms, including iOS, via CoreML (supported by Apple); Android, via the TensorFlow Android runtime; in a browser, via Keras.js and WebDNN; on Google Cloud, via TensorFlow-Serving; in a Python webapp backend; on the JVM, via DL4J model import; and on a Raspberry Pi.</p>
			<p>Now that we've looked at both TensorFlow and Keras, from the next section onward, our main focus will be on how to use them in combination to create deep neural networks. Keras will be used as a high-level API, given its user-friendliness, including TensorFlow, which will be the backend.</p>
			<h1 id="_idParaDest-99">How<a id="_idTextAnchor137"/> to Implement a Neural Network Using TensorFlow</h1>
			<p>In this section, we will look at the most important aspects to consider when implementing a deep neural network. Starting with the very basic concepts, we will go through all the steps that lead up to the creation of a state-of-the-art deep learning model. We will cover the network architecture's definition, training strategies, and performance improvement techniques, understanding how they work, and preparing you so that you can tackle the next section's exercises, where these concepts will be applied to solve real-world problems.</p>
			<p>To successfully implement a deep neural network in TensorFlow, we have to complete a given number of steps. These can be summarized and grouped as follows:</p>
			<ol>
				<li value="1"><strong class="bold">Model creation</strong>: Network architecture definition, input features encoding, embeddings, output layers</li>
				<li><strong class="bold">Model training</strong>: Loss function definition, optimizer choice, features normalization, backpropagation</li>
				<li><strong class="bold">Model validation</strong>: Strategies and key elements</li>
				<li><strong class="bold">Model improvement</strong>: Overfitting countermeasures</li>
				<li><strong class="bold">Model test and inference</strong>: Performance evaluation and online predictions</li>
			</ol>
			<p>Let's look at each of these steps in detail.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor138"/>Model Creation</h2>
			<p>The very first step is to create a model. Choosing an architecture is hardly something that can be done <em class="italic">a priori</em> on paper. It is a typical process that requires experimentation, going back and forth between model design and field validation and testing. This is the phase where all network layers are created and properly linked to generate a complete processing operation set that goes from inputs to outputs.</p>
			<p>The very first layer is the one that is interfaced with input data, specifically, the so-called "input features." In the case of images, for example, input features are image pixels. Depending on the nature of the layer, the input features' dimensionality needs to be taken into account. You will learn how to choose layer dimensions, depending on the layer's nature, in the upcoming sections.</p>
			<p>The very last layer is called the output layer. It generates model predictions, so its dimensions depend on the nature of the problem. For example, in classification problems, where the model has to predict in which of the, say, 10 classes a given instance falls, the model will have 10 neurons in the output layer providing 10 scores (one per class). In the upcoming sections, we will illustrate how to create output layers with the correct dimensions. </p>
			<p>Between the first and last layers, there are intermediate layers, called hidden layers. These layers constitute the network architecture, and they are responsible for the core processing capabilities of the model. At the time of writing, a rule that can be used to choose the best network architecture doesn't exist; this is a process that requires a lot of experimentation, under the guidance of some general principles. </p>
			<p>A very powerful and common approach is to leverage proven models from academic papers, using them as a starting point, and then adjusting the architecture appropriately to fit and fine-tune it to the custom problem. When pretrained literature models are used and fine-tuned, the procedure is called "transfer learning," meaning we are leveraging an already trained model and transferring its knowledge to the new model, which then won't start from scratch. </p>
			<p>Once the model has been created, all its parameters (weights/biases) must be initialized (for all non-pretrained layers). You might be tempted to set them all equal to zero, but this is hardly a good choice. There are many different initialization schemes available, and again, which one to choose requires experience and experimentation. This aspect will become clearer in the following sections. Implementation will rely on default initialization to be performed by Keras/TensorFlow, which is usually a good and safe starting point.</p>
			<p>A typical code example for model creation can be seen in the following snippet, which we studied in the previous section:</p>
			<p class="source-code">inputs = tf.keras.layers.Input(shape=(784,))</p>
			<p class="source-code">x = tf.keras.layers.Dense(64, activation='relu')(inputs)</p>
			<p class="source-code">x = tf.keras.layers.Dense(64, activation='relu')(x)</p>
			<p class="source-code">predictions = tf.keras.layers.Dense(10, activation='softmax')(x)</p>
			<p class="source-code">model = tf.keras.models.Model(inputs=inputs, outputs=predictions)</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor139"/>Model Training</h2>
			<p>When a model is initialized and applied to input data without undergoing a training phase, it outputs random values. In order to improve its performance, we need to adjust its parameters (weights) to minimize its errors. This is the aim of the model training stage, which requires the following steps: </p>
			<ol>
				<li value="1">First, we have to evaluate how "wrong" the model is with a given parameter configuration by computing a so-called "loss," which is a measure of model prediction error.</li>
				<li>Second, a hyperdimensional gradient is computed, which tells us how (in which direction) the model needs to change its parameters in order to improve current performance, thereby minimizing the loss function (it is indeed an optimization process).</li>
				<li>Finally, the model parameters are updated by taking a "step" in the negative gradient direction (following some precise rules) and the whole process restarts from the loss evaluation stage.</li>
			</ol>
			<p>This procedure is repeated as many times as needed until the system converges and the model reaches its maximum performance (minimum loss).</p>
			<p>A typical code example for model training is shown in the following snippet, which we studied in the previous sections:</p>
			<p class="source-code">model.compile(optimizer='rmsprop', \</p>
			<p class="source-code">              loss='categorical_crossentropy', \</p>
			<p class="source-code">              metrics=['accuracy'])</p>
			<p class="source-code">model.fit(data, labels)  # starts training</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor140"/>Loss Function Definition</h2>
			<p>Model error can be measured by means of different loss functions. How to choose the best one requires experience. For complex applications, we often need to carefully adapt the loss function in order to drive training in directions we are interested in. As an example, let's look at how to define a typical loss that's used for classification problems: the sparse categorical cross entropy. To create it in Keras, we can use the following instruction: </p>
			<p class="source-code">loss_CatCrossEntropy = tf.keras.losses\</p>
			<p class="source-code">                       .SparseCategoricalCrossentropy()</p>
			<p>This function operates on two inputs: true labels and predicted labels. Based on their values, it computes the loss associated with the model:</p>
			<p class="source-code">loss_CatCrossEntropy(y_true=groundTruth, y_pred=predictions)</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor141"/>Optimizer Choice</h2>
			<p>The second and third steps, estimating the gradient and updating the parameters, respectively, are addressed by optimizers. These objects calculate gradients and perform update steps in the gradient's direction to minimize model loss. There are many optimizers available, from the simplest ones to the most advanced (refer to the following diagram). They provide different performances, and which one to select is, again, a matter of experience and a trial-and-error process. As an example, the following code selects the <strong class="source-inline">Adam</strong> optimizer, assigning a specific learning rate of <strong class="source-inline">0.01</strong>. This parameter regulates how "large" the step taken will be along the gradient direction:</p>
			<p class="source-code">optimizer = tf.keras.optimizers.Adam(learning_rate=0.01)</p>
			<p class="source-code">optimizer = tf.keras.optimizers.Adadelta(learning_rate=0.01)</p>
			<p class="source-code">optimizer = tf.keras.optimizers.Adagrad(learning_rate=0.01)</p>
			<p class="source-code">optimizer = tf.keras.optimizers.Adamax(learning_rate=0.01)</p>
			<p class="source-code">optimizer = tf.keras.optimizers.Ftrl(learning_rate=0.01)</p>
			<p class="source-code">optimizer = tf.keras.optimizers.Nadam(learning_rate=0.01)</p>
			<p class="source-code">optimizer = tf.keras.optimizers.RMSprop(learning_rate=0.01)</p>
			<p class="source-code">optimizer = tf.keras.optimizers.SGD(learning_rate=0.01)</p>
			<p>The following diagram is an instantaneous snapshot comparing different optimizers. It shows how <em class="italic">quickly</em> they move toward the minimum, starting all at the same time. We can see how some of them are faster than others:</p>
			<div>
				<div id="_idContainer359" class="IMG---Figure">
					<img src="image/B16182_03_04.jpg" alt="Figure 3.4: Comparison of optimizer minimization steps&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4: Comparison of optimizer minimization steps</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The preceding diagram was created by Alec Radford (<a href="https://twitter.com/alecrad">https://twitter.com/alecrad</a>).</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor142"/>Learning Rate Scheduling</h2>
			<p>In most cases, and for most deep learning models, the best results are achieved if the learning rate is gradually reduced during training. The reason for this can be seen in the following diagram:</p>
			<div>
				<div id="_idContainer360" class="IMG---Figure">
					<img src="image/B16182_03_05.jpg" alt="Figure 3.5: Optimization behavior when using different learning rate values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5: Optimization behavior when using different learning rate values</p>
			<p>When approaching the minimum of the loss function, we want to take smaller and smaller steps to efficiently reach the very bottom of the hyperdimensional concavity. </p>
			<p>With Keras, it is possible to prescribe many different decreasing functions for the learning rate trend over epochs by means of a scheduler. One common choice is <strong class="source-inline">InverseTimeDecay</strong>. This can be implemented as follows:</p>
			<p class="source-code">lr_schedule = tf.keras.optimizers.schedules\</p>
			<p class="source-code">              .InverseTimeDecay(0.001,\</p>
			<p class="source-code">                                decay_steps=STEPS_PER_EPOCH*1000,\</p>
			<p class="source-code">                                decay_rate=1, staircase=False)</p>
			<p>The preceding code sets a decreasing function through <strong class="source-inline">InverseTimeDecay</strong> to hyperbolically decrease the learning rate to 1/2 of the base rate at 1,000 epochs, 1/3 at 2,000 epochs, and so on. This can be seen in the following graph:</p>
			<div>
				<div id="_idContainer361" class="IMG---Figure">
					<img src="image/B16182_03_06.jpg" alt="Figure 3.6: Inverse time decay learning rate scheduling&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6: Inverse time decay learning rate scheduling</p>
			<p>Then, it is applied to an optimizer as an argument, as shown in the following snippet for the <strong class="source-inline">Adam</strong> optimizer:</p>
			<p class="source-code">tf.keras.optimizers.Adam(lr_schedule)</p>
			<p>Each optimization step makes the loss drop, thereby improving the model. It is then possible to repeat the same process over and over until convergence is reached and the loss stops decreasing. The number of optimization steps performed is usually called the number of epochs. </p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor143"/>Feature Normalization</h2>
			<p>The broad applications for deep neural networks favor their usage on very different types of inputs, from image pixels to credit card transaction history, from social account profile habits to audio recordings. From this, it is clear that raw input features cover very different numerical scales. As mentioned previously, training these models requires solving an optimization problem using a loss gradient calculation. For this reason, numerical aspects are of paramount importance, resulting in a speeding up of the process, as well as making it more robust. One of the most important practices, in this context, is feature normalization or standardization. The most common approach consists of performing the following steps for each feature:</p>
			<ol>
				<li value="1">Calculating the mean and standard deviation using all the training set instances.</li>
				<li>Subtracting the mean and dividing by standard deviation. Values calculated on the training set must be applied to the training, validation, and test sets.</li>
			</ol>
			<p>This way, all the features will have zero mean and standard deviation equal to <strong class="source-inline">1</strong>. Different, but similar, approaches scale feature values between a user-defined minimum-maximum range (for example, between –1 and 1) or apply similar transformations (for example, log scaling). As usual, in the field, which approach works better is hardly predictable and requires experience and a trial-and-error approach.</p>
			<p>The following code snippet shows how data normalization is performed, wherein the mean and standard deviation of the original values are calculated, the mean is then subtracted from the original values, and the result is then divided by the standard deviation:</p>
			<p class="source-code">train_stats = train_dataset.describe()</p>
			<p class="source-code">train_stats = train_stats.transpose()</p>
			<p class="source-code">def norm(x):</p>
			<p class="source-code">    return (x - train_stats['mean']) / train_stats['std']</p>
			<p class="source-code">normed_train_data = norm(train_dataset)</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor144"/>Model Validation</h2>
			<p>As stated in the previous subsections, a large portion of choices require experimentation, meaning we have to select a given configuration and evaluate how the corresponding model performs. In order to compute this performance measure, the candidate model must be applied to a set of instances and its output compared against ground truth values. This step can be repeated many times, depending on how many alternative configurations we want to compare. In the long run, these configuration choices can suffer an excessive influence of the set of instances used to measure model performance. For this reason, in order to have a final accurate performance measure of the model of choice, it has to be tested on a new set of instances that have never been seen before. The first set of instances is called a "validation set," while the final one is called a "test set."</p>
			<p>There are different choices we can adopt when defining training, validation, and test sets, such as the following:</p>
			<ul>
				<li>70:20:10: The initial dataset is decomposed into three chunks, that is, the training, validation, and test sets, with the proportion 70:20:10, respectively.</li>
				<li>80:20 + k-Folding: The initial dataset is decomposed into two chunks, 80% training and 20% testing, respectively. Validation is performed using k-Folding on the training dataset: it is divided into 'k' folds and, in turn, training is carried out in 'k-1' folds, while validation is performed on the k-th piece. 'K' varies from 1 to k and metrics are averaged to obtain a global measure.</li>
			</ul>
			<p>Many variants of the preceding methods can be used. The choices are strictly related to the problem and the available dataset.</p>
			<p>The following code snippet shows how to prescribe an 80:20 split for validation when fitting a model on a training dataset:</p>
			<p class="source-code">model.fit(normed_train_data, train_labels, epochs=epochs, \</p>
			<p class="source-code">          validation_split = 0.2, verbose=2)</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor145"/>Performance Metrics</h2>
			<p>In order to measure performances, beside the loss functions, other metrics are usually adopted. There is a very wide set of metrics available, and the question as to which you should use depends on many factors, including the type of problem, dataset characteristics, and so on. The following is a list of the most common ones:</p>
			<ul>
				<li><strong class="bold">Mean Squared Error</strong> (<strong class="bold">MSE</strong>): Used for regression problems.</li>
				<li><strong class="bold">Mean Absolute Error</strong> (<strong class="bold">MAE</strong>): Used for regression problems.</li>
				<li>Accuracy: Number of correct predictions divided by the number of total tested instances. This is used for classification problems.</li>
				<li><strong class="bold">Receiver Operating Characteristic Area Under Curve</strong> (<strong class="bold">ROC</strong> <strong class="bold">AUC</strong>): Used for binary classification, especially in the presence of highly unbalanced data.</li>
				<li>Others: Fβ score, precision, and recall. </li>
			</ul>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor146"/>Model Improvement</h2>
			<p>In this section, we will look at a few techniques that can be used to improve the performance of a model.</p>
			<h3 id="_idParaDest-109"><a id="_idTextAnchor147"/>Overfitting</h3>
			<p>A common problem we may typically encounter when training deep neural networks is a critical drop in model performance (measured, of course, on the validation or test set) when the number of training epochs passes a given threshold, even if, at the same time, the training loss continues to decrease. This phenomenon is called <strong class="bold">overfitting</strong>. It can be defined as follows: a highly representative model, a model with the relevant number of degrees of freedom (for example, a neural network with many layers and neurons), if trained "<em class="italic">too much</em>," bends itself to adhere to the training data, with the intent to minimize the training loss. This results in poor generalization performances, making validation and/or test errors higher. Deep learning models, thanks to their high-dimensional parameter space, are usually very good at fitting the training data, but the actual aim of building a machine learning model is being able to generalize what has been learned, not merely fit a dataset.</p>
			<p>At this point, we might be tempted to significantly reduce the number of model parameters to avoid overfitting. But this would cause different problems. In fact, a model with an insufficient number of parameters would incur <strong class="bold">underfitting</strong>. Basically, it would not be able to properly fit the data, again resulting in poor performance, this time on both the training and validation/test sets.</p>
			<p>The correct solution is the one that finds a proper balance between having a large number of parameters that would perfectly fit training data and having too small a number of model degrees of freedom, resulting in it being able to capture important information from data. It is currently not possible to identify the right size for a model so that it won't face overfitting or underfitting problems. Experimentation is a key element in this regard, thereby requiring the data engineer to build and test different architectures. A good rule is to start with models with a relatively small number of parameters and then increase them until generalization performance grows.</p>
			<p>The best solution against overfitting is to enrich the training dataset with new data. Aim for complete coverage of the full range of inputs that are supported and expected by the model. New data should also contain additional information with respect to starting the dataset in order to effectively contrast overfitting and to result in a better generalization error. When collecting additional data is not possible or too expensive, it is necessary to adopt specific, very powerful techniques. The most important ones will be described here.</p>
			<h3 id="_idParaDest-110"><a id="_idTextAnchor148"/>Regularization</h3>
			<p>Regularization is one of the most powerful tools used to contrast overfitting. Given a network architecture and a set of training data, there is an entire space of possible weights that produce the same results. Every combination of weights in this space defines a specific model. As we saw in the preceding section, we have to prefer, as a general principle, simple models over complex ones. A common way to reach this goal is to force network weights to assume small values, thereby regularizing the distribution of weights. This can be achieved through "weight regularization". This consists of shaping the loss function so that it can take weight values into consideration, adding a new term to it that is directly proportional to their magnitude. Two approaches are usually encountered:</p>
			<ul>
				<li><strong class="bold">L1 regularization</strong>: The term that's added to the loss function is proportional to the absolute value of the weight coefficients, commonly referred to as the "L1 norm" of the weights.</li>
				<li><strong class="bold">L2 regularization</strong>: The term that's added to the loss function is proportional to the square of the value of the weight coefficients, commonly referred to as the "L2 norm" of the weights.</li>
			</ul>
			<p>Both of these have the effect of limiting the magnitude of the weights, but while L1 regularization tends to drive weights toward exactly zero, L2 regularization penalizes weights with a less strict constraint since the additional loss term grows at a higher rate. L2 is, in general, more common.</p>
			<p>Keras contains pre-built L1 and L2 regularization objects. The user has to pass them as arguments to the network layers that they want to apply the technique to. The following code shows how to apply it to a common dense layer:</p>
			<p class="source-code">tf.keras.layers.Dense(512, activation='relu', \</p>
			<p class="source-code">                      kernel_regularizer=tf.keras\</p>
			<p class="source-code">                                         .regularizers.l2(0.001))</p>
			<p>The parameter that was passed to the L2 regularizer (<strong class="source-inline">0.001</strong>) shows that an additional loss term equal to <strong class="source-inline">0.001 * weight_coefficient_value**2</strong> will be added to the total loss of the network for every coefficient in the weight matrix.</p>
			<h3 id="_idParaDest-111"><a id="_idTextAnchor149"/>Early Stopping</h3>
			<p>Early stopping is a specific form of regularization. The idea is to keep track of both training and validation errors during training and to continue training the model until both training and validation losses decrease. This allows us to spot the epochs threshold, after which the training loss' decrease would come as an expense of increased generalization error, so that we can stop training when validation/test performances have reached their maximum. One typical parameter the user has to choose when adopting this technique is the number of epochs the system should wait for and monitor before stopping the iterations if no improvement in the validation error is shown. This parameter is commonly named "patience."</p>
			<h3 id="_idParaDest-112"><a id="_idTextAnchor150"/>Dropout</h3>
			<p>One of the most popular and effective reliable regularization techniques for neural networks is Dropout. It was developed at the University of Toronto by Prof. Hinton and his research group.</p>
			<p>When Dropout is applied to a layer, a certain percentage of the layer output features during training are randomly set to zero (they drop out). For example, if the output of a given layer would normally have been [0.3, 0.4, 1.2, 0.1, 1.5] for a given set of input features during training, when dropout is applied, the same output vector will have some zero entries randomly distributed; for example, [0.3, 0, 1.2, 0.1, 0].</p>
			<p>The idea behind dropout is to encourage each node to output values that are highly informative and meaningful on their own, without relying on its neighboring ones.</p>
			<p>The parameter to be set when inserting a dropout layer is called the <strong class="bold">dropout rate</strong>: this represents the fraction of features that are being set to zero and is usually chosen in a range between <strong class="source-inline">0.2</strong> and <strong class="source-inline">0.5</strong>. When performing inference, dropout is deactivated, and an additional operation needs to be executed to take into account the fact that more units will be active with respect to training time. To re-establish a balance between these two situations, the layer's output values are multiplied by a factor equal to the dropout rate, resulting in a scaling-down operation. In Keras, dropout can be introduced in a network using the dropout layer, which is applied to the output of the layer immediately before it. Consider the following code snippet:</p>
			<p class="source-code">dropout_model = tf.keras.Sequential([</p>
			<p class="source-code">    #[...]</p>
			<p class="source-code">    tf.keras.layers.Dense(512, activation='relu'), \</p>
			<p class="source-code">    tf.keras.layers.Dropout(0.5), \</p>
			<p class="source-code">    tf.keras.layers.Dense(256, activation='relu'), \</p>
			<p class="source-code">    #[...]</p>
			<p class="source-code">    ])</p>
			<p>As you can see, dropout is applied to the layer with <strong class="source-inline">512</strong> neurons, setting 50% of their values to 0.0 at training time, and multiplying their values by 0.5 at inference time.</p>
			<h3 id="_idParaDest-113"><a id="_idTextAnchor151"/>Data Augmentation</h3>
			<p>Data augmentation is particularly useful when the number of instances available for training is limited. It is super easy to understand how it is implemented and works in the context of image processing. Suppose we want to train a network to classify images of different breeds of a specific species and we only have a limited number of examples for each breed. How can we enlarge the dataset to help the model generalize better? Data augmentation plays a major role in this context: the idea is to create new training instances, starting from those we already have and tweaking them appropriately. In the case of images, we can act on them by doing the following:</p>
			<ul>
				<li>Random rotations with respect to a point in the vicinity of the center </li>
				<li>Random crops</li>
				<li>Random affine transformations (shear, resize, and so on)</li>
				<li>Random horizontal/vertical flips</li>
				<li>White noise superimposition</li>
				<li>Salt and pepper noise superimposition</li>
			</ul>
			<p>These are a few examples of data augmentation techniques that can be used for images, which, of course, have counterparts in other domains. This approach makes the model way more robust and improves its generalization performance, allowing it to abstract notions and knowledge about the specific problem it is facing in a more general way by giving privilege to the most informative input features.</p>
			<h3 id="_idParaDest-114"><a id="_idTextAnchor152"/>Batch Normalization</h3>
			<p>Batch normalization is a technique that consists of applying a normalization transform to every batch of data. For example, in the context of training a deep network with a batch size of 128, meaning the system will process 128 training samples at a time, the batch normalization layer works this way:</p>
			<ol>
				<li value="1">It calculates the mean and variance for each feature using all the samples of the given batch.</li>
				<li>It subtracts the corresponding feature mean that was previously calculated from each feature of every batch sample.</li>
				<li>It divides each feature of every batch sample by the square root of the corresponding feature variance.</li>
			</ol>
			<p>Batch normalization has many benefits. It was initially proposed to solve <em class="italic">internal covariate shift</em>. While training deep networks, the layer's parameters continuously change, causing internal layers to constantly adapt and readjust to new distributions they see as inputs coming from the preceding layers. This is particularly critical for deep networks, where small changes in the first layers are amplified through the network. Normalizing the layer's output helps in bounding these shifts, speeding up training and generating more reliable models. </p>
			<p>In addition, using batch normalization, we can do the following:</p>
			<ul>
				<li>We can adopt a higher learning rate without the risk of incurring the problem of vanishing or exploding gradients. </li>
				<li>We can favor network regularization by making its generalization better and mitigating overfitting.</li>
				<li>We can make the model become more robust to different initialization schemes and learning rates.</li>
			</ul>
			<h3 id="_idParaDest-115"><a id="_idTextAnchor153"/>Model Testing and Inference</h3>
			<p>Once the model has been trained and its validation performances are satisfactory, we can move on to the final stage. As already stated, a final, accurate, model performance estimation requires that we test the model on a set of instances it has never seen before: the test set. After performance has been confirmed, the model can be moved to production for online inference, where it will serve as designed: new instances will be provided to the model and it will output predictions, leveraging the knowledge it has been designed and trained to have.</p>
			<p>In the following subsections, three types of neural networks with specific elements/layers will be described. They will provide straightforward examples of different technologies that are widely encountered in the field. </p>
			<h2 id="_idParaDest-116">Standa<a id="_idTextAnchor154"/>rd Fully Connected Neural Networks</h2>
			<p>The term <em class="italic">fully connected neural network</em> is commonly used to indicate deep neural networks that are only composed of fully connected layers. Fully connected layers are the layers whose neurons are connected to all the neurons of the previous layer, as well as all the neurons of the next one, as shown in the following diagram:</p>
			<div>
				<div id="_idContainer362" class="IMG---Figure">
					<img src="image/B16182_03_07.jpg" alt="Figure 3.7: A fully connected neural network&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7: A fully connected neural network</p>
			<p>This chapter will mainly deal with fully connected networks. They map inputs to outputs through a series of intermediate hidden layers. These architectures are capable of handling a wide variety of problems, but they are limited in terms of the input dimensions they can handle, as well as the number of layers and number of neurons, due to the rapid growth of the number of parameters, which is strictly dependent on these variables.</p>
			<p>An example of a fully connected neural network that will be encountered later on is the one presented as follows, built with the Keras API. It connects an input layer who dimension is equal to <strong class="source-inline">len(train_dataset.keys())</strong> to an output layer of dimension <strong class="source-inline">1</strong>, by means of two hidden layers with <strong class="source-inline">64</strong> neurons each:</p>
			<p class="source-code">    model = tf.keras.Sequential([tf.keras.layers.Dense\</p>
			<p class="source-code">            (64, activation='relu',\</p>
			<p class="source-code">             input_shape=[len(train_dataset.keys())]),\</p>
			<p class="source-code">             tf.keras.layers.Dense(64, activation='relu'),\</p>
			<p class="source-code">             tf.keras.layers.Dense(1)])</p>
			<p>Now, let's quickly solve an exercise in order to aid our understanding of fully connected neural networks.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor155"/>Exercise 3.02: Building a Fully Connected Neural Network Model with the Keras High-Level API</h2>
			<p>In this exercise, we will build a fully connected neural network with an input dimension of <strong class="source-inline">100</strong>, 2 hidden layers, and an output layer of <strong class="source-inline">10</strong> neurons. The following are the steps to complete this exercise:</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">TensorFlow</strong> module and print its version:<p class="source-code">from __future__ import absolute_import, division, \</p><p class="source-code">print_function, unicode_literals</p><p class="source-code">import tensorflow as tf</p><p class="source-code">print("TensorFlow version: {}".format(tf.__version__))</p><p>This prints out the following line:</p><p class="source-code">TensorFlow version: 2.1.0</p></li>
				<li>Create the network using the Keras <strong class="source-inline">sequential</strong> module. This allows us to build a model by stacking a series of layers, one after the other. In this specific case, we're using two hidden layers and an output layer:<p class="source-code">INPUT_DIM = 100</p><p class="source-code">OUTPUT_DIM = 10</p><p class="source-code"> </p><p class="source-code">model = tf.keras.Sequential([tf.keras.layers.Dense\</p><p class="source-code">        (128, activation='relu', \</p><p class="source-code">        input_shape=[INPUT_DIM]), \</p><p class="source-code">        tf.keras.layers.Dense(256, activation='relu'), \</p><p class="source-code">        tf.keras.layers.Dense(OUTPUT_DIM, activation='softmax')])</p></li>
				<li>Print the summary to look at the model description:<p class="source-code">model.summary()</p><p>The output will be as follows:</p><p class="source-code">Model: "sequential"</p><p class="source-code">_________________________________________________________________</p><p class="source-code">Layer (type)                 Output Shape              Param #   </p><p class="source-code">=================================================================</p><p class="source-code">dense (Dense)                (None, 128)               12928     </p><p class="source-code">_________________________________________________________________</p><p class="source-code">dense_1 (Dense)              (None, 256)               33024     </p><p class="source-code">_________________________________________________________________</p><p class="source-code">dense_2 (Dense)              (None, 10)                2570      </p><p class="source-code">=================================================================</p><p class="source-code">Total params: 48,522</p><p class="source-code">Trainable params: 48,522</p><p class="source-code">Non-trainable params: 0</p><p class="source-code">_________________________________________________________________</p></li>
			</ol>
			<p>As you can see, the model has been created and the summary provides us with a clear understanding of the layers, their types and shapes, and the number of parameters of the network, which is very useful when building neural networks in real life.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/37s1M5w">https://packt.live/37s1M5w</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3f9WzSq">https://packt.live/3f9WzSq</a>.</p>
			<p>Now, let's move on and understand convolutional neural networks.</p>
			<h2 id="_idParaDest-118">Convolu<a id="_idTextAnchor156"/>tional Neural Networks</h2>
			<p>The term <strong class="bold">Convolutional Neural Network</strong> (<strong class="bold">CNN</strong>) usually identifies a deep neural network composed of a combination of the following:</p>
			<ul>
				<li>Convolutional layers</li>
				<li>Pooling layers</li>
				<li>Fully connected layers</li>
			</ul>
			<p>One of the most successful applications of CNNs is in image and video processing tasks. In fact, they are way more capable, with respect to fully connected ones, of handling high-dimensional inputs such as images. They are also widely used for anomaly detection tasks, being used in autoencoders, as well as encoders for reinforcement learning algorithms, specifically for policy and value networks.</p>
			<p>Convolutional layers can be thought of as a series of filters applied (convolved) to layer inputs to generate layer outputs. The main parameters of these layers are the number of filters they have and the dimension of the convolution kernel. </p>
			<p>Pooling layers reduce the dimensions of the data; they combine the outputs of neuron clusters at one layer into a single neuron in the next layer. Pooling layers may compute a max (<strong class="bold">MaxPooling</strong>), which uses the maximum value from each cluster of neurons at the prior layer, or an average (<strong class="bold">AveragePooling</strong>), which uses the average value from each cluster of neurons at the prior layer.</p>
			<p>These convolution/pooling operations encode input information in a compressed representation, up to a point where these new deep features, also called embeddings, are typically provided as inputs to standard fully connected layers at the very end of the network. A classic convolutional neural network schematization is represented in the following figure:</p>
			<div>
				<div id="_idContainer363" class="IMG---Figure">
					<img src="image/B16182_03_08.jpg" alt="Figure 3.8: Convolutional neural network scheme&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8: Convolutional neural network scheme</p>
			<p>The following exercise shows how to create a convolutional neural network using the Keras high-level API.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor157"/>Exercise 3.03: Building a Convolutional Neural Network Model with the Keras High-Level API</h2>
			<p>This exercise will show you how to build a convolutional neural network with three convolutional layers (number of filters equal to <strong class="source-inline">16</strong>, <strong class="source-inline">32</strong>, and <strong class="source-inline">64</strong>, respectively, and a kernel size of <strong class="source-inline">3</strong>), alternated with three <strong class="source-inline">MaxPooling</strong> layers, and, at the end, two fully connected layers with <strong class="source-inline">512</strong> and <strong class="source-inline">1</strong> neurons, respectively. Here is the step-by-step procedure:</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">TensorFlow</strong> module and print its version:<p class="source-code">from __future__ import absolute_import, division, \</p><p class="source-code">print_function, unicode_literals</p><p class="source-code">import tensorflow as tf</p><p class="source-code">print("TensorFlow version: {}".format(tf.__version__))</p><p>This prints out the following line:</p><p class="source-code">TensorFlow version: 2.1.0</p></li>
				<li>Create the network using the Keras sequential module:<p class="source-code">IMG_HEIGHT = 480</p><p class="source-code">IMG_WIDTH = 680</p><p class="source-code">model = tf.keras.Sequential([tf.keras.layers.Conv2D\</p><p class="source-code">        (16, 3, padding='same',\</p><p class="source-code">         activation='relu',\</p><p class="source-code">         input_shape=(IMG_HEIGHT, IMG_WIDTH, 3)),\</p><p class="source-code">         tf.keras.layers.MaxPooling2D(),\</p><p class="source-code">         tf.keras.layers.Conv2D(32, 3, padding='same',\</p><p class="source-code">         activation='relu'),\</p><p class="source-code">         tf.keras.layers.MaxPooling2D(),\</p><p class="source-code">         tf.keras.layers.Conv2D(64, 3, padding='same',\</p><p class="source-code">         activation='relu'),\</p><p class="source-code">         tf.keras.layers.MaxPooling2D(),\</p><p class="source-code">         tf.keras.layers.Flatten(),\</p><p class="source-code">         tf.keras.layers.Dense(512, activation='relu'),\</p><p class="source-code">         tf.keras.layers.Dense(1)])</p><p class="source-code">model.summary()</p><p>The preceding code allows us to build a model by stacking a series of layers, one after the other. In this specific case, three series of convolutional layers and max pooling layers are followed by a flattening layer and two dense layers.</p><p>This outputs the following model description:</p><p class="source-code">Model: "sequential"</p><p class="source-code">_________________________________________________________________</p><p class="source-code">Layer (type)                 Output Shape              Param #   </p><p class="source-code">=================================================================</p><p class="source-code">conv2d (Conv2D)              (None, 480, 680, 16)      448       </p><p class="source-code">_________________________________________________________________</p><p class="source-code">max_pooling2d (MaxPooling2D) (None, 240, 340, 16)      0         </p><p class="source-code">_________________________________________________________________</p><p class="source-code">conv2d_1 (Conv2D)            (None, 240, 340, 32)      4640      </p><p class="source-code">_________________________________________________________________</p><p class="source-code">max_pooling2d_1 (MaxPooling2 (None, 120, 170, 32)      0         </p><p class="source-code">_________________________________________________________________</p><p class="source-code">conv2d_2 (Conv2D)            (None, 120, 170, 64)      18496     </p><p class="source-code">_________________________________________________________________</p><p class="source-code">max_pooling2d_2 (MaxPooling2 (None, 60, 85, 64)        0         </p><p class="source-code">_________________________________________________________________</p><p class="source-code">flatten (Flatten)            (None, 326400)            0         </p><p class="source-code">_________________________________________________________________</p><p class="source-code">dense (Dense)                (None, 512)               167117312 </p><p class="source-code">_________________________________________________________________</p><p class="source-code">dense_1 (Dense)              (None, 1)                 513       </p><p class="source-code">=================================================================</p><p class="source-code">Total params: 167,141,409</p><p class="source-code">Trainable params: 167,141,409</p><p class="source-code">Non-trainable params: 0</p></li>
			</ol>
			<p>Thus, we have successfully created a CNN using Keras. The preceding summary gives us significant information about the layers and the different parameters of the network.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2AZJqwn">https://packt.live/2AZJqwn</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/37p1OuX">https://packt.live/37p1OuX</a>.</p>
			<p>Now that we've dealt with convolutional neural networks, let's focus on another important architecture family: recurrent neural networks.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor158"/>Recurrent Neural Networks</h2>
			<p>Recurrent neural networks are models composed of particular units that, in the same way as feedforward networks, are able to process data from input to output, but, unlike them, are also able to process data in the opposite direction using feedback loops. They are basically designed so that the output of a layer is redirected and becomes the input of the same layer using specific internal states capable of "remembering" previous states. </p>
			<p>This specific feature makes them particularly suited for solving tasks characterized by temporal/sequential development. It can be useful to compare CNNs and RNNs to understand which problems one is more suited to than the other. CNNs are the best fit for problems where local coherence is strongly enhanced and is particularly the case for images/video. Local coherence is exploited to drastically reduce the number of weights needed to process high-dimensional inputs. RNNs, on the other hand, perform best on problems characterized by temporal development, which means tasks where data can be represented by time series. This is the case for natural language processing or speech recognition, where words and sounds are meaningful if they're considered in a specific sequence.</p>
			<p>Recurrent architectures can be thought of as sequences of operations, and they are perfectly designed to keep track of historical data:</p>
			<div>
				<div id="_idContainer364" class="IMG---Figure">
					<img src="image/B16182_03_09.jpg" alt="Figure 3.9: Recurrent neural network block diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9: Recurrent neural network block diagram</p>
			<p>The most important components they are based on are GRUs and LSTMs. These blocks have internal elements and states explicitly dedicated to keeping track of important information for the task they aim to solve. They both address the issue of learning long-term dependencies successfully when training machine learning algorithms on temporal data. They tackle this problem by storing "memory" from data seen in the past in order to help the network make predictions in the future.</p>
			<p>The main differences between GRUs and LSTMs are the number of gates, the inputs the unit has, and the cell states, which are the internal elements the make up the unit's memory. GRUs have one gate, while LSTMs have three gates, called the input, forget, and output gates. LSTMs are more flexible than GRUs since they have more parameters, which, on the other hand, makes them less efficient in terms of both memory and time.</p>
			<p>These networks have been responsible for the great advancements in fields such as speech recognition, natural language processing, text-to-speech, machine translation, language modeling, and many other similar tasks.</p>
			<p>The following is a block diagram of a typical GRU:</p>
			<div>
				<div id="_idContainer365" class="IMG---Figure">
					<img src="image/B16182_03_10.jpg" alt="Figure 3.10: Block diagram of a GRU&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10: Block diagram of a GRU</p>
			<p>The following is a block diagram of a typical LSTM:</p>
			<div>
				<div id="_idContainer366" class="IMG---Figure">
					<img src="image/B16182_03_11.jpg" alt="Figure 3.11: Block diagram of an LSTM&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11: Block diagram of an LSTM</p>
			<p>The following exercise shows how a recurrent network with LSTM units can be created using the Keras API. </p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor159"/>Exercise 3.04: Building a Recurrent Neural Network Model with the Keras High-Level API</h2>
			<p>In this exercise, we will create a recurrent neural network using the Keras high-level API. It will have the following architecture: the very first layer is simply a layer that encodes, using certain rules, the input features, thereby producing a given set of embeddings. The second layer is a layer where <strong class="source-inline">64</strong> LSTM units are added to it. They are added inside a bidirectional wrapper, which is a specific layer that's used to improve and speed up learning by doubling the units it acts on and training the first ones with the input as-is, and the second ones with the input reversed (for example, words in a sentence read from right to left). Then, the outputs are concatenated. This technique has been proven to generate faster and better learning. Finally, two dense layers are added that have <strong class="source-inline">64</strong> and <strong class="source-inline">1</strong> neurons, respectively. Perform the following steps to complete this exercise:</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">TensorFlow</strong> module and print its version:<p class="source-code">from __future__ import absolute_import, division, \</p><p class="source-code">print_function, unicode_literals</p><p class="source-code">import tensorflow as tf</p><p class="source-code">print("TensorFlow version: {}".format(tf.__version__))</p><p>This outputs the following line:</p><p class="source-code">TensorFlow version: 2.1.0</p></li>
				<li>Build the model using the Keras <strong class="source-inline">sequential</strong> method and print the network summary:<p class="source-code">EMBEDDING_SIZE = 8000</p><p class="source-code">model = tf.keras.Sequential([\</p><p class="source-code">        tf.keras.layers.Embedding(EMBEDDING_SIZE, 64),\</p><p class="source-code">        tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(64)),\</p><p class="source-code">        tf.keras.layers.Dense(64, activation='relu'),\</p><p class="source-code">        tf.keras.layers.Dense(1)])</p><p class="source-code">model.summary()</p><p>In the preceding code, the model is simply built by stacking up consecutive layers. First, there is the embedding layer, then the bidirectional one, which operates on the LSTM layer, and finally two dense layers at the end of the model.</p><p>The model summary will be as follows:</p><p class="source-code">Model: "sequential"</p><p class="source-code">_________________________________________________________________</p><p class="source-code">Layer (type)                 Output Shape              Param #   </p><p class="source-code">=================================================================</p><p class="source-code">embedding (Embedding)        (None, None, 64)          512000    </p><p class="source-code">_________________________________________________________________</p><p class="source-code">bidirectional (Bidirectional (None, 128)               66048     </p><p class="source-code">_________________________________________________________________</p><p class="source-code">dense (Dense)                (None, 64)                8256      </p><p class="source-code">_________________________________________________________________</p><p class="source-code">dense_1 (Dense)              (None, 1)                 65        </p><p class="source-code">=================================================================</p><p class="source-code">Total params: 586,369</p><p class="source-code">Trainable params: 586,369</p><p class="source-code">Non-trainable params: 0</p><p class="source-code">_________________________________________________________________</p><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3cX01OO">https://packt.live/3cX01OO</a>.</p><p class="callout">You can also run this example online at <a href="https://packt.live/37nw1ud">https://packt.live/37nw1ud</a>.</p></li>
			</ol>
			<p>With this overview of how to implement a neural network using TensorFlow, the following sections will show you how to combine all these notions to tackle typical machine learning problems, including regression and classification problems.</p>
			<h1 id="_idParaDest-122">Simple Regr<a id="_idTextAnchor160"/>ession Using TensorFlow</h1>
			<p>This section will explain, step by step, how to successfully tackle a regression problem. You will learn how to take a preliminary look at the dataset to understand its most important properties, as well as how to prepare it to be used during training, validation, and inference. Then, a deep neural network will be built from a clean sheet using TensorFlow via the Keras API. This model will then be trained and its performance will be evaluated. </p>
			<p>In a regression problem, the aim is to predict the output of a continuous value, such as a price or a probability. In this exercise, the classic Auto MPG dataset will be used and a deep neural network will be trained on it to accurately predict car fuel efficiency, using no more than the following seven features: Cylinders, Displacement, Horsepower, Weight, Acceleration, Model Year, and Origin. </p>
			<p>The dataset can be thought of as a table with eight columns (seven features, plus one target value) and as many rows as instances the dataset has. As per the best practices we looked at in the previous sections, it will be divided as follows: 20% of the total number of instances will create the test set, while the remaining ones will be split again into training and validation sets with an 80:20 ratio.</p>
			<p>As a first step, the training set will be inspected for missing values, and cleaned if needed. Then, a chart showing variable correlation will be plotted. The only categorical variable present will be converted into numerical form via one-hot encoding. Finally, all the features will be normalized.</p>
			<p>The deep learning model will then be created. A three-layered fully connected architecture will be used: the first and the second layer will have 64 nodes, while the last one, being the output layer of a regression problem, will have only one node.</p>
			<p>Standard choices for the loss function (mean squared error) and optimizer (RMSprop) will be applied. Training will then be performed with and without early stopping to highlight the different effects they have on training and validation loss.</p>
			<p>Finally, the model will be applied to the test set to evaluate performances and make predictions. </p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor161"/>Exercise 3.05: Creating a Deep Neural Network to Predict the Fuel Efficiency of Cars</h2>
			<p>In this exercise, we will build, train, and measure performances of a deep neural network model that predicts car fuel efficiency using only seven car features: <strong class="source-inline">Cylinders</strong>, <strong class="source-inline">Displacement</strong>, <strong class="source-inline">Horsepower</strong>, <strong class="source-inline">Weight</strong>, <strong class="source-inline">Acceleration</strong>, <strong class="source-inline">Model Year</strong>, and <strong class="source-inline">Origin</strong>.</p>
			<p>The step-by-step procedure for this is as follows:</p>
			<ol>
				<li value="1">Import all the required modules and print the versions of the most important ones:<p class="source-code">from __future__ import absolute_import, division, \</p><p class="source-code">print_function, unicode_literals</p><p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">import numpy as np</p><p class="source-code">import pandas as pd</p><p class="source-code">import seaborn as sns</p><p class="source-code">import tensorflow as tf</p><p class="source-code">print("TensorFlow version: {}".format(tf.__version__))</p><p>The output will be as follows:</p><p class="source-code">TensorFlow version: 2.1.0</p></li>
				<li>Import the Auto MPG dataset, read it with pandas, and show the last five rows:<p class="source-code">dataset_path = tf.keras.utils.get_file("auto-mpg.data", \</p><p class="source-code">               "https://raw.githubusercontent.com/"\</p><p class="source-code">               "PacktWorkshops/"\</p><p class="source-code">               "The-Reinforcement-Learning-Workshop/master/"\</p><p class="source-code">               "Chapter03/Dataset/auto-mpg.data")</p><p class="source-code">column_names = ['MPG','Cylinders','Displacement','Horsepower',\</p><p class="source-code">                'Weight', 'Acceleration', 'Model Year', 'Origin']</p><p class="source-code">raw_dataset = pd.read_csv(dataset_path, names=column_names,\</p><p class="source-code">                          na_values = "?", comment='\t',\</p><p class="source-code">                          sep=" ", skipinitialspace=True)</p><p class="source-code">dataset = raw_dataset.copy()</p><p class="source-code">dataset.tail()</p><p class="callout-heading">Note</p><p class="callout">Watch out for the slashes in the string below. Remember that the backslashes ( <strong class="source-inline">\</strong> ) are used to split the code across multiple lines, while the forward slashes ( <strong class="source-inline">/</strong> ) are part of the URL.</p><p>The output will be as follows:</p><div id="_idContainer367" class="IMG---Figure"><img src="image/B16182_03_12.jpg" alt="Figure 3.12: Last five rows of the dataset imported in pandas&#13;&#10;"/></div><p class="figure-caption">Figure 3.12: Last five rows of the dataset imported in pandas</p></li>
				<li>Let's clean the data from unknown values. Check how much <strong class="source-inline">Not available</strong> data is present and where:<p class="source-code">dataset.isna().sum()</p><p>This produces the following output:</p><p class="source-code">MPG             0</p><p class="source-code">Cylinders       0</p><p class="source-code">Displacement    0</p><p class="source-code">Horsepower      6</p><p class="source-code">Weight          0</p><p class="source-code">Acceleration    0</p><p class="source-code">Model Year      0</p><p class="source-code">Origin          0</p><p class="source-code">dtype: int64</p></li>
				<li>Given the small number of rows with unknown values, simply drop them:<p class="source-code">dataset = dataset.dropna()</p></li>
				<li>Use one-hot encoding for the <strong class="source-inline">Origin</strong> variable, which is categorical:<p class="source-code">dataset['Origin'] = dataset['Origin']\</p><p class="source-code">                    .map({1: 'USA', 2: 'Europe', 3: 'Japan'})</p><p class="source-code">dataset = pd.get_dummies(dataset, prefix='', prefix_sep='')</p><p class="source-code">dataset.tail()</p><p>The output will be as follows:</p><div id="_idContainer368" class="IMG---Figure"><img src="image/B16182_03_13.jpg" alt="Figure 3.13: Last five rows of the dataset imported into pandas using one-hot encoding&#13;&#10;"/></div><p class="figure-caption">Figure 3.13: Last five rows of the dataset imported into pandas using one-hot encoding</p></li>
				<li>Split the data into training and test sets with an 80:20 ratio:<p class="source-code">train_dataset = dataset.sample(frac=0.8,random_state=0)</p><p class="source-code">test_dataset = dataset.drop(train_dataset.index)</p></li>
				<li>Now, let's take a look at some training data statistics, that is, the joint distributions of some pairs of features from the training set, using the <strong class="source-inline">seaborn</strong> module. The <strong class="source-inline">pairplot</strong> command takes in the features of the dataset as input to evaluate them, couple by couple. Along the diagonal (where the couple is composed of two instances of the same feature), it shows the distribution of the variable, while in the off-diagonal terms, it shows the scatterplot of the two features. This is useful if we wish to highlight correlations:<p class="source-code">sns.pairplot(train_dataset[["MPG", "Cylinders", "Displacement", \</p><p class="source-code">                            "Weight"]], diag_kind="kde")</p><p>This generates the following image:</p><div id="_idContainer369" class="IMG---Figure"><img src="image/B16182_03_14.jpg" alt="Figure 3.14: Joint distributions of some pairs of features from the training set&#13;&#10;"/></div><p class="figure-caption">Figure 3.14: Joint distributions of some pairs of features from the training set</p></li>
				<li>Let's now take a look at the overall statistics:<p class="source-code">train_stats = train_dataset.describe()</p><p class="source-code">train_stats.pop("MPG")</p><p class="source-code">train_stats = train_stats.transpose()</p><p class="source-code">train_stats</p><p>The output will be as follows:</p><div id="_idContainer370" class="IMG---Figure"><img src="image/B16182_03_15.jpg" alt="Figure 3.15: Overall training set statistics&#13;&#10;"/></div><p class="figure-caption">Figure 3.15: Overall training set statistics</p></li>
				<li>Split the features from the labels and normalize the data:<p class="source-code">train_labels = train_dataset.pop('MPG')</p><p class="source-code">test_labels = test_dataset.pop('MPG')</p><p class="source-code">def norm(x):</p><p class="source-code">    return (x - train_stats['mean']) / train_stats['std']</p><p class="source-code">normed_train_data = norm(train_dataset)</p><p class="source-code">normed_test_data = norm(test_dataset)</p></li>
				<li>Now, let's look at the model's creation and a summary of the same:<p class="source-code">def build_model():</p><p class="source-code">    model = tf.keras.Sequential([</p><p class="source-code">            tf.keras.layers.Dense(64, activation='relu',\</p><p class="source-code">                                  input_shape=[len\</p><p class="source-code">                                  (train_dataset.keys())]),\</p><p class="source-code">            tf.keras.layers.Dense(64, activation='relu'),\</p><p class="source-code">            tf.keras.layers.Dense(1)])</p><p class="source-code">    optimizer = tf.keras.optimizers.RMSprop(0.001)</p><p class="source-code">    model.compile(loss='mse', optimizer=optimizer,\</p><p class="source-code">                  metrics=['mae', 'mse'])</p><p class="source-code">    return model</p><p class="source-code">model = build_model()</p><p class="source-code">model.summary()</p><p>This generates the following output:</p><div id="_idContainer371" class="IMG---Figure"><img src="image/B16182_03_16.jpg" alt="Figure 3.16: Model summary&#13;&#10;"/></div><p class="figure-caption">Figure 3.16: Model summary</p></li>
				<li>Use the <strong class="source-inline">fit</strong> model function to train the network for 1,000 epochs by using a validation set of 20%:<p class="source-code">epochs = 1000</p><p class="source-code">history = model.fit(normed_train_data, train_labels,\</p><p class="source-code">                    epochs=epochs, validation_split = 0.2, \</p><p class="source-code">                    verbose=2)</p><p>This will produce a very long output. We will only report the last few lines here:</p><p class="source-code">Epoch 999/1000251/251 - 0s - loss: 2.8630 - mae: 1.0763 </p><p class="source-code">- mse: 2.8630 - val_loss: 10.2443 - val_mae: 2.3926 </p><p class="source-code">- val_mse: 10.2443</p><p class="source-code">Epoch 1000/1000251/251 - 0s - loss: 2.7697 - mae: 0.9985 </p><p class="source-code">- mse: 2.7697 - val_loss: 9.9689 - val_mae: 2.3709 - val_mse: 9.9689</p></li>
				<li>Visualize the training and validation metrics by plotting the MAE and MSE.<p>The following snippet plots the MAE:</p><p class="source-code">hist = pd.DataFrame(history.history)</p><p class="source-code">hist['epoch'] = history.epoch</p><p class="source-code">plt.plot(hist['epoch'],hist['mae'])</p><p class="source-code">plt.plot(hist['epoch'],hist['val_mae'])</p><p class="source-code">plt.ylim([0, 10])</p><p class="source-code">plt.ylabel('MAE [MPG]')</p><p class="source-code">plt.legend(["Training", "Validation"])</p><p>The output will be as follows:</p><div id="_idContainer372" class="IMG---Figure"><img src="image/B16182_03_17.jpg" alt="Figure 3.17: Mean absolute error over the plot of epochs &#13;&#10;"/></div><p class="figure-caption">Figure 3.17: Mean absolute error over the plot of epochs </p><p>The preceding figure shows how increasing the training epochs causes the validation error to grow, meaning the system is experiencing an overfitting problem.</p></li>
				<li>Now, let's visualize the MSE using a plot:<p class="source-code">plt.plot(hist['epoch'],hist['mse'])</p><p class="source-code">plt.plot(hist['epoch'],hist['val_mse'])</p><p class="source-code">plt.ylim([0, 20])</p><p class="source-code">plt.ylabel('MSE [MPG^2]')</p><p class="source-code">plt.legend(["Training", "Validation"])</p><p>The output will be as follows:</p><div id="_idContainer373" class="IMG---Figure"><img src="image/B16182_03_18.jpg" alt="Figure 3.18: Mean squared error over the plot of epochs &#13;&#10;"/></div><p class="figure-caption">Figure 3.18: Mean squared error over the plot of epochs </p><p>Also, in this case, the figure shows how increasing the training epochs causes the validation error to grow, meaning the system is experiencing an overfitting problem.</p></li>
				<li>Use Keras callbacks to add early stopping (with the patience parameter equal to 10 epochs) to avoid overfitting. First of all, build the model:<p class="source-code">model = build_model()</p></li>
				<li>Then, define an early stopping callback. This entity will be passed to the <strong class="source-inline">model.fit</strong> function and will be called every fit step to check whether the validation error stops decreasing for more than <strong class="source-inline">10</strong> consecutive epochs:<p class="source-code">early_stop = tf.keras.callbacks\</p><p class="source-code">             .EarlyStopping(monitor='val_loss', patience=10)</p></li>
				<li>Finally, call the <strong class="source-inline">fit</strong> method with the early stop callback:<p class="source-code">early_history = model.fit(normed_train_data, train_labels,\</p><p class="source-code">                          epochs=epochs, validation_split=0.2,\</p><p class="source-code">                          verbose=2, callbacks=[early_stop])</p><p>The last few lines of the output are as follows:</p><p class="source-code">Epoch 42/1000251/251 - 0s - loss: 7.1298 - mae: 1.9014 </p><p class="source-code">- mse: 7.1298 - val_loss: 8.1151 - val_mae: 2.1885 </p><p class="source-code">- val_mse: 8.1151</p><p class="source-code">Epoch 43/1000251/251 - 0s - loss: 7.0575 - mae: 1.8513 </p><p class="source-code">- mse: 7.0575 - val_loss: 8.4124 - val_mae: 2.2669 </p><p class="source-code">- val_mse: 8.4124</p></li>
				<li>Visualize the train and validation metrics for early stopping. Firstly, collect all the training history data and put it into a pandas DataFrame, for both the metric and epoch values:<p class="source-code">early_hist = pd.DataFrame(early_history.history)</p><p class="source-code">early_hist['epoch'] = early_history.epoch</p></li>
				<li>Then, plot the training and validation MAE against the epochs, limiting the max <strong class="source-inline">y</strong> values to <strong class="source-inline">10</strong>:<p class="source-code">plt.plot(early_hist['epoch'],early_hist['mae'])</p><p class="source-code">plt.plot(early_hist['epoch'],early_hist['val_mae'])</p><p class="source-code">plt.ylim([0, 10])</p><p class="source-code">plt.ylabel('MAE [MPG]')</p><p class="source-code">plt.legend(["Training", "Validation"])</p><p>The preceding code will produce the following output:</p><div id="_idContainer374" class="IMG---Figure"><img src="image/B16182_03_19.jpg" alt="Figure 3.19: Mean absolute error over the plot of epochs (early stopping)&#13;&#10;"/></div><p class="figure-caption">Figure 3.19: Mean absolute error over the plot of epochs (early stopping)</p><p>As demonstrated by the preceding figure, training is stopped as soon as the validation error stops decreasing, thereby avoiding overfitting.</p></li>
				<li>Evaluate the model accuracy on the test set:<p class="source-code">loss, mae, mse = model.evaluate(normed_test_data, \</p><p class="source-code">                                test_labels, verbose=2)</p><p class="source-code">print("Testing set Mean Abs Error: {:5.2f} MPG".format(mae))</p><p>The output will be as follows:</p><p class="source-code">78/78 - 0s - loss: 6.3067 - mae: 1.8750 - mse: 6.3067 </p><p class="source-code">Testing set Mean Abs Error:  1.87 MPG</p><p class="callout-heading">Note </p><p class="callout">The accuracy may show slightly different values due to random sampling with a variable random seed.</p></li>
				<li>Finally, perform model inference by predicting all the MPG values for all test instances. Then, plot these values with respect to their true values so that you have a visual estimation of the model error:<p class="source-code">test_predictions = model.predict(normed_test_data).flatten()</p><p class="source-code">a = plt.axes(aspect='equal')</p><p class="source-code">plt.scatter(test_labels, test_predictions)</p><p class="source-code">plt.xlabel('True Values [MPG]')</p><p class="source-code">plt.ylabel('Predictions [MPG]')</p><p class="source-code">lims = [0, 50]</p><p class="source-code">plt.xlim(lims)</p><p class="source-code">plt.ylim(lims)</p><p class="source-code">_ = plt.plot(lims, lims)</p><p>The output will be as follows:</p><div id="_idContainer375" class="IMG---Figure"><img src="image/B16182_03_20.jpg" alt="Figure 3.20: Predictions versus ground truth scatterplot&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 3.20: Predictions versus ground truth scatterplot</p>
			<p>The scatterplot puts predicted values versus true values in correspondence with one another, which means that the closer the points are to the diagonal line, the more accurate the predictions will be. It is evident how clustered the points are, meaning predictions are fairly accurate.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3feCLNN">https://packt.live/3feCLNN</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/37n5WeM">https://packt.live/37n5WeM</a>.</p>
			<p>This section has shown how to successfully tackle a regression problem. The selected dataset has been imported, cleaned, and subdivided into training, validation, and test sets. Then, a brief exploratory data analysis was carried out before a three-layered fully connected deep neural network was created. The network has been successfully trained and its performance has been evaluated on the test set.</p>
			<p>Now, let's study classification problems using TensorFlow.</p>
			<h1 id="_idParaDest-124">Simple Classificatio<a id="_idTextAnchor162"/><a id="_idTextAnchor163"/>n Using TensorFlow</h1>
			<p>This section will help you understand and solve a typical supervised learning problem that falls under the category conventionally named <strong class="bold">classification</strong>.</p>
			<p>Classification tasks, in their simplest generic form, aim to associate one category, among a predefined set, with instances. An intuitive example of a classification task that's often used for introductory courses is classifying the images of domestic pets in the correct category they belong to, such as "cat" or "dog." Classification plays a fundamental role in many everyday activities and can easily be encountered in different contexts. The previous example is a specific case of classification called <strong class="bold">image classification</strong>, and many similar applications can be found in this category. </p>
			<p>However, classification extends beyond images. The following are some examples:</p>
			<ul>
				<li>Customer classification for video recommendation systems (answering the question, "In which market segment this user falls?")</li>
				<li>Spam filters ("What are the chances this email is spam?")</li>
				<li>Malware detection ("Is this program a cyber threat?")</li>
				<li>Medical diagnosis ("Is this patient sick?")</li>
			</ul>
			<p>For image classification tasks, images are fed to the classification algorithm as inputs, and it returns the class they belong to as output. Images are three-dimensional arrays of numbers representing per-pixel brightness (height x width x number of channels, where color images have three channels – red, green, blue (RGB) – and grayscale images only have one), and these numbers are the features that the algorithm uses to determine the class images belong to. </p>
			<p>When dealing with other types of inputs, features can be different. For example, in the case of a medical diagnosis classification system, blood test parameters, age, sex, and suchlike can be features that are used by the algorithm to identify the class the instance belongs to, that is, "sick" or "not sick."</p>
			<p>In the following exercise, we will create a deep neural network by building upon what we described in the previous sections. This will be able to achieve an accuracy of around 70% when classifying signals that have been detected inside a simulated ATLAS experiment, distinguishing between background noise and Higgs Boson Tau-Tau decay using a set of 28 features: yes, machine learning applied to particle physics!</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For additional information on the dataset, visit the official website: <a href="http://archive.ics.uci.edu/ml/datasets/HIGGS">http://archive.ics.uci.edu/ml/datasets/HIGGS</a>.</p>
			<p>Given the huge size of the dataset, to keep the exercise easy to run and still meaningful, it will be subsampled: 10,000 rows will be used for training and 1,000 rows each for validation and test. Three different models will be trained: a small model that will be a reference (two layers with 16 and 1 neurons each), a large model with no overfit countermeasures (five layers; four with 512 neurons and the last one with 1 neuron) to demonstrate problems that may be encountered in this scenario, and then regularization and dropout will be added to the large model, effectively limiting overfitting and improving performance.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor164"/>Exercise 3.06: Creating a Deep Neural Network to Classify Events Generated by the ATLAS Experiment in the Quest for Higgs Boson</h2>
			<p>In this exercise, we will build, train, and measure the performance of a deep neural network in order to improve the discovery significance of the ATLAS experiment by using simulated data with features for characterizing events. The task is to classify events into two categories: "tau decay of a Higgs Boson" versus "background." </p>
			<p>This dataset can be found in the TensorFlow dataset (<a href="https://www.tensorflow.org/datasets">https://www.tensorflow.org/datasets</a>), which is a collection of ready-to-use datasets. It is available to download and interface via the processing pipeline. In our case, the original dataset is too big for our purposes, so we will postpone dataset usage until we get to this chapter's activity. For now, we will use a subgroup of the dataset that's directly available through the repository.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can find the dataset in this book's GitHub repository here: <a href="https://packt.live/3dUfYq8">https://packt.live/3dUfYq8</a>.</p>
			<p>The step-by-step procedure is described in detail as follows:</p>
			<ol>
				<li value="1">Import all the required modules and print the versions of the most important ones:<p class="source-code">from __future__ import absolute_import, division, \</p><p class="source-code">print_function, unicode_literals</p><p class="source-code">from  IPython import display</p><p class="source-code">from matplotlib import pyplot as plt</p><p class="source-code">from scipy.ndimage.filters import gaussian_filter1d</p><p class="source-code">import pandas as pd</p><p class="source-code">import numpy as np</p><p class="source-code">import tensorflow as tf</p><p class="source-code">print("TensorFlow version: {}".format(tf.__version__))</p><p>The output will be as follows:</p><p class="source-code">TensorFlow version: 2.1.0</p></li>
				<li>Import the dataset and prepare the data for preprocessing.<p>For this exercise, we will download a custom-made smaller subset that's been pulled from the original dataset:</p><p class="source-code">higgs_path = tf.keras.utils.get_file('HIGGSSmall.csv.gz', \</p><p class="source-code">             'https://github.com/PacktWorkshops/'\</p><p class="source-code">             'The-Reinforcement-Learning-Workshop/blob/'\</p><p class="source-code">             'master/Chapter03/Dataset/HIGGSSmall.csv.gz?raw=true')</p></li>
				<li>Read the CSV dataset into a TensorFlow dataset class and repack it so that it has tuples (<strong class="source-inline">features</strong>, <strong class="source-inline">labels</strong>):<p class="source-code">N_TEST = int(1e3)</p><p class="source-code">N_VALIDATION = int(1e3)</p><p class="source-code">N_TRAIN = int(1e4)</p><p class="source-code">BUFFER_SIZE = int(N_TRAIN)</p><p class="source-code">BATCH_SIZE = 500</p><p class="source-code">STEPS_PER_EPOCH = N_TRAIN//BATCH_SIZE</p><p class="source-code">N_FEATURES = 28</p><p class="source-code">ds = tf.data.experimental\</p><p class="source-code">     .CsvDataset(higgs_path,[float(),]*(N_FEATURES+1), \</p><p class="source-code">                 compression_type="GZIP")</p><p class="source-code">def pack_row(*row):</p><p class="source-code">    label = row[0]</p><p class="source-code">    features = tf.stack(row[1:],1)</p><p class="source-code">    return features, label</p><p class="source-code">packed_ds = ds.batch(N_TRAIN).map(pack_row).unbatch()</p><p>Take a look at the value distribution of the features:</p><p class="source-code">for features,label in packed_ds.batch(1000).take(1):</p><p class="source-code">    print(features[0])</p><p class="source-code">    plt.hist(features.numpy().flatten(), bins = 101)</p><p>The output will be as follows:</p><p class="source-code">tf.Tensor(</p><p class="source-code">[ 0.8692932 -0.6350818  0.22569026  0.32747006 -0.6899932</p><p class="source-code">  0.7542022 -0.2485731 -1.0920639   0.          1.3749921</p><p class="source-code"> -0.6536742  0.9303491  1.1074361   1.1389043  -1.5781983</p><p class="source-code"> -1.0469854  0.         0.65792954 -0.01045457 -0.04576717</p><p class="source-code">  3.1019614  1.35376    0.9795631   0.97807616  0.92000484</p><p class="source-code">  0.72165745 0.98875093 0.87667835], shape=(28,), dtype=float32)</p><p>The plot will be as follows: </p><div id="_idContainer376" class="IMG---Figure"><img src="image/B16182_03_21.jpg" alt="Figure 3.21: First feature value distribution&#13;&#10;"/></div><p class="figure-caption">Figure 3.21: First feature value distribution</p><p>In the preceding graph, the <em class="italic">x</em> axis represents the number of training samples for a given value, while the <em class="italic">y</em> axis denotes the first feature's numerical value.</p></li>
				<li>Create training, validation, and test sets:<p class="source-code">validate_ds = packed_ds.take(N_VALIDATION).cache()</p><p class="source-code">test_ds = packed_ds.skip(N_VALIDATION).take(N_TEST).cache()</p><p class="source-code">train_ds = packed_ds.skip(N_VALIDATION+N_TEST)\</p><p class="source-code">           .take(N_TRAIN).cache()</p></li>
				<li>Define feature, label, and class names:<p class="source-code">feature_names = ["lepton pT", "lepton eta", "lepton phi",\</p><p class="source-code">                 "missing energy magnitude", \</p><p class="source-code">                 "missing energy phi",\</p><p class="source-code">                 "jet 1 pt", "jet 1 eta", "jet 1 phi",\</p><p class="source-code">                 "jet 1 b-tag",\</p><p class="source-code">                 "jet 2 pt", "jet 2 eta", "jet 2 phi",\</p><p class="source-code">                 "jet 2 b-tag",\</p><p class="source-code">                 "jet 3 pt", "jet 3 eta", "jet 3 phi",\</p><p class="source-code">                 "jet 3 b-tag",\</p><p class="source-code">                 "jet 4 pt", "jet 4 eta", "jet 4 phi",\</p><p class="source-code">                 "jet 4 b-tag",\</p><p class="source-code">                 "m_jj", "m_jjj", "m_lv", "m_jlv", "m_bb",\</p><p class="source-code">                 "m_wbb", "m_wwbb"]</p><p class="source-code">label_name = ['Measure']</p><p class="source-code">class_names = ['Signal', 'Background']</p><p class="source-code">print("Features: {}".format(feature_names))</p><p class="source-code">print("Label: {}".format(label_name))</p><p class="source-code">print("Class names: {}".format(class_names))</p><p>The output will be as follows:</p><p class="source-code">Features: ['lepton pT', 'lepton eta', 'lepton phi', </p><p class="source-code">'missing energy magnitude', 'missing energy phi', </p><p class="source-code">'jet 1 pt', 'jet 1 eta', 'jet 1 phi', 'jet 1 b-tag', </p><p class="source-code">'jet 2 pt', 'jet 2 eta', 'jet 2 phi', 'jet 2 b-tag', </p><p class="source-code">'jet 3 pt', 'jet 3 eta', 'jet 3 phi', 'jet 3 b-tag', </p><p class="source-code">'jet 4 pt', 'jet 4 eta', 'jet 4 phi', 'jet 4 b-tag', </p><p class="source-code">'m_jj', 'm_jjj', 'm_lv', 'm_jlv', 'm_bb', 'm_wbb', 'm_wwbb']</p><p class="source-code">Label: ['Measure']</p><p class="source-code">Class names: ['Signal', 'Background']</p></li>
				<li>Show a sample of a training instance for features and labels:<p class="source-code">features, labels = next(iter(train_ds))</p><p class="source-code">print("Features =")</p><p class="source-code">print(features.numpy())</p><p class="source-code">print("Labels =")</p><p class="source-code">print(labels.numpy())</p><p>The output will be as follows:</p><p class="source-code">Features =</p><p class="source-code">[ 0.3923715   1.3781117   1.5673449   0.17123567  1.6574531  </p><p class="source-code">0.86394763    0.88821083  1.4797885   2.1730762   1.2008675   </p><p class="source-code">0.9490923 -0.30092147    2.2148721   1.277294    0.4025028  </p><p class="source-code">0.50748837  0.         0.50555664</p><p class="source-code"> -0.55428815 -0.7055601   0.          0.94152564  0.9448251  </p><p class="source-code">0.9839765    0.7801499   1.4989641   0.91668195  0.8027126 ]</p><p class="source-code">Labels = 0.0</p></li>
				<li>Assign a batch size to the datasets:<p class="source-code">test_ds = test_ds.batch(BATCH_SIZE)</p><p class="source-code">validate_ds = validate_ds.batch(BATCH_SIZE)</p><p class="source-code">train_ds = train_ds.shuffle(BUFFER_SIZE).repeat()\</p><p class="source-code">           .batch(BATCH_SIZE)</p></li>
				<li>Now, let's start creating the model and training it. Create a decaying learning rate:<p class="source-code">lr_schedule = tf.keras.optimizers.schedules\</p><p class="source-code">              .InverseTimeDecay(0.001,\</p><p class="source-code">                                decay_steps=STEPS_PER_EPOCH*1000, \</p><p class="source-code">                                decay_rate=1,  staircase=False)</p></li>
				<li>Define a function that will compile a model with an <strong class="source-inline">Adam</strong> optimizer, use binary cross entropy as the <strong class="source-inline">loss</strong> function, and fit it on training data by using early stopping on the validation dataset.<p>The function takes in the model as input, chooses the <strong class="source-inline">Adam</strong> optimizer, and compiles the model with it, as well as with the binary cross entropy loss and the accuracy metrics:</p><p class="source-code">def compile_and_fit(model, name, max_epochs=3000):</p><p class="source-code">    optimizer = tf.keras.optimizers.Adam(lr_schedule)</p><p class="source-code">    model.compile(optimizer=optimizer,\</p><p class="source-code">    loss=tf.keras.losses.BinaryCrossentropy(from_logits=True),\</p><p class="source-code">    metrics=[tf.keras.losses.BinaryCrossentropy(from_logits=True,\</p><p class="source-code">             name='binary_crossentropy'),'accuracy'])</p><p>A summary of the model is then printed, as follows:</p><p class="source-code">    model.summary()</p></li>
				<li>The model is then fitted on the training dataset using a validation dataset and the early stopping callback. The training <strong class="source-inline">history</strong> is saved and returned as output:<p class="source-code">    history = model.fit(train_ds, \</p><p class="source-code">              steps_per_epoch = STEPS_PER_EPOCH,\</p><p class="source-code">              epochs=max_epochs, validation_data=validate_ds, \</p><p class="source-code">              callbacks=[tf.keras.callbacks\</p><p class="source-code">                         .EarlyStopping\</p><p class="source-code">                         (monitor='val_binary_crossentropy',\</p><p class="source-code">                         patience=200)],verbose=2)</p><p class="source-code">    return history</p></li>
				<li>Create a small model with just two layers with 16 and 1 neurons, respectively, and compile it and fit it on the dataset:<p class="source-code">small_model = tf.keras.Sequential([\</p><p class="source-code">              tf.keras.layers.Dense(16, activation='elu',\</p><p class="source-code">                                    input_shape=(N_FEATURES,)),\</p><p class="source-code">              tf.keras.layers.Dense(1)])</p><p class="source-code">size_histories = {}</p><p class="source-code">size_histories['small'] = compile_and_fit(small_model, 'sizes/small')</p><p>This will produce a long output, where the last two lines will be similar to the following:</p><p class="source-code">Epoch 1522/3000</p><p class="source-code">20/20 - 0s - loss: 0.5693 - binary_crossentropy: 0.5693 </p><p class="source-code">- accuracy: 0.6846 - val_loss: 0.5841 </p><p class="source-code">- val_binary_crossentropy: 0.5841 - val_accuracy: 0.6640</p><p class="source-code">Epoch 1523/3000</p><p class="source-code">20/20 - 0s - loss: 0.5695 - binary_crossentropy: 0.5695 </p><p class="source-code">- accuracy: 0.6822 - val_loss: 0.5845 </p><p class="source-code">- val_binary_crossentropy: 0.5845 - val_accuracy: 0.6600</p></li>
				<li>Check the model's performance on the test set:<p class="source-code">test_accuracy = tf.keras.metrics.Accuracy()</p><p class="source-code">for (features, labels) in test_ds:</p><p class="source-code">    logits = small_model(features)</p><p class="source-code">    probabilities = tf.keras.activations.sigmoid(logits)</p><p class="source-code">    predictions = 1*(probabilities.numpy() &gt; 0.5)</p><p class="source-code">    test_accuracy(predictions, labels)</p><p class="source-code">    small_model_accuracy = test_accuracy.result()</p><p class="source-code">print("Test set accuracy:{:.3%}".format(test_accuracy.result()))</p><p>The output will be as follows:</p><p class="source-code">Test set accuracy: 68.200%</p><p class="callout-heading">Note </p><p class="callout">The accuracy may show slightly different values due to random sampling with a variable random seed.</p></li>
				<li>Create a large model with five layers – four with <strong class="source-inline">512</strong> neurons and the last one with <strong class="source-inline">1</strong> neuron, respectively – and compile and fit it:<p class="source-code">large_model = tf.keras.Sequential([\</p><p class="source-code">              tf.keras.layers.Dense(512, activation='elu',\</p><p class="source-code">                                    input_shape=(N_FEATURES,)),\</p><p class="source-code">              tf.keras.layers.Dense(512, activation='elu'),\</p><p class="source-code">              tf.keras.layers.Dense(512, activation='elu'),\</p><p class="source-code">              tf.keras.layers.Dense(512, activation='elu'),\</p><p class="source-code">              tf.keras.layers.Dense(1)]) </p><p class="source-code">size_histories['large'] = compile_and_fit(large_model, "sizes/large")</p><p>This will produce a long output, where the last two lines will be similar to the following:</p><p class="source-code">Epoch 221/3000</p><p class="source-code">20/20 - 0s - loss: 1.0285e-04 - binary_crossentropy: 1.0285e-04 </p><p class="source-code">- accuracy: 1.0000 - val_loss: 2.5506 </p><p class="source-code">- val_binary_crossentropy: 2.5506 - val_accuracy: 0.6660</p><p class="source-code">Epoch 222/3000</p><p class="source-code">20/20 - 0s - loss: 1.0099e-04 - binary_crossentropy: 1.0099e-04 </p><p class="source-code">- accuracy: 1.0000 - val_loss: 2.5586 </p><p class="source-code">- val_binary_crossentropy: 2.5586 - val_accuracy: 0.6650</p></li>
				<li>Check the model's performance on the test set:<p class="source-code">test_accuracy = tf.keras.metrics.Accuracy()</p><p class="source-code">for (features, labels) in test_ds:</p><p class="source-code">    logits = large_model(features)</p><p class="source-code">    probabilities = tf.keras.activations.sigmoid(logits)</p><p class="source-code">    predictions = 1*(probabilities.numpy() &gt; 0.5)</p><p class="source-code">    test_accuracy(predictions, labels)</p><p class="source-code">    large_model_accuracy = test_accuracy.result()</p><p class="source-code">    regularization_model_accuracy = test_accuracy.result()</p><p class="source-code">print("Test set accuracy: {:.3%}"\</p><p class="source-code">      . format(regularization_model_accuracy))</p><p>The output will be as follows:</p><p class="source-code">Test set accuracy: 65.200%</p><p class="callout-heading">Note </p><p class="callout">The accuracy may show slightly different values due to random sampling with a variable random seed.</p></li>
				<li>Create the same large model as before, but add regularization items such as L2 regularization and dropout. Then, compile it and fit the model to the set:<p class="source-code">regularization_model = tf.keras.Sequential([\</p><p class="source-code">                       tf.keras.layers.Dense(512,\</p><p class="source-code">                       kernel_regularizer=tf.keras.regularizers\</p><p class="source-code">                                          .l2(0.0001),\</p><p class="source-code">                       activation='elu', \</p><p class="source-code">                       input_shape=(N_FEATURES,)),\</p><p class="source-code">                       tf.keras.layers.Dropout(0.5),\</p><p class="source-code">                       tf.keras.layers.Dense(512,\</p><p class="source-code">                       kernel_regularizer=tf.keras.regularizers\</p><p class="source-code">                                          .l2(0.0001),\</p><p class="source-code">                       activation='elu'),\</p><p class="source-code">                       tf.keras.layers.Dropout(0.5),\</p><p class="source-code">                       tf.keras.layers.Dense(512,\</p><p class="source-code">                       kernel_regularizer=tf.keras.regularizers\</p><p class="source-code">                                          .l2(0.0001),\</p><p class="source-code">                       activation='elu'),\</p><p class="source-code">                       tf.keras.layers.Dropout(0.5),\</p><p class="source-code">                       tf.keras.layers.Dense(512,\</p><p class="source-code">                       kernel_regularizer=tf.keras.regularizers\</p><p class="source-code">                                          .l2(0.0001),\</p><p class="source-code">                       activation='elu'),\</p><p class="source-code">                       tf.keras.layers.Dropout(0.5),\</p><p class="source-code">                       tf.keras.layers.Dense(1)])</p><p class="source-code">size_histories['regularization'] = compile_and_fit\</p><p class="source-code">                                   (regularization_model,\</p><p class="source-code">                                    "regularizers/regularization",\</p><p class="source-code">                                    max_epochs=9000)</p><p>This will produce a long output, where the last two lines will be similar to the following:</p><p class="source-code">Epoch 1264/9000</p><p class="source-code">20/20 - 0s - loss: 0.5873 - binary_crossentropy: 0.5469 </p><p class="source-code">- accuracy: 0.6978 - val_loss: 0.5819 </p><p class="source-code">- val_binary_crossentropy: 0.5416 - val_accuracy: 0.7030</p><p class="source-code">Epoch 1265/9000</p><p class="source-code">20/20 - 0s - loss: 0.5868 - binary_crossentropy: 0.5465 </p><p class="source-code">- accuracy: 0.7024 - val_loss: 0.5759 </p><p class="source-code">- val_binary_crossentropy: 0.5356 - val_accuracy: 0.7100</p></li>
				<li>Check the model's performance on the test set:<p class="source-code">test_accuracy = tf.keras.metrics.Accuracy()</p><p class="source-code">for (features, labels) in test_ds:</p><p class="source-code">    logits = regularization_model (features)</p><p class="source-code">    probabilities = tf.keras.activations.sigmoid(logits)</p><p class="source-code">    predictions = 1*(probabilities.numpy() &gt; 0.5)</p><p class="source-code">    test_accuracy(predictions, labels)</p><p class="source-code">print("Test set accuracy: {:.3%}".format(test_accuracy.result()))</p><p>The output will be as follows:</p><p class="source-code">Test set accuracy: 69.300%</p><p class="callout-heading">Note </p><p class="callout">The accuracy may show slightly different values due to random sampling with a variable random seed.</p></li>
				<li>Compare the binary cross entropy trend of the three models over epochs:<p class="source-code">histSmall = pd.DataFrame(size_histories["small"].history)</p><p class="source-code">histSmall['epoch'] = size_histories["small"].epoch</p><p class="source-code">histLarge = pd.DataFrame(size_histories["large"].history)</p><p class="source-code">histLarge['epoch'] = size_histories["large"].epoch</p><p class="source-code">histReg = pd.DataFrame(size_histories["regularization"].history)</p><p class="source-code">histReg['epoch'] = size_histories["regularization"].epoch</p><p class="source-code">trainSmoothSmall = gaussian_filter1d\</p><p class="source-code">                   (histSmall['binary_crossentropy'], sigma=3)</p><p class="source-code">testSmoothSmall = gaussian_filter1d\</p><p class="source-code">                  (histSmall['val_binary_crossentropy'], sigma=3)</p><p class="source-code">trainSmoothLarge = gaussian_filter1d\</p><p class="source-code">                   (histLarge['binary_crossentropy'], sigma=3)</p><p class="source-code">testSmoothLarge = gaussian_filter1d\</p><p class="source-code">                  (histLarge['val_binary_crossentropy'], sigma=3)</p><p class="source-code">trainSmoothReg = gaussian_filter1d\</p><p class="source-code">                 (histReg['binary_crossentropy'], sigma=3)</p><p class="source-code">testSmoothReg = gaussian_filter1d\</p><p class="source-code">                (histReg['val_binary_crossentropy'], sigma=3)</p><p class="source-code">plt.plot(histSmall['epoch'], trainSmoothSmall, '-', \</p><p class="source-code">         histSmall['epoch'], testSmoothSmall, '--')</p><p class="source-code">plt.plot(histLarge['epoch'], trainSmoothLarge, '-', \</p><p class="source-code">         histLarge['epoch'], testSmoothLarge, '--')</p><p class="source-code">plt.plot(histReg['epoch'], trainSmoothReg, '-', \</p><p class="source-code">         histReg['epoch'], testSmoothReg, '--',)</p><p class="source-code">plt.ylim([0.5, 0.7])</p><p class="source-code">plt.ylabel('Binary Crossentropy')</p><p class="source-code">plt.legend(["Small Training", "Small Validation", \</p><p class="source-code">            "Large Training", "Large Validation", \</p><p class="source-code">            "Regularization Training", \</p><p class="source-code">            "Regularization Validation"])</p><p>This will produce the following graph:</p><div id="_idContainer377" class="IMG---Figure"><img src="image/B16182_03_22.jpg" alt="Figure 3.22: Binary cross entropy comparison &#13;&#10;"/></div><p class="figure-caption">Figure 3.22: Binary cross entropy comparison </p><p>The preceding graph shows a comparison of the different models, in terms of both training and validation errors, to demonstrate how overfitting works. The training error goes down for each of them as the number of training epochs increases. The validation error for the large model, on the other hand, rapidly increases after a certain number of epochs. In the small model, it goes down, following the training error closely and reaching a final performance that is worse than the one obtained by the model with regularization, which avoids overfitting and has the best performance among the three.</p></li>
				<li>Compare the accuracy trend of the three models over epochs:<p class="source-code">trainSmoothSmall = gaussian_filter1d\</p><p class="source-code">                   (histSmall['accuracy'], sigma=6)</p><p class="source-code">testSmoothSmall = gaussian_filter1d\</p><p class="source-code">                  (histSmall['val_accuracy'], sigma=6)</p><p class="source-code">trainSmoothLarge = gaussian_filter1d\</p><p class="source-code">                   (histLarge['accuracy'], sigma=6)</p><p class="source-code">testSmoothLarge = gaussian_filter1d\</p><p class="source-code">                  (histLarge['val_accuracy'], sigma=6)</p><p class="source-code">trainSmoothReg = gaussian_filter1d\</p><p class="source-code">                 (histReg['accuracy'], sigma=6)</p><p class="source-code">testSmoothReg = gaussian_filter1d\</p><p class="source-code">                (histReg['val_accuracy'], sigma=6)</p><p class="source-code">plt.plot(histSmall['epoch'], trainSmoothSmall, '-', \</p><p class="source-code">         histSmall['epoch'], testSmoothSmall, '--')</p><p class="source-code">plt.plot(histLarge['epoch'], trainSmoothLarge, '-', \</p><p class="source-code">         histLarge['epoch'], testSmoothLarge, '--')</p><p class="source-code">plt.plot(histReg['epoch'], trainSmoothReg, '-', \</p><p class="source-code">         histReg['epoch'], testSmoothReg, '--',)</p><p class="source-code">plt.ylim([0.5, 0.75])</p><p class="source-code">plt.ylabel('Accuracy')</p><p class="source-code">plt.legend(["Small Training", "Small Validation", \</p><p class="source-code">            "Large Training", "Large Validation",\</p><p class="source-code">            "Regularization Training", \</p><p class="source-code">            "Regularization Validation",])</p><p>This will produce the following graph:</p><div id="_idContainer378" class="IMG---Figure"><img src="image/B16182_03_23.jpg" alt="Figure 3.23: Accuracy comparison&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 3.23: Accuracy comparison</p>
			<p>In a specular way with <a id="_idTextAnchor165"/>respect to the previous one, this graph shows, once again, a comparison of the different models, but in terms of accuracy. The training accuracy grows for each model when the number of training epochs increases. The validation accuracy for the large model, on the other hand, stops growing after a certain number of epochs. In the small model, it goes up, following the training one closely and reaching a final performance that is worse than the one obtained by the model with regularization, which avoids overfitting and attains the best performance among the three.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/37m9huu">https://packt.live/37m9huu</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3hhIDaZ">https://packt.live/3hhIDaZ</a>.</p>
			<p>In this section, we solved a fancy classification problem, resulting in the creation of a deep learning model able to achieve about 70% accuracy when classifying Higgs boson-related signals using simulated ATLAS experiment data. After a first general overview of the dataset, where we understood how it is arranged and the nature of its features and labels, a set of three deep fully connected neural networks were created using the Keras API. These models were trained and tested, and their performances in terms of loss and accuracy over epochs have been compared, thereby giving us a firm grasp of the overfitting problem and which techniques help in solving it. </p>
			<h1 id="_idParaDest-126">TensorBoard – How to Vi<a id="_idTextAnchor166"/>sualize Data Using TensorBoard</h1>
			<p>TensorBoard is a web-based tool embedded in TensorFlow. It provides a suite of methods that we can use to get insights into TensorFlow sessions and graphs, thus allowing the user to inspect, visualize, and understand them deeply. It provides access to many functionalities in a straightforward way, as follows:</p>
			<ul>
				<li>It allows us to explore the details of TensorFlow model graphs, making the user able to zoom in to specific blocks and subsections.</li>
				<li>It can generate plots of typical quantities of interest that we can take a look at during training, such as loss and accuracy.</li>
				<li>It gives us access to histogram visualizations that show tensors changing over time.</li>
				<li>It provides trends of layer weights and bias over epochs.</li>
				<li>It stores runtime metadata for a run, such as total memory usage.</li>
				<li>It visualizes embeddings.</li>
			</ul>
			<p>TensorBoard reads TensorFlow log files containing summary information about the training process at hand. These are generated with the appropriate callbacks, which are then passed to TensorFlow jobs. </p>
			<p>The following screenshot shows some typical visualizations that are provided by TensorBoard. The first one is the "Scalars" section, which shows scalar quantities associated with the training stage. In this example, accuracy and binary cross entropy are being represented:</p>
			<div>
				<div id="_idContainer379" class="IMG---Figure">
					<img src="image/B16182_03_24.jpg" alt="Figure 3.24: TensorBoard scalars&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.24: TensorBoard scalars</p>
			<p>The second view provides a block diagram visualization of the computational graph, where all the layers are reported together with their relations, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer380" class="IMG---Figure">
					<img src="image/B16182_03_25.jpg" alt="Figure 3.25: TensorBoard graph&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.25: TensorBoard graph</p>
			<p>The <strong class="source-inline">DISTRIBUTIONS</strong> tab provides an overview of how the model parameters are distributed across epochs, as shown in the following figure:</p>
			<div>
				<div id="_idContainer381" class="IMG---Figure">
					<img src="image/B16182_03_26.jpg" alt="Figure 3.26: TensorBoard distributions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.26: TensorBoard distributions</p>
			<p>Finally, the <strong class="source-inline">HISTOGRAMS</strong> tab provides similar information to the <strong class="source-inline">DISTRIBUTIONS</strong> tab, but is unfolded in 3D, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer382" class="IMG---Figure">
					<img src="image/B16182_03_27.jpg" alt="Figure 3.27: TensorBoard histograms&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.27: TensorBoard histograms</p>
			<p>In this section and, in particular, in the following exercise, TensorBoard will be leveraged to easily visualize metrics in terms of trends, tensor graphs, distributions, and histograms.</p>
			<p>In order to focus only on TensorBoard, the very same classification exercise we performed in the previous section will be used. Only the large model will be trained. All we need is to import TensorBoard and activate it, as well as a definition of the log file directory. </p>
			<p>A TensorBoard callback is then created and passed to the <strong class="source-inline">fit</strong> method of the model. This will generate all TensorBoard files inside the log directory. Once training is complete, this log directory path is passed to TensorBoard as an argument. This will open a web-based visualization where the user is able to gain deep insights into its model and training-related aspects.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor167"/>Exercise 3.07: Creating a Deep Neural Network to Classify Events Generated by the ATLAS Experiment in the Quest for the Higgs Boson Using TensorBoard for Visualization</h2>
			<p>In this exercise, we will build, train, and measure the performance of a deep neural network with the same goal of <em class="italic">Exercise 3.06, Creating a Deep Neural Network to Classify Events Generated by the ATLAS Experiment in the Quest for Higgs Boson</em> in mind, but instead, we will leverage TensorBoard so that we can gain additional training insights. </p>
			<p>The following steps need to be implemented in order to complete this exercise:</p>
			<ol>
				<li value="1">Import all the required modules:<p class="source-code">from __future__ import absolute_import, division, \</p><p class="source-code">print_function, unicode_literals</p><p class="source-code">from  IPython import display</p><p class="source-code">from matplotlib import pyplot as plt</p><p class="source-code">from scipy.ndimage.filters import gaussian_filter1d</p><p class="source-code">import pandas as pd</p><p class="source-code">import numpy as np</p><p class="source-code">import datetime</p><p class="source-code"> </p><p class="source-code">import tensorflow as tf</p><p class="source-code"> </p><p class="source-code">!rm -rf ./logs/ </p><p class="source-code"> </p><p class="source-code"># Load the TensorBoard notebook extension</p><p class="source-code">%load_ext tensorboard</p></li>
				<li>Download the custom smaller subset of the original dataset:<p class="source-code">higgs_path = tf.keras.utils.get_file('HIGGSSmall.csv.gz', \</p><p class="source-code">             'https://github.com/PacktWorkshops/'\</p><p class="source-code">             'The-Reinforcement-Learning-Workshop/blob/master/'\</p><p class="source-code">             'Chapter03/Dataset/HIGGSSmall.csv.gz?raw=true')</p></li>
				<li>Read the CSV dataset into the TensorFlow dataset class and repack it so that it has tuples (<strong class="source-inline">features</strong>, <strong class="source-inline">labels</strong>):<p class="source-code">N_TEST = int(1e3)</p><p class="source-code">N_VALIDATION = int(1e3)</p><p class="source-code">N_TRAIN = int(1e4)</p><p class="source-code">BUFFER_SIZE = int(N_TRAIN)</p><p class="source-code">BATCH_SIZE = 500</p><p class="source-code">STEPS_PER_EPOCH = N_TRAIN//BATCH_SIZE</p><p class="source-code"> </p><p class="source-code">N_FEATURES = 28</p><p class="source-code"> </p><p class="source-code">ds = tf.data.experimental.CsvDataset\</p><p class="source-code">     (higgs_path,[float(),]*(N_FEATURES+1), \</p><p class="source-code">      compression_type="GZIP")</p><p class="source-code">def pack_row(*row):</p><p class="source-code">    label = row[0]</p><p class="source-code">    features = tf.stack(row[1:],1)</p><p class="source-code">    return features, label</p><p class="source-code">packed_ds = ds.batch(N_TRAIN).map(pack_row).unbatch()</p></li>
				<li>Create training, validation, and test sets and assign them the <strong class="source-inline">BATCH_SIZE</strong> parameter:<p class="source-code">validate_ds = packed_ds.take(N_VALIDATION).cache()</p><p class="source-code">test_ds = packed_ds.skip(N_VALIDATION).take(N_TEST).cache()</p><p class="source-code">train_ds = packed_ds.skip(N_VALIDATION+N_TEST)\</p><p class="source-code">           .take(N_TRAIN).cache()</p><p class="source-code"> </p><p class="source-code">test_ds = test_ds.batch(BATCH_SIZE)</p><p class="source-code">validate_ds = validate_ds.batch(BATCH_SIZE)</p><p class="source-code">train_ds = train_ds.shuffle(BUFFER_SIZE)\</p><p class="source-code">           .repeat().batch(BATCH_SIZE)</p></li>
				<li>Now, let's start creating the model and training it. Create a decaying learning rate:<p class="source-code">lr_schedule = tf.keras.optimizers.schedules\</p><p class="source-code">              .InverseTimeDecay(0.001, \</p><p class="source-code">                                decay_steps=STEPS_PER_EPOCH*1000,\</p><p class="source-code">                                decay_rate=1, staircase=False)</p></li>
				<li>Define a function that will compile a model with the <strong class="source-inline">Adam</strong> optimizer and use binary cross entropy as the <strong class="source-inline">loss</strong> function. Then, fit it on the training data using early stopping by using the validation dataset, as well as a TensorBoard callback:<p class="source-code">log_dir = "logs/fit/" + datetime.datetime.now()\</p><p class="source-code">          .strftime("%Y%m%d-%H%M%S")</p><p class="source-code">def compile_and_fit(model, name, max_epochs=3000):</p><p class="source-code">    optimizer = tf.keras.optimizers.Adam(lr_schedule)</p><p class="source-code">    model.compile(optimizer=optimizer,\</p><p class="source-code">    loss=tf.keras.losses.BinaryCrossentropy(from_logits=True),\</p><p class="source-code">    metrics=[tf.keras.losses.BinaryCrossentropy\</p><p class="source-code">            (from_logits=True, name='binary_crossentropy'),\</p><p class="source-code">             'accuracy'])</p><p class="source-code">    model.summary()</p><p class="source-code">    tensorboard_callback = tf.keras.callbacks.TensorBoard\</p><p class="source-code">                           (log_dir=log_dir,\</p><p class="source-code">                            histogram_freq=1,\</p><p class="source-code">                            profile_batch=0)</p><p class="source-code">    history = model.fit\</p><p class="source-code">              (train_ds,\</p><p class="source-code">               steps_per_epoch = STEPS_PER_EPOCH,\</p><p class="source-code">               epochs=max_epochs,\</p><p class="source-code">               validation_data=validate_ds,\</p><p class="source-code">               callbacks=[tf.keras.callbacks.EarlyStopping\</p><p class="source-code">                         (monitor='val_binary_crossentropy',\</p><p class="source-code">                          patience=200),\</p><p class="source-code">                          tensorboard_callback],               verbose=2)</p><p class="source-code">    return history</p></li>
				<li>Create the same large model as before with regularization items such as L2 regularization and dropout, and then compile it and fit it on the dataset:<p class="source-code">regularization_model = tf.keras.Sequential([\</p><p class="source-code">                       tf.keras.layers.Dense(512,\</p><p class="source-code">                       kernel_regularizer=tf.keras.regularizers\</p><p class="source-code">                                          .l2(0.0001),\</p><p class="source-code">                       activation='elu', \</p><p class="source-code">                       input_shape=(N_FEATURES,)),\</p><p class="source-code">                       tf.keras.layers.Dropout(0.5),\</p><p class="source-code">                       tf.keras.layers.Dense(512,\</p><p class="source-code">                       kernel_regularizer=tf.keras.regularizers\</p><p class="source-code">                                          .l2(0.0001),\</p><p class="source-code">                       activation='elu'),\</p><p class="source-code">                       tf.keras.layers.Dropout(0.5),\</p><p class="source-code">                       tf.keras.layers.Dense(512,\</p><p class="source-code">                       kernel_regularizer=tf.keras.regularizers\</p><p class="source-code">                                          .l2(0.0001),\</p><p class="source-code">                       activation='elu'),\</p><p class="source-code">                       tf.keras.layers.Dropout(0.5),\</p><p class="source-code">                       tf.keras.layers.Dense(512,\</p><p class="source-code">                       kernel_regularizer=tf.keras.regularizers\</p><p class="source-code">                                          .l2(0.0001),\</p><p class="source-code">                       activation='elu'),\</p><p class="source-code">                       tf.keras.layers.Dropout(0.5),\</p><p class="source-code">                       tf.keras.layers.Dense(1)])</p><p class="source-code">compile_and_fit(regularization_model,\</p><p class="source-code">                "regularizers/regularization", max_epochs=9000)</p><p>The last output line will be as follows:</p><p class="source-code">Epoch 1112/9000</p><p class="source-code">20/20 - 1s - loss: 0.5887 - binary_crossentropy: 0.5515 </p><p class="source-code">- accuracy: 0.6949 - val_loss: 0.5831 </p><p class="source-code">- val_binary_crossentropy: 0.5459 - val_accuracy: 0.6960</p></li>
				<li>Check the model's performances on the test set:<p class="source-code">test_accuracy = tf.keras.metrics.Accuracy()</p><p class="source-code">for (features, labels) in test_ds:</p><p class="source-code">    logits = regularization_model(features)</p><p class="source-code">    probabilities = tf.keras.activations.sigmoid(logits)</p><p class="source-code">    predictions = 1*(probabilities.numpy() &gt; 0.5)</p><p class="source-code">    test_accuracy(predictions, labels)</p><p class="source-code">print("Test set accuracy: {:.3%}".format(test_accuracy.result()))</p><p>The output will be as follows:</p><p class="source-code">Test set accuracy: 69.300%</p><p class="callout-heading">Note</p><p class="callout">The accuracy may show slightly different values due to random sampling with a variable random seed.</p></li>
				<li>Visualize the variables with TensorBoard:<p class="source-code">%tensorboard --logdir logs/fit</p><p>This command starts the web-based visualization tool. Four main windows are represented in the following figure, displaying information about loss and accuracy, model graphs, histograms, and distributions in a clockwise order, starting from the top left:</p></li>
			</ol>
			<div>
				<div id="_idContainer383" class="IMG---Figure">
					<img src="image/B16182_03_28.jpg" alt="Figure 3.28: TensorBoard visualization&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.28: TensorBoard visualization</p>
			<p>The advantages of using TensorBoard are quite evident: all the training information is collected in a single place, allowing the user to easily navigate through it. The top-left panel, the <strong class="source-inline">SCALARS</strong> tab, allows the user to monitor loss and accuracy so that they are able to check the same chart we saw previously in an easier way. </p>
			<p>In the top right, the model graph is shown, so it is possible to visualize how input data flows into the computational graph by going through each block.</p>
			<p>The two views at the bottom show the same information in two different representations: all the model parameter (networks weights and biases) distributions are shown across training epochs. On the left, the <strong class="source-inline">DISTRIBUTIONS</strong> tab displays the parameters in 2D, while the <strong class="source-inline">HISTOGRAMS</strong> tab unfolds the parameters in 3D. They both allow the user to monitor how trainable parameters vary during the training step.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2AWGjFv">https://packt.live/2AWGjFv</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2YrWl2d">https://packt.live/2YrWl2d</a>.</p>
			<p>In this section, we focused on providing some insights into how to use TensorBoard to visualize training-related model parameters. We saw how, starting with an already familiar problem, it is super easy to add the TensorBoard web-based visualization tool and navigate through all of its plugins directly inside a Python notebook.</p>
			<p>Now, let's complete an activity to put all our knowledge to the test.</p>
			<h2 id="_idParaDest-128">Activity 3.01: Classifying F<a id="_idTextAnchor168"/>ashion Clothes Using a TensorFlow Dataset and TensorFlow 2</h2>
			<p>Suppose you need to code an image processing algorithm for a company that owns a clothes warehouse. They want to autonomously classify clothes based on a camera output, thereby allowing them to group clothes together with no human intervention.</p>
			<p>In this activity, we will create a deep fully connected neural network capable of doing such a task, meaning that it will accurately classify images of clothes by assigning them to the class they belong to.</p>
			<p>The following steps will help you to complete this activity:</p>
			<ol>
				<li value="1">Import all the required modules, such as <strong class="source-inline">numpy</strong>, <strong class="source-inline">matplotlib.pyplot</strong>, <strong class="source-inline">tensorflow</strong>, and <strong class="source-inline">tensorflow_datasets</strong>, and print out their main module versions.</li>
				<li>Import the Fashion MNIST dataset using TensorFlow datasets and split it into train and test sets.</li>
				<li>Explore the dataset to get familiar with the input features, that is, shapes, labels, and classes.</li>
				<li>Visualize some instances of the training set. </li>
				<li>Perform data normalization by building the classification model.</li>
				<li>Train the deep neural network.</li>
				<li>Test the model's accuracy. You should obtain an accuracy in excess of 88%.</li>
				<li>Perform inference and check the predictions against the ground truth.<p>By the end of this activity, the trained model should be able to classify all the fashion items (clothes, shoes, bags, and so on) with an accuracy greater than 88%, thus producing a result similar to the one shown in the following image:</p></li>
			</ol>
			<div>
				<div id="_idContainer384" class="IMG---Figure">
					<img src="image/B16182_03_29.jpg" alt="Figure 3.29: Clothes classification with a deep neural network output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.29: Clothes classification with a deep neural network output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 696.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor169"/>Summary</h1>
			<p>In this chapter, we were introduced to practical deep learning with TensorFlow 2 and Keras, their key features and applications, and how they work together. We became familiar with the differences between low- and high-level APIs, as well as how to leverage the most advanced modules to ease the creation of deep models. Then, we discussed how to implement a deep neural network with TensorFlow and addressed some major topics: from model creation, training, validation, and testing, we highlighted the most important aspects to consider so as to avoid pitfalls. We saw how to build different types of deep learning models, such as fully connected, convolutional, and recurrent neural networks, via the Keras API. We solved a regression task and a classification problem, which gave us hands-on experience with this. We learned how to leverage TensorBoard to visualize many different training trends regarding metrics and model parameters. Finally, we built and trained a model that is able to classify fashion item images with high accuracy, an activity that shows that a possible real-world problem can be solved with the help of the most advanced deep learning techniques. </p>
			<p>In the next chapter, we will be studying the OpenAI Gym environment and how to use TensorFlow 2 for reinforcement learning.</p>
		</div>
		<div>
			<div id="_idContainer386" class="Content">
			</div>
		</div>
	</body></html>