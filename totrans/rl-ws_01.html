<html><head></head><body>
		<div>
			<div id="_idContainer008" class="Content">
			</div>
		</div>
		<div id="_idContainer009" class="Content">
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>1. Introduction to Reinforcement Learning</h1>
		</div>
		<div id="_idContainer136" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces the <strong class="bold">Reinforcement Learning</strong> (<strong class="bold">RL</strong>) framework, which is one of the most exciting fields of machine learning and artificial intelligence. You will learn how to describe the characteristics and advanced applications of RL to show what can be achieved within this framework. You will also learn to differentiate between RL and other learning approaches. You will learn the main concepts of this discipline both from a theoretical point of view and from a practical point of view using Python and other useful libraries.</p>
			<p class="callout">By the end of the chapter, you will understand what RL is and know how to use the Gym toolkit and Baselines, two popular libraries in this field, to interact with an environment and implement a simple learning loop.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Introduction</h1>
			<p>Learning and adapting to new circumstances is a crucial process for humans and, in general, for all animals. Usually, learning is intended as a process of trial and error through which we improve our performance in particular tasks. Our life is a continuous learning process, that is, we start from simple goals (for example, walking), and we end up pursuing difficult and complex tasks (for example, playing a sport). As humans, we are always driven by our reward mechanism, which awards good behaviors and punishes bad ones. </p>
			<p><strong class="bold">Reinforcement Learning</strong> (<strong class="bold">RL</strong>), inspired by the human learning process, is a subfield of machine learning and deals with learning from interaction. With the term "interaction," we mean the process of trial and error through which we, as humans, understand the consequences of our actions and build up our own experiences. </p>
			<p>RL, in particular, considers sequential decision-making problems. These are problems in which an agent has to take a sequence of decisions, that is, actions, to maximize a certain performance measure.</p>
			<p>RL considers tasks to be <strong class="bold">Markov Decision Processes</strong> (<strong class="bold">MDPs</strong>), which are problems arising in many real-world scenarios. In this setting, the decision-maker, referred to as the agent, has to make decisions accounting for environmental uncertainty and experience. Agents are goal-directed; they need only a notion of a goal, such as a numerical signal, to be maximized. Unlike supervised learning, in RL, there is no need to provide good examples; it is the agent who learns how to map situations to actions. The mapping from situations (states) to actions is called "policy" in literature, and it represents the agent's behavior or strategy. Solving an MDP means finding the agent's policy by maximizing the desired outcome (that is, the total reward). We will study MDPs in more detail in future chapters.</p>
			<p>RL has been successfully applied to various kinds of problems and domains, showing exciting results. This chapter is an introduction to RL. It aims to explain some applications and describe concepts both from an intuitive perspective and from a mathematical point of view. Both of these aspects are very important when learning new disciplines. Without intuitive understanding, it is impossible to make sense of formulas and algorithms; without mathematical background, it is tough to implement existing or new algorithms.</p>
			<p>In this chapter, we will first compare the three main machine learning paradigms, namely supervised learning, RL, and unsupervised learning. We will discuss their differences and similarities and define some example problems.</p>
			<p>Second, we will move on to a section that contains the theory of RL and its notations. We will learn about concepts such as what an agent is, what an environment is, and how to parameterize different policies. This section represents the fundamentals of this discipline.</p>
			<p>Third, we will begin using two RL frameworks, namely Gym and Baselines. We will learn that interacting with a Gym environment is extremely simple, as is learning a task using Baselines algorithms.</p>
			<p>Finally, we will explore some RL applications to motivate you to study this discipline, showing various techniques that can be used to face real-world problems. RL is not bound to the academic world. However, it is still crucial from an industrial point of view, allowing you to solve problems that are almost impossible to solve using other techniques.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Learning Paradigms</h1>
			<p>In this section, we will discuss the similarities and differences between the three main <strong class="bold">learning paradigms</strong> under the umbrella of machine learning. We will analyze some representative problems in order to understand the characteristics of these frameworks better.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Introduction to Learning Paradigms</h2>
			<p>For a learning paradigm, we implement a problem and a solution method. Usually, learning paradigms deal with data and rephrase the problem in a way that can be solved by finding parameters and maximizing an objective function. In these settings, the problem can be faced using mathematical and optimization tools, allowing a formal study. The term "learning" is often used to represent a dynamic process of adapting the algorithm's parameters in such a way as to optimize their performance (that is, to learn) on a given task. Tom Mitchell defined learning in a precise way, as follows:</p>
			<p><em class="italic">"A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E."</em></p>
			<p>Let's rephrase the preceding definition more intuitively. To define whether a program is learning, we need to set a task; that is the goal of the program. The task can be everything we want the program to do, that is, play a game of chess, do autonomous driving, or carry out image classification. The problem should be accompanied by a performance measure, that is, a function that returns how well the program is performing on that task. For the chess game, a performance function can simply be represented by the following:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B16182_01_01.jpg" alt="Figure 1.1: A performance function for a game of chess&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1: A performance function for a game of chess</p>
			<p>In this context, the experience is the amount of data collected by the program at a specific moment. For chess, the experience is represented by the set of games played by the program.</p>
			<p>The same input presented at the beginning of the learning phase or the end of the learning phase can result in different responses (that is, outputs) from the algorithm; the differences are caused by the algorithm's parameters being updated during the process.</p>
			<p>In the following table, we can see some examples of the experience, task, and performance tuples to better understand their concrete instantiations:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B16182_01_02.jpg" alt="Figure 1.2: Table for instantiations &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2: Table for instantiations </p>
			<p>It is possible to classify the learning algorithms based on the input they have and on the feedback they receive. In the following section, we will look at the three main learning paradigms in the context of machine learning based on this classification.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Supervised versus Unsupervised versus RL</h2>
			<p>The three main learning paradigms are supervised learning, unsupervised learning, and RL. The following figure represents the general schema of each of these learning paradigms:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B16182_01_03.jpg" alt="Figure 1.3: Representation of learning paradigms&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3: Representation of learning paradigms</p>
			<p>From the preceding figure, we can derive the following information:</p>
			<ul>
				<li>Supervised learning minimizes the error of the output of the model with respect to a target specified in the training set.</li>
				<li>RL maximizes the reward signal of the actions.</li>
				<li>Unsupervised learning has no target and no reward; it tries to learn a data representation that can be useful.</li>
			</ul>
			<p>Let's go more in-depth and elaborate on these concepts further, particularly from a mathematical perspective.</p>
			<p>Supervised learning deals with learning a function by mapping an input to an output when th<a id="_idTextAnchor023"/>e correspondences between the input and output (sample, label) are given by an external teacher (supervisor) and are contained in a training set. The objective of supervised learning is to generalize to unseen samples that are not included in the dataset, resulting in a system (for example, a function) that is able to respond correctly in new situations. Here, the correspondences between the sample and label are usually known (for example, in the training set) and given to the system. Examples of supervised learning tasks include regression and classification problems. In a regression task, the learner has to find a function, <img src="image/B16182_01_03d.png" alt="a"/>, of the input, <img src="image/B16182_01_03a.png" alt="b"/>, producing a (or <img src="image/B16182_01_03b.png" alt="e"/>, in general) real output,<img src="image/B16182_01_03c.png" alt="c"/>. In mathematical notation, we have to find <img src="image/B16182_01_03e.png" alt="d"/> such that:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B16182_01_04.jpg" alt="Figure 1.4: Regression&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4: Regression</p>
			<p>Here, <img src="image/B16182_01_04a.png" alt="f"/> is known for the examples in the training set. In a classification task, the function to be learned is a discrete mapping; <img src="image/B16182_01_04b.png" alt="7"/> belongs to a finite and discrete set. Formalizing the problem, we search for a discrete-valued function, <img src="image/B16182_01_04c.png" alt="8"/>, such that: </p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B16182_01_05.jpg" alt="Figure 1.5: Classification&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5: Classification</p>
			<p>Here, the set, <img src="image/B16182_01_05a.png" alt="A picture containing clock&#10;&#10;Description automatically generated"/>, represents the set of possible classes or categories. </p>
			<p>Unsupervised learning deals with learning patterns in the data when the target label is not present or is unknown. The objective of unsupervised learning is to find a new, usually smaller, representation of data. Examples of unsupervised learning algorithms include clustering and <strong class="bold">Principal Component Analysis (PCA)</strong>.</p>
			<p>In a clustering task, the learner should split the dataset into clusters (a group of elements) according to some similarity measure. At first glance, clustering may seem very similar to classification; however, as an unsupervised learning task, the labels, or classes, are not given to the algorithm inside the training set. Indeed, it is the algorithm itself that should make sense of its inputs, by learning a representation of the input space in such a way that similar samples are close to each other. </p>
			<p>For example, in the following <a href="B16182_01_Final_SZ_ePub.xhtml#_idTextAnchor025"/>figure, we have the original data on the left; on the right, we have the possible output of a clustering algorithm. Different colors denote different clusters:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B16182_01_06.jpg" alt="Figure 1.6: An example of a clustering application &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6: An <a id="_idTextAnchor024"/><a id="_idTextAnchor025"/>example of a clustering application </p>
			<p>In the preceding example, the input space is composed of two dimensions, that is, <img src="image/B16182_01_06a.png" alt="g"/>, and the algorithm found three clusters or three groups of similar elements.</p>
			<p>PCA is an unsupervised algorithm used for dimensionality reduction and feature extraction. PCA tries to make sense of data by searching for a representation that contains most of the information from the given data.</p>
			<p>RL is different from both supervised and unsupervised learning. RL deals with learning control actions in a sequential decision-making problem. The sequential structure of the problem makes RL challenging and different from the two other paradigms. Moreover, in supervised and unsupervised learning, the dataset is fixed. In RL, the dataset is continuously changing, and dataset creation is itself the agent's task. In RL, different from supervised learning, no teacher provides the correct value for a given sample or the right action for a given situation. RL is based on a different form of feedback, which is the environment's feedback evaluating the behavior of the agent. It is precisely the presence of feedback that also makes RL different from unsupervised learning.</p>
			<p>We will explore these concepts in more detail in future sections:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B16182_01_07.jpg" alt="Figure 1.7: Machine learning paradigms and their relationships&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7: Machine learning paradigms and their relationships</p>
			<p>RL and supervised learning can also be mixed up. A common technique (also used by AlphaGo Zero) is called <strong class="bold">imitation learning</strong> (or behavioral cloning). Instead of learning a task from scratch, we teach the agent in a supervised way how to behave (or which action to take) in a given situation. In this context, we have an expert (or multiple experts) demonstrating to the agent the desired behavior. In this way, the agent can start building its internal representation and its initial knowledge. Its actions won't be random at all when the RL part begins, and its behavior will be more focused on the actions shown by the expert.</p>
			<p>Let's now look at a few scenarios that will help us to classify the problems in a better manner.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor026"/>Classifying Common Problems into Learning Scenarios</h2>
			<p>In this section, we will understand how it is possible to frame some common real-world problems into a learning framework by defining the required elements.</p>
			<h3 id="_idParaDest-25"><a id="_idTextAnchor027"/>Predicting Whether an Image Contains a Dog or a Cat</h3>
			<p>Predicting the content of an image is a standard classification example; therefore, it lies under the umbrella of supervised learning. Here, we are given a picture, and the algorithm should decide whether the image contains a dog or a cat. The input is the image, and the associated label can be 0 for cats and 1 for dogs.</p>
			<p>For a human, this is a straightforward task, as we have an internal representation of dogs and cats (as well as an internal representation of the world), and we are trained extensively in our life to recognize dogs and cats. Despite this, writing an algorithm that is able to identify whether an image contains a dog or a cat is a difficult task without machine learning techniques. For a human, it is elementary to know whether the image is of a dog or cat; it is also easy to create a simple dataset of images of cats and dogs. </p>
			<p><em class="italic">Why Not Unsupervised Learning?</em></p>
			<p>Unsupervised learning is not suited to this type of task as we have a defined output we need to obtain from an input. Of course, supervised learning methods build an internal representation of the input data in which similarities are better exploited. This representation is only implicit; it is not the output of the algorithm as is the case in unsupervised learning.</p>
			<p><em class="italic">Why Not RL?</em></p>
			<p>RL, by definition, considers sequential decision-making problems. Predicting the content of an image is not a sequential problem, but instead a one-shot task.</p>
			<h3 id="_idParaDest-26"><a id="_idTextAnchor028"/>Detecting and Classifying All Dogs and Cats in an Image</h3>
			<p>Detection and classification are two examples of supervised learning problems. However, this task is more complicated than the previous one. The detection part can be seen as both a regression and classification problem at the same time. The input is always the image we want to analyze, and the output is the coordinate of the bounding boxes for each dog or cat in the picture. Associated with each bounding box, we have a label to classify the content in the region of interest as a dog or a cat: </p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B16182_01_08.jpg" alt="Figure 1.8: Cat and dog detection and classification&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8: Cat and dog detection and classification</p>
			<p><em class="italic">Why Not Unsupervised Learning?</em></p>
			<p>As in the previous example, here, we have a determined output given an input (an image). We do not want to extract unknown patterns in the data. </p>
			<p><em class="italic">Why Not RL?</em></p>
			<p>Detection and classification are not tasks that are suited to the RL framework. We do not have a set of actions the agent should take to solve a problem. Also, in this case, the sequential structure is absent.</p>
			<h3 id="_idParaDest-27"><a id="_idTextAnchor029"/>Playing Chess</h3>
			<p>Playing chess can be seen as an RL problem. The program can perceive the current state of the board (for example, the positions and types of pawns), and, based on that, it should decide which action to take. Here, the number of possible actions is vast. Selecting an action means to understand and anticipate the consequences of the move to defeat the opponent:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B16182_01_09.jpg" alt="Figure 1.9: Chess as an RL problem&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9: Chess as an RL problem</p>
			<p><em class="italic">Why Not Supervised?</em></p>
			<p>We can think of playing chess as a supervised learning problem, but we would need to have a dataset, and we should incorporate the sequential structure of the game into the supervised learning problem. In RL, there is no need to have a dataset; it is the algorithm itself that builds up a dataset through interaction and, possibly, self-play.</p>
			<p><em class="italic">Why Not Unsupervised?</em></p>
			<p>Unsupervised learning does not fit in this problem as we are not dealing with learning a representation of the data; we have a defined objective, which is winning the game.</p>
			<p>In this section, we compared the three main learning paradigms. We saw the kind of data they have at their disposal, the type of interaction each algorithm has with the external world, and we analyzed some particular problems to understand which learning paradigm is best suited.</p>
			<p>When facing a real-world problem, we always have to remember the distinction between these techniques, selecting the best one based on our goals, our data, and on the problem structure.</p>
			<h1 id="_idParaDest-28">Fundamentals of Rei<a id="_idTextAnchor030"/>nforcement Learning</h1>
			<p>In RL, the main goal is to learn from interaction. We want agents to learn a behavior, a way of selecting actions in given situations, to achieve some goal. The main difference between classical programming or planning is that we do not want to code the planning software explicitly on our own, as this would require a great effort; it can be very inefficient and even impossible. The RL discipline was born precisely for this reason.</p>
			<p>RL agents start (usually) with no idea of what to do. They typically do not know the goal, they do not know the game's rules, and they do not know the dynamics of the environment or how their actions influence the state.</p>
			<p>There are three main components of RL: perception, actions, and goals.</p>
			<p>Agents should be able to perceive the current environment state to deal with a task. This perception, also called observation, might be different from the actual environment state, can be subject to noise, or can be partial.</p>
			<p>For example, think of a robot moving in an unknown environment. For robotic applications, usually, the robot perceives the environment using cameras. Such a perception does not represent the environment state completely; it can be subject to occlusions, poor lighting, or adverse conditions. The system should be able to deal with this incomplete representation and learn a way of moving in the environment.</p>
			<p>The other main component of an agent is the ability to act; the agent should be able to take actions that affect the environment state or the agent's state.  </p>
			<p>Agents should also have a goal defined through the environment state. Goals are described using high-level concepts such as winning a game, moving in an environment, or driving correctly. </p>
			<p>One of the challenges of RL, a challenge that does not arise in other types of learning, is the exploration-exploitation trade-off. In order to improve, the agent has to exploit its knowledge; it should prefer actions that have demonstrated themselves as useful in the past. There's a problem here: to discover better actions, the agent should continue exploring, trying moves they have never done before. To estimate the effect of an action reliably, an agent has to perform each action many times. The critical thing to notice here is that neither exploration nor exploitation can be performed individually in order to learn a task.</p>
			<p>The aforementioned is very similar to the challenges we face as babies when we have to learn how to walk. At first, we try different types of movement, and we start from a simple movement yielding satisfactory results: crawling. Then, we want to improve our behavior to become more efficient. To learn a new behavior, we have to do movements we never did before: we try to walk. At first, we perform different actions yielding unsatisfactory results: we fall many times. Once we discover the correct way of moving our legs and balancing our body, we become more efficient in walking. If we did not explore further and we stopped at the first behavior that yields satisfactory results, we would crawl forever. By exploring, we learn that there can be different behaviors that are more efficient. Once we learn how to walk, we can stop exploring, and we can start exploiting our knowledge.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor031"/>Elements of RL</h2>
			<p>Let'<a id="_idTextAnchor032"/>s introduce the main elements of the RL framework intuitively.</p>
			<h3 id="_idParaDest-30"><a id="_idTextAnchor033"/>Agent</h3>
			<p>In RL, the agent is the abstract concept of the entity that moves in the world, takes actions, and achieves goals. An agent can be a piece of autonomous driving software, a chess player, a Go player, an algorithmic trader, or a robot. The agent is everything that can perceive and influence the state of the environment and, therefore, can be used to accomplish goals.</p>
			<h3 id="_idParaDest-31"><a id="_idTextAnchor034"/>Actions</h3>
			<p>An agent can perform actions based on the current situation. Actions can assume different forms depending on the specific task.</p>
			<p>Actions can be to steer, to push the accelerator pedal, or to push the brake pedal in an autonomous driving context. Other examples of actions include moving the horse to the H5 position or moving the king to the A5 position in a chess context.</p>
			<p>Actions can be low-level, such as controlling the voltage of the motors of a vehicle, but they can also be high-level, or planning actions, such as deciding where to go. The decision on the action level is the responsibility of the algorithm's designer. Actions that are too high-level can be challenging to implement at a lower level; they might require extensive planning at lower levels. At the same time, low-level actions make the problem difficult to learn. </p>
			<h3 id="_idParaDest-32"><a id="_idTextAnchor035"/>Environment</h3>
			<p>The environment represents the context in which the agent moves and takes decisions. An environment is composed of three main elements: states, dynamics, and rewards. They can be explained as follows:</p>
			<ul>
				<li><strong class="bold">State</strong>: This represents all of the information describing the environment at a particular timestep. The state is available to the agent through observations, which can be a partial or full representation.</li>
				<li><strong class="bold">Dynamics</strong>: The dynamics of an environment describe how actions influence the state of the environment. The environment dynamic is usually very complex or unknown. An RL algorithm using the information of the environment dynamic to learn how to achieve a goal belongs to the category of model-based RL, where the model represents the mathematical description of the environment. Most of the time, the environment dynamic is not available to the agent. In this case, the algorithm belongs to the model-free category. Even if the environment model is not available, too complicated, or too approximated, the agent can learn a model of the environment during training. Also, in this case, the algorithm is said to be model-based.</li>
				<li><strong class="bold">Rewards</strong>: Rewards are scalar values associated with each timestep describing the agent's goal. Rewards can also be described as environmental feedback, providing information to an agent about its behavior; it is, therefore, necessary for making learning possible. If the agent receives a high reward, it means that it performed a good move, a move bringing it closer to its goal.</li>
			</ul>
			<h3 id="_idParaDest-33"><a id="_idTextAnchor036"/>Policy</h3>
			<p>A policy describes the behavior of the agent. Agents select actions by following their policies. Mathematically, a policy is a function mapping states to actions. What does this mean? Well, it means that the input of the policy is the current state, and its output is the action to take. A policy can have different forms. It can be a simple set of rules, a lookup table, a neural network, or any function approximator. A policy is the core of the RL framework, and the goal of all RL algorithms (implicit or explicit) is to improve the agent's policy to maximize the agent's performance on a task (or on a set of tasks). A policy can be stochastic, involving a distribution over actions, or it can be deterministic. In the latter case, the selected action is uniquely determined by the environment's state.</p>
			<h3 id="_idParaDest-34"><a id="_idTextAnchor037"/>An Example of an Autonomous Driving Environment</h3>
			<p>To better understand the environment's role and its characteristics in the RL framework, let's formalize an autonomous driving environment, as shown in the following figure:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B16182_01_10.jpg" alt="Figure 1.10: An autonomous driving scenario&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.10: An autonomous driving scenario</p>
			<p>Considering the preceding figure, let's now look at each of the components of the environment:</p>
			<ul>
				<li><strong class="bold">State</strong>: The state can be represented by the 360-degree image of the street around our car. In this case, the state is an image, that is, a matrix of pixels. It can also be represented by a series of images covering the whole space around the car. Another possibility is to describe the state using features and not images. The state can be the current velocity and acceleration of our vehicle, the distance from other cars, or the distance from the street border. In this case, we are using preprocessed information to represent the state more easily. These features can be extracted from images or other types of sensors (for example, <strong class="bold">Light Detection and Ranging – LIDAR</strong>).</li>
				<li><strong class="bold">Dynamics</strong>: The dynamics of the environment in an autonomous car scenario are represented by the equations describing how the system changes when the car accelerates, breaks, or steers. For instance, the vehicle is going at 30 km/h, and the next vehicle is 100 meters away from it. The state is represented by the car's speed and the proximity information concerning the next vehicle. If the car accelerates, the speed changes according to the car's properties (included in the environment dynamics). Also, the proximity information changes since the next vehicle can be closer or further away (according to the speed). In this situation, at the next timestep, the car's speed can be 35 km/h, and the next vehicle can be closer, for example, only 90 meters away.</li>
				<li><strong class="bold">Reward</strong>: The reward can represent how well the agent is driving. It's not easy to formalize a reward function. A natural reward function should award states in which the car is aligned to the street and should avoid states in which the car crashes or goes off the road. The reward function definition is an open problem and researchers are putting efforts into developing algorithms where the reward function is not needed (self-motivation or curiosity-driven agents), where the agent learns from demonstrations (imitation learning), and where the agent recovers the reward function from demonstrations (<strong class="bold">Inverse Reinforcement Learning or IRL</strong>).<p class="callout-heading">Note</p><p class="callout">For further reading on curiosity-driven agents, please refer to the following paper: <a href="https://pathak22.github.io/large-scale-curiosity/resources/largeScaleCuriosity2018.pdf">https://pathak22.github.io/large-scale-curiosity/resources/largeScaleCuriosity2018.pdf</a>.</p></li>
			</ul>
			<p>We are now ready to design and implement our first environment class using Python. We will demonstrate how to implement the state, the dynamics, and the reward of a toy problem in the following exercise.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor038"/>Exercise 1.01: Implementing a Toy Environment Using Python</h2>
			<p>In this exercise, we will implement a simple toy environment using Python. The environment is illustrated in<a href="B16182_01_Final_SZ_ePub.xhtml#_idTextAnchor039"> <em class="italic">Figure 1.11</em></a>. It is composed of three states (1, 2, 3) and two actions (A and B). The initial state is state 1. States are represented by nodes. Edges represent transitions between states. On the edges, we have an action causing the transition and the associated reward. </p>
			<p>The representation of the environment in <em class="italic">Figure 1.11</em> is the standard environment representation in the context of RL. In this exercise, we will become acquainted with the concept of the environment and its implementation:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B16182_01_11.jpg" alt="Figure 1.11: A toy environment composed of three states (1, 2, 3) and two actions (A and B)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.11: A toy <a id="_idTextAnchor039"/><a id="_idTextAnchor040"/>environment composed of three states (1, 2, 3) and two actions (A and B)</p>
			<p>In the preceding figure, the reward is associated with each state-action pair.</p>
			<p>The goal of this exercise is to implement an <strong class="source-inline">Environment</strong> class with a <strong class="source-inline">step()</strong> method that takes as input the agent's actions and returns a state-action pair (next state, reward). In addition to this, we will write a <strong class="source-inline">reset()</strong> method that restarts the environment's state:</p>
			<ol>
				<li>Create a new Jupyter notebook or a simple Python script to enter the code.</li>
				<li>Import the <strong class="source-inline">Tuple</strong> type from <strong class="source-inline">typing</strong>:<p class="source-code">from typing import Tuple</p></li>
				<li>Define the class constructor by initializing its properties:<p class="source-code">class Environment:</p><p class="source-code">    def __init__(self):</p><p class="source-code">        """</p><p class="source-code">        Constructor of the Environment class.</p><p class="source-code">        """</p><p class="source-code">        self._initial_state = 1</p><p class="source-code">        self._allowed_actions = [0, 1]  # 0: A, 1: B</p><p class="source-code">        self._states = [1, 2, 3]</p><p class="source-code">        self._current_state = self._initial_state</p><p class="callout-heading">Note</p><p class="callout">The triple-quotes ( <strong class="source-inline">"""</strong> ) shown in the code snippet above are used to denote the start and end points of a multi-line code comment. Comments are added into code to help explain specific bits of logic. </p><p>We have two allowed actions, the action 0 and the action 1 representing the actions A and B. We have three environment states: 1, 2, and 3. We define the <strong class="source-inline">current_state</strong> variable to be equal to the initial state (state 1).</p></li>
				<li>Define the step function, which is responsible for updating the current state based on the previous state and the action taken by the agent:<p class="source-code">    def step(self, action: int) -&gt; Tuple[int, int]:</p><p class="source-code">        """</p><p class="source-code">        Step function: compute the one-step dynamic from the \</p><p class="source-code">        given action.</p><p class="source-code">        Args:</p><p class="source-code">            action (int): the action taken by the agent.</p><p class="source-code">        Returns:</p><p class="source-code">            The tuple current_state, reward.</p><p class="source-code">        """</p><p class="source-code">        # check if the action is allowed</p><p class="source-code">        if action not in self._allowed_actions:</p><p class="source-code">            raise ValueError("Action is not allowed")</p><p class="source-code">        reward = 0</p><p class="source-code">        if action == 0 and self._current_state == 1:</p><p class="source-code">            self._current_state = 2</p><p class="source-code">            reward = 1</p><p class="source-code">        elif action == 1 and self._current_state == 1:</p><p class="source-code">            self._current_state = 3</p><p class="source-code">            reward = 10</p><p class="source-code">        elif action == 0 and self._current_state == 2:</p><p class="source-code">            self._current_state = 1</p><p class="source-code">            reward = 0</p><p class="source-code">        elif action == 1 and self._current_state == 2:</p><p class="source-code">            self._current_state = 3</p><p class="source-code">            reward = 1</p><p class="source-code">        elif action == 0 and self._current_state == 3:</p><p class="source-code">            self._current_state = 2</p><p class="source-code">            reward = 0</p><p class="source-code">        elif action == 1 and self._current_state == 3:</p><p class="source-code">            self._current_state = 3</p><p class="source-code">            reward = 10</p><p class="source-code">        return self._current_state, reward</p><p class="callout-heading">Note</p><p class="callout">The <strong class="source-inline">#</strong> symbol in the code snippet above denotes a code comment. Comments are added into code to help explain specific bits of logic.</p><p>We first check that the action is allowed. Then, we define the new current state and reward based on the action and the previous state by looking at the transition in the previous figure.</p></li>
				<li>Now, we need to define the <strong class="source-inline">reset</strong> function, which simply resets the environment state:<p class="source-code">    def reset(self) -&gt; int:</p><p class="source-code">        """</p><p class="source-code">        Reset the environment starting from the initial state.</p><p class="source-code">        Returns:</p><p class="source-code">            The environment state after reset (initial state).</p><p class="source-code">        """</p><p class="source-code">        self._current_state = self._initial_state</p><p class="source-code">        return self._current_state</p></li>
				<li>We can use our environment class to understand whether our implementation is correct for the specified environment. We can do this with a simple loop, using a predefined set of actions to test the transitions of our environment. A possible action set, in this case, is <strong class="source-inline">[0, 0, 1, 1, 0, 1]</strong>. Using this set, we will test all of the environment's transitions:<p class="source-code">env = Environment()</p><p class="source-code">state = env.reset()</p><p class="source-code">actions = [0, 0, 1, 1, 0, 1]</p><p class="source-code">print(f"Initial state is {state}")</p><p class="source-code">for action in actions:</p><p class="source-code">    next_state, reward = env.step(action)</p><p class="source-code">    print(f"From state {state} to state {next_state} \</p><p class="source-code">with action {action}, reward: {reward}")</p><p class="source-code">    state = next_state</p><p class="callout-heading">Note </p><p class="callout">The code snippet shown here uses a backslash ( <strong class="source-inline">\</strong> ) to split the logic across multiple lines. When the code is executed, Python will ignore the backslash, and treat the code on the next line as a direct continuation of the current line.</p><p>The output should be as follows: </p><p class="source-code">Initial state is 1</p><p class="source-code">From state 1 to state 2 with action 0, reward: 1</p><p class="source-code">From state 2 to state 1 with action 0, reward: 0</p><p class="source-code">From state 1 to state 3 with action 1, reward: 10</p><p class="source-code">From state 3 to state 3 with action 1, reward: 10</p><p class="source-code">From state 3 to state 2 with action 0, reward: 0</p><p class="source-code">From state 2 to state 3 with action 1, reward: 1</p></li>
			</ol>
			<p>To understand this better, compare the output with <em class="italic">Figure 1.11</em> to discover whether the transitions and rewards are compatible with the selected actions.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2Arr9rO">https://packt.live/2Arr9rO</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2zpMul0">https://packt.live/2zpMul0</a>.</p>
			<p>In this exercise, we implemented a simple RL environment by defining the step function and the reset function. These functions are at the core of every environment, representing the interaction between the agent and the environment.</p>
			<h2 id="_idParaDest-36">The Agent-Environment<a id="_idTextAnchor041"/><a id="_idTextAnchor042"/><a id="_idTextAnchor043"/> Interface</h2>
			<p>RL considers sequential decision-making problems. In this context, we can refer to the agent as the "decision-maker." In sequential decision-making problems, actions taken by the decision-maker do not only influence the immediate reward and the immediate environment's state, but they also affect future rewards and states. MDPs are a natural way of formalizing sequential decision-making problems. In MDPs, an agent interacts with an environment through actions and receives rewards based on the action, on the current state of the environment, and on the environment's dynamics. The goal of the decision-maker is to maximize the cumulative sum of rewards given a horizon (which is possibly infinite). The task the agent has to learn is defined through the rewards it receives, as you can see in the following figure:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B16182_01_12.jpg" alt="Figure 1.12: The Agent-Environment interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.12: The Agent-Environment interface</p>
			<p>In RL, an episode is divided into a sequence of discrete timesteps: <img src="image/B16182_01_12a.png" alt="11"/>. Here, <img src="image/B16182_01_12b.png" alt="a"/> represents the horizon length, which is possibly infinite. The interaction between the agent and the environment happens at each timestep. At each timestep, the agent receives a representation of the current environment's state, <img src="image/B16182_01_12c.png" alt="18"/>. Based on this state, it selects an action, <img src="image/B16182_01_12d.png" alt="14"/>, belonging to the action space given the current state,<img src="image/B16182_01_12e.png" alt="15"/>. The action affects the environment. As a result, the environment changes its state, transitioning to the next state, <img src="image/B16182_01_12f.png" alt="16"/>, according to its dynamics. At the same time, the agent receives a scalar reward, <img src="image/B16182_01_12g.png" alt="17"/> quantifying how good the action taken in that state was.</p>
			<p>Let's now try to understand the mathematical notations used in the preceding example:</p>
			<ul>
				<li>Time horizon <img src="image/B16182_01_12k.png" alt="19"/>: If a task has a finite time horizon, then <img src="image/B16182_01_12k.png" alt="20"/> is an integer number representing the maximum duration of an episode. In infinite tasks, <img src="image/B16182_01_12q.png" alt="21"/> can also be <img src="image/B16182_01_12o.png" alt="22"/>.</li>
				<li>Action <img src="image/B16182_01_12r.png" alt="23"/> is the action taken by the agent in the timestep, t. The action belongs to the action space, <img src="image/B16182_01_12p.png" alt="24"/>, defined by the current state, <img src="image/B16182_01_12h.png" alt="25"/>.</li>
				<li>State <img src="image/B16182_01_12m.png" alt="26"/> is the representation of the environment's state received by the agent at time t. It belongs to the state space, <img src="image/B16182_01_12i.png" alt="27"/>, defined by the environment. It can be represented by an image, a sequence of images, or a simple vector assuming different shapes. Note that the actual environment state can be different and more complex than the state perceived by the agent.</li>
				<li>Reward <img src="image/B16182_01_12j.png" alt="s"/>  is represented by a real number, describing how good the taken action was. A high reward corresponds to a good action. The reward is fundamental for the agent to understand how to achieve a goal.</li>
			</ul>
			<p>In episodic RL, the agent-environment interaction is divided into episodes; the agent has to achieve the goal within the episode. The interaction is finalized to learn better behavior. After several episodes, the agent can decide to update its behavior by incorporating its knowledge of past interactions. Based on the effect of the action on the environment and the received rewards, the agent will perform more frequent actions yielding higher rewards. </p>
			<h3 id="_idParaDest-37"><a id="_idTextAnchor044"/>What's the Agent? What's in the Environment?</h3>
			<p>An important aspect to take into account when dealing with RL is the difference between the agent and the environment. This difference is not typically defined in terms of a physical distinction. Usually, we model the environment as everything that's not under the control of the agent. The environment can include physical laws, other agents, or an agent's properties or characteristics.</p>
			<p>However, this does not imply that the agent does not know the environment. The agent can also be aware of the environment and the effect of its actions on it, but it cannot change the way the environment reacts. Also, the reward computation belongs to the environment, as it must be entirely outside the agent's control. If this is not the case, the agent can learn how to modify the reward function in such a way as to maximize its performance without learning the task. The boundary between the agent and environment is a control boundary, meaning that the agent cannot control the reaction of the environment. It is not a knowledge boundary since the agent can know the environment model perfectly and still find difficulties in learning the task.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor045"/>Environment Types</h2>
			<p>In this section, we w<a id="_idTextAnchor046"/>ill examine some possible environment dichotomies. The characterization of the environment depends on the state space (finite or continuous), on the type of transitions (deterministic or stochastic), on the information available to the agent (fully or partially observable), and the number of agents involved in the learning problem (single versus multi-agent). </p>
			<h3 id="_idParaDest-39"><a id="_idTextAnchor047"/>Finite versus Continuous</h3>
			<p>The state space gives the first distinction. The state space can be divided into two main categories: a finite state space and a continuous state space. A finite state space has a finite number of possible states in which the agent can be, and it's the more straightforward case. An environment with a continuous state space has infinite possible states. In these types of environments, the generalization properties of the agent are fundamental to solve a task because the probability of arriving at the same state twice is almost zero. In continuous environments, an agent cannot use the experience due to the previous presence in that state; it has to generalize using some kind of similarity with respect to the previously experienced states. Note that generalization is also essential for finite state spaces with a considerable number of states (for example, when the state space is represented by the set of all possible images).</p>
			<p>Consider the following examples:</p>
			<ul>
				<li>Chess is finite. There is a finite number of possible states in which an agent can be. The state, for chess, is represented by the chessboard situation at a given time. We can calculate all the possible states by varying the situation of the chessboard. The number of states is very high but still finite.</li>
				<li>Autonomous driving can be defined as a continuous problem. If we describe the autonomous driving problem as a problem in which the agent has to make driving decisions based on the sensors' input, we obtain a continuous problem. The sensors provide continuous input in a given range. The agent state, in this case, can be represented by the agent's speed, the agent's acceleration, or the rotation of the wheels per minute.</li>
			</ul>
			<h3 id="_idParaDest-40"><a id="_idTextAnchor048"/>Deterministic versus Stochastic</h3>
			<p>A deterministic environment is an environment in which, given a state, an action is performed by the agent; the following state is uniquely determined as well as the following reward. Deterministic environments are simple types of environments, but they are also rarely used due to their limited applicability in the real world. </p>
			<p>Almost all real-world environments are stochastic. In stochastic environments, a state and an action performed by the agent determines the probability distribution over the next state and the next reward. The following state is not uniquely determined, but it's uncertain. In these types of environments, the agent should act many times to obtain a reliable estimate of its consequences. </p>
			<p>Notice that, in a deterministic environment, the agent could perform each action in each state exactly once, and based on the acquired knowledge, it can solve the task. Also, notice that solving the task does not mean taking actions that yield the highest immediate return, because this action can also bring the agent to an inconvenient part of the environment where future rewards are always low. To solve the task correctly, the agent should take actions with the highest associated future return (called a state-action value). The state-action value does not take into account only the immediate reward but also the future rewards, giving the agent a farsighted view. We will define later what a state-action value is.</p>
			<p>Consider the following examples:</p>
			<ul>
				<li>Rubik's Cube is deterministic. To a given action, it corresponds a defined state transition.</li>
				<li>Chess is deterministic but opponent-dependent. The successive state does not depend only on the agent's action but also on the opponent's action.</li>
				<li>Texas Hold'em is stochastic and opponent-dependent. The transition to the next state is stochastic and depends on the deck, which is not known by the agent. </li>
			</ul>
			<h3 id="_idParaDest-41"><a id="_idTextAnchor049"/>Fully Observable versus Partially Observable</h3>
			<p>The agent, to plan actions, has to receive a representation of the environment state, <img src="image/B16182_01_12n.png" alt="29"/> (refer to <em class="italic">Figure 1.12, The Agent-Environment interface</em>). If the state representation received by the agent completely defines the state of the environment, the environment is <strong class="bold">Fully Observable</strong>. If some parts of the environment are outside the representation observed by the agent, the environment is <strong class="bold">Partially Observable</strong>, also called the <strong class="bold">Partially Observable Markov Decision Process</strong> (<strong class="bold">POMDP</strong>). Partially observable environments are, for example, multi-agent environments. In the case of partially observable environments, the information perceived by the agents, together with the action taken, is not sufficient for determining the next state of the environment. A technique to improve the perception of the agent, making it more accurate, is to keep the history of taken actions and observations, but this requires some memory techniques (such as a <strong class="bold">Recurrent Neural Network</strong>, or <strong class="bold">RNN</strong>, or <strong class="bold">Long Short-Term Memory</strong>, or <strong class="bold">LSTM</strong>) embedded in the agent's policy.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more information on LSTMs, please refer to <a href="https://www.bioinf.jku.at/publications/older/2604.pdf">https://www.bioinf.jku.at/publications/older/2604.pdf</a>.</p>
			<h3 id="_idParaDest-42"><a id="_idTextAnchor050"/>POMDP versus MDP</h3>
			<p>Consider the following figure:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B16182_01_13.jpg" alt="Figure 1.13: A representation of a partially observable environment &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.13: A representation of a partia<a id="_idTextAnchor051"/>lly observable environment </p>
			<p>In the preceding figure, the agent does not receive the full environment state but only an observation, <img src="image/B16182_01_13a.png" alt="A close up of a logo&#10;&#10;Description automatically generated"/>. </p>
			<p>To better understand the differences between these two types of environments, let's look at <em class="italic">Figure 1.13</em>. In partially observable environments (POMDP), the representation given to the agent is only a part of the actual environment state, and it is not enough to understand the actual environment state without uncertainty.</p>
			<p>In fully observable environments (MDPs), the state representation given to the agent is semantically equivalent to the state of the environment. Notice that, in this case, the state given to the agent can assume a different form (for example, an image, a vector, a matrix, or a tensor). However, from this representation, it is always possible to reconstruct the actual state of the environment. The meaning of the state is precisely the same, even if under a different form. </p>
			<p>Consider the following examples:</p>
			<ul>
				<li>Chess (and, in general, board games) is fully observable. The agent can perceive the whole environment state. In a chess game, the environment state is represented by the chessboard, and the agent can exactly perceive the position of each pawn.</li>
				<li>Poker is partially observable. A poker agent cannot perceive the whole state of the game, which includes the opponent cards and deck cards.</li>
			</ul>
			<h3 id="_idParaDest-43"><a id="_idTextAnchor052"/>Single Agents versus Multiple Agents</h3>
			<p>Another useful characteristic of environments is the number of agents involved in a task. If there is only one agent, the subject of our study, the environment is a single-agent environment. If the number of agents is more than one, the environment is a multi-agent environment. The presence of multiple agents increases the complexity of the problem since the action that influences the state becomes a joint action, the set of all the agents' actions. Usually, agents only know their individual actions and do not know another agent's actions. For this reason, the multi-agent environment is an instance of POMDP in which the partial visibility is due to the presence of other agents. Notice that each agent has its own observation, which can differ from the other agent's observation, as shown in the following figure:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B16182_01_14.jpg" alt="Figure 1.14: A schematic representation of the multi-agent decentralized MDP&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.14: A schematic representation of the multi-agent decentralized MDP</p>
			<p>Consider the following examples:</p>
			<ul>
				<li>Robot navigation is usually a single-agent task. We may have only one agent moving in a possible unknown environment. The goal of the agent can be to reach a given position in the environment while avoiding crashes as much as possible in the minimum amount of time.</li>
				<li>Poker is a multi-agent task where we have two agents competing against each other. The perceived state is different in this case and the perceived reward is also different.</li>
			</ul>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor053"/>An Action and Its Types</h2>
			<p>The action set of an agent in an environment can be finite or continuous. If the action set is finite, the agent has at its disposal a finite number of actions. Consider the MountainCar-v0 (discrete) example, described in more detail later. This has a discrete action set; the agent only has to select the direction in which to accelerate, and the acceleration is constant.</p>
			<p>If the action set is continuous, the agent has at its disposal infinite actions from which it should select the best actions in a given state. Usually, tasks with continuous action sets are more challenging to solve than those with finite actions. </p>
			<p>Let's look at the example of MountainCar-v0:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B16182_01_15.jpg" alt="Figure 1.15: A MountainCar-v0 task&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.15: A MountainCar-v0 task</p>
			<p>As you can see in the preceding figure, a car is positioned in a valley between two mountains. The goal of the car is to arrive at the flag on the mountain to its right.</p>
			<p>The MountainCar-v0 example is a standard RL benchmark in which there is a car trying to ramp itself up a mountain. The car's engine doesn't have enough strength to ramp upward. For this reason, the car should use the inertia given from the shape of the valley, that is, it should go to the left to gain speed. The state is composed of the car velocity, acceleration, and <em class="italic">x</em> position. There are two versions of this task based on the action set we define, as follows:</p>
			<ul>
				<li><strong class="bold">MountainCar-v0 discrete</strong>: We have only two possible actions, (-1, +1) or (0, 1), depending on the parameterization.</li>
				<li><strong class="bold">MountainCar-v0 continuous</strong>: A continuous set of actions from -1 to +1.</li>
			</ul>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor054"/>Policy</h2>
			<p>We define the policy as the behavior <a id="_idTextAnchor055"/>of the agent. Formally, a policy is a function that takes as input the history of the current episode and outputs the current action. The concept of policies has huge importance in RL; all RL algorithms focus on learning the best policy for a given task.</p>
			<p>An example of a winning policy for the MountainCar-v0 task is a policy that brings the agent up on the left mountain and then uses the cumulated potential to ramp up the mountain on the right. For negative velocities, the optimal action is LEFT, as the agent should go as high as possible on the left mountain. For positive velocities, the agent should take the action RIGHT, as its goal is to ramp up the mountain on its right. </p>
			<p>A Markovian policy is simply a policy depending only on the current state and not the whole history.</p>
			<p>We denote a stationary Markovian policy with <img src="image/B16182_01_15a.png" alt="pi"/> as follows:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B16182_01_16.jpg" alt="Figure 1.16: Stationary Markovian policy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.16: Stationary Markovian policy</p>
			<p>The Markovian policy goes from the state space to the action space. If we evaluate the policy in a given state, <img src="image/B16182_01_16b.png" alt="33"/>, we obtain the selected action, <img src="image/B16182_01_16a.png" alt="a"/>, in that state:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B16182_01_17.jpg" alt="Figure 1.17: Stationary Markovian policy in state St&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.17: Stationary Markovian policy in state <img src="image/B16182_01_17b.png" alt="34"/> </p>
			<p>A policy can be implemented in different ways. The most straightforward policy is just a rule-based policy, which is essentially a set of rules or heuristics.</p>
			<p>Policies that are a subject of interest in RL are usually parametric. Parametric policies are (differentiable) functions depending on a set of parameters. Usually, the policy parameters are identified as <img src="image/B16182_01_17a.png" alt="A picture containing object, clock&#10;&#10;Description automatically generated"/>:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B16182_01_18.jpg" alt="Figure 1.18: Parametric policies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.18: Parametric policies</p>
			<p>The set of policy parameters can be represented by a vector in a <em class="italic">d</em>-dimensional space. The selected action is determined by the policy structure (we will explore some possible policy structures later on), by the policy parameters, and, of course, by the current environment state. </p>
			<h3 id="_idParaDest-46"><a id="_idTextAnchor056"/>Stochastic Policies</h3>
			<p>The policies presented so far ar<a id="_idTextAnchor057"/>e merely deterministic policies because the output is precisely an action. Stochastic policies are policies that output a distribution over the action space. Stochastic policies are usually powerful policies that mix both exploration and exploitation. With stochastic policies, it is possible to obtain complex behaviors.</p>
			<p>A stochastic policy assigns a certain probability to each action. The actions will be selected according to the associated probability.</p>
			<p><em class="italic">Figure 1.19</em> explains, graphically, and with an example, the differences between a stochastic policy and a deterministic policy. The policy in the figure has three possible actions.</p>
			<p>The stochastic policy (upper part) assigns to actions, respectively, a probability of 0.2, 0.7, and 0.1. The most probable action is the second action, which is associated with the highest probability. However, all of the actions could also be selected. </p>
			<p>In the bottom part, we have the same set of actions with a deterministic policy. The policy, in this case, selects only one action (the second in the figure) with a probability of 1. In this case, actions 1 and 3 will not be selected, having an associated probability of 0.</p>
			<p>Note that we can obtain a deterministic policy from a stochastic one by taking the action associated with the highest probability:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B16182_01_19.jpg" alt="Figure 1.19: Stochastic versus deterministic policies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.19: Stochastic versus deterministic polici<a id="_idTextAnchor058"/>es<a id="_idTextAnchor059"/></p>
			<h3 id="_idParaDest-47"><a id="_idTextAnchor060"/>Policy Parameterizations</h3>
			<p>In this section, we will analyze some possible policy parameterizations. Parameterizing a policy means giving a structure to the policy function and considering how parameters affect our output actions. Based on the parameterization, it is possible to obtain simple policies or even complex stochastic policies starting from the same input state.</p>
			<p><strong class="bold">Linear (Deterministic)</strong></p>
			<p>The resulting action is a line<a id="_idTextAnchor061"/>ar combination of the state features, <img src="image/B16182_01_20a.png" alt="A picture containing drawing, animal&#10;&#10;Description automatically generated"/>:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B16182_01_20.jpg" alt="Figure 1.20: An expression of a linear policy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.20: An expression of a linear policy</p>
			<p>A linear policy is a very simple policy represented by a matrix multiplication.</p>
			<p>Consider the example of MountainCar-v0. The state space is represented by the position, speed, and acceleration: <img src="image/B16182_01_20b.png" alt="A close up of a sign&#10;&#10;Description automatically generated"/>. We usually add a constant, 1, that corresponds to the bias term. Therefore, <img src="image/B16182_01_20c.png" alt="A close up of a sign&#10;&#10;Description automatically generated"/> . Policy parameters are defined by <img src="image/B16182_01_20d.png" alt="A picture containing object, clock&#10;&#10;Description automatically generated"/> . We can simply use as state features the identity function, <img src="image/B16182_01_20e.png" alt="40"/>.</p>
			<p>The resulting policy is as follows:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B16182_01_21.jpg" alt="Figure 1.21: A linear policy for MountainCar-v0 &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.21: A linear policy for MountainCar-v0 </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Using a comma, <strong class="source-inline">,</strong>, we can denote the column separator, and with a semicolon, <strong class="source-inline">;</strong>, we can denote the row separator. </p>
			<p class="callout">Therefore, <img src="image/B16182_01_21a.png" alt="41"/> is a row vector, and <img src="image/B16182_01_21b.png" alt="42"/> is a column vector that is equivalent to <img src="image/B16182_01_21c.png" alt="43"/>.</p>
			<p>If the environment state is [1, 2, 0.1], the cart is in position <img src="image/B16182_01_21d.png" alt="b"/> with velocity <img src="image/B16182_01_21e.png" alt="c"/> and acceleration <img src="image/B16182_01_21f.png" alt="A picture containing drawing, clock&#10;&#10;Description automatically generated"/>, and the policy parameters are defined by [4, 5, 1, 1], we obtain an action, <img src="image/B16182_01_21g.png" alt="e"/>. </p>
			<p>Since the action space of MountainCar-v0 is defined in the interval, [-1, +1], we need to squash the resulting action using a squashing function such as <img src="image/B16182_01_21h.png" alt="f"/> (hyperbolic tangent). In our case, <img src="image/B16182_01_21h.png" alt="g"/> applied to the output of the multiplication results in approximately +1:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B16182_01_22.jpg" alt="Figure 1.22: A hyperbolic tangent plot; the hyperbolic tangent squashes &#13;&#10;the real numbers in the interval, [-1, +1]&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.22: A hyperbolic tangent plot; the hyperbolic tangent squashes the real numbers in the interval, [-1, +1]</p>
			<p>Even if linear policies are simple, they are usually enough to solve most tasks, given that the state features represent the problem.</p>
			<p><strong class="bold">Gaussian Policy</strong></p>
			<p>In the case of Gaussian parameterization, the resultin<a id="_idTextAnchor062"/>g action has a Gaussian distribution in which the mean, <img src="image/B16182_01_22a.png" alt="49"/>, and the variance, <img src="image/B16182_01_22b.png" alt="A drawing of a person&#10;&#10;Description automatically generated"/>, depend on state features:</p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B16182_01_23.jpg" alt="Figure 1.23: Expression for a Gaussian policy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.23: Expression for a Gaussian policy</p>
			<p>Here, with the symbol <img src="image/B16182_01_23a.png" alt="c"/>, we denote the conditional distribution; therefore, with <img src="image/B16182_01_23b.png" alt="a"/>, we denote the distribution conditioned on state <img src="image/B16182_01_23c.png" alt="b"/>.</p>
			<p>Remember, the functional form of the Gaussian distribution, <img src="image/B16182_01_23d.png" alt="A picture containing drawing&#10;&#10;Description automatically generated"/>, is as follows:</p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B16182_01_24.jpg" alt="Figure 1.24: A Gaussian distribution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.24: A Gaussian distribution</p>
			<p>In the case of a Gaussian policy, this becomes the following:</p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B16182_01_25.jpg" alt="Figure 1.25: A Gaussian policy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.25: A Gaussian policy</p>
			<p>Gaussian parameterization is useful for continuous action spaces. Note that we are giving the agent the possibility of also changing the variance of the distribution. This means that it can decide to increase the variance, enabling it to explore scenarios where it's not sure what the best action to take is, or it can reduce the variance by increasing the amount of exploitation when it's very sure about which action to take in a given state. The effect of the variance can be visualized as follows:</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B16182_01_26.jpg" alt="Figure 1.26: The effect of the variance on a Gaussian policy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.26: The effect of the variance on a Gaussian policy</p>
			<p>In the preceding figure, if the variance increases (the lower curve), the policy becomes more exploratory. Additionally, actions that are very far from the mean have nonzero probabilities. When the variance is small (the higher curve), the policy is highly exploitative. This means that only actions that are very close to the mean have nonzero probabilities.</p>
			<p>In the preceding diagram, the smaller Gaussian represents a highly explorative policy with respect to the larger policy. Here, we can see the effect of the variance on the policy exploration attitude.</p>
			<p>While learning a task, in the first training episodes, the policy needs to have a high variance in order for it to explore different actions. The variance will be reduced once the agent gains some experience and becomes more and more confident about the best actions.</p>
			<p><strong class="bold">The Boltzmann Policy</strong></p>
			<p>Boltzmann parameterization is used for discrete action spac<a id="_idTextAnchor063"/>es. The resulting action is a softmax function acting on the weighted state features, as stated in the following expression:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B16182_01_27.jpg" alt="Figure 1.27: Expression for a Boltzmann policy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.27: Expression for a Boltzmann policy</p>
			<p>Here, <img src="image/B16182_01_27a.png" alt="55"/> is the set of parameters associated with action <img src="image/B16182_01_27b.png" alt="c"/>.</p>
			<p>The Boltzmann policy is a stochastic policy. The motivation behind this is very simple; let's sum the policy over all the actions (the denominator does not depend on the action, <img src="image/B16182_01_27c.png" alt="d"/>), as follows:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B16182_01_28.jpg" alt="Figure 1.28: A Boltzmann policy over all of the actions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.28: A Boltzmann policy over all of the actions</p>
			<p>The Boltzmann policy becomes deterministic if we select the action with the highest probability, which is equivalent to selecting the mean action in a Gaussian distribution. What the Boltzmann parameterization represents is simply a normalization of the value, <img src="image/B16182_01_28a.png" alt="59"/>, corresponding to the score of action <img src="image/B16182_01_27d.png" alt="e"/>. The score is thus normalized by considering the value of all the other actions obtaining a distribution.</p>
			<p>In all of these parametrizations, the state features might be non-linear features depending on several parameters, for example, whether it is coming from a neural network, the <strong class="bold">radial basis function (RBF) </strong>features, or the tile coding features.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor064"/>Exercise 1.02: Implementing a Linear Policy</h2>
			<p>In this exercise, we will practice with the implementation of a linear policy. The goal is to write the presented parameterizations in the case of a state composed of <img src="image/B16182_01_28b.png" alt="n"/> components. In the first case, the features can be represented by the identity function; in the second case, the features are represented by a polynomial function of order 2: </p>
			<ol>
				<li value="1">Open a new Jupyter notebook and import NumPy to implement all of the requested policies: <p class="source-code">from typing import Callable, List</p><p class="source-code">import matplotlib</p><p class="source-code">from matplotlib import pyplot as plt</p><p class="source-code">import numpy as np</p><p class="source-code">import scipy.stats</p></li>
				<li>Let's now implement the linear policy. A linear policy can be efficiently represented by a dot product between the policy parameters and state features. The first step is to write the constructor:<p class="source-code">class LinearPolicy:</p><p class="source-code">    def __init__(</p><p class="source-code">        self, parameters: np.ndarray, \</p><p class="source-code">        fe<a id="_idTextAnchor065"/>atures: Callable[[np.ndarray], np.ndarray]):</p><p class="source-code">        """</p><p class="source-code">        Linear Policy Constructor.</p><p class="source-code">        Args:</p><p class="source-code">            parameters (np.ndarray): policy parameters </p><p class="source-code">            as np.ndarray.</p><p class="source-code">            features (Callable[[np.ndarray], np.ndarray]): </p><p class="source-code">            function used to extract features from the </p><p class="source-code">            state representation.</p><p class="source-code">        """</p><p class="source-code">        self._parameters = parameters</p><p class="source-code">        self._features = features</p><p>The constructor simply sets the attribute's parameters and features. The feature parameter is actually a callable that takes, as input, a NumPy array and returns another NumPy array. The input is the environment state, whereas the output is the state features. </p></li>
				<li>Next, we will implement the call method. The <strong class="source-inline">__call__</strong> method takes as input the state, and returns the selected action according to the policy parameters. The call represents a real policy implementation. What we have to do in the linear case is to first apply the feature function and then compute the dot product between the parameters and the features. A possible implementation of the call function is as follows:<p class="source-code">    def __call__(self, state: np.ndarray) -&gt; np.ndarray:</p><p class="source-code">        """</p><p class="source-code">        Call method of the Policy.</p><p class="source-code">        Args:</p><p class="source-code">            state (np.ndarray): environment state.</p><p class="source-code">        Returns:</p><p class="source-code">            The resulting action.</p><p class="source-code">        """</p><p class="source-code">        # calculate state features</p><p class="source-code">        state_features = self._features(state)</p><p class="source-code">        """</p><p class="source-code">        the parameters shape [0] should be the same as the </p><p class="source-code">        state features as they must be multiplied</p><p class="source-code">        """</p><p class="source-code">        assert state_features.shape[0] == self._parameters.shape[0]</p><p class="source-code">        # dot product between parameters and state features</p><p class="source-code">        return np.dot(self._parameters.T, state_features)</p></li>
				<li>Let's try the defined policy with a state composed of a 5-dimensional array. Sample a random set of parameters and a random state vector. Create the policy object. The constructor needs the callable features, which, in this case, is the identity function. Call the policy to obtain the resulting action:<p class="source-code"># sample a random set of parameters</p><p class="source-code">parameters = np.random.rand(5, 1)</p><p class="source-code"># define the state features as identity function</p><p class="source-code">features = lambda x: x</p><p class="source-code"># define the policy</p><p class="source-code">pi: LinearPolicy = LinearPolicy(parameters, features)</p><p class="source-code"># sample a state</p><p class="source-code">state = np.random.rand(5, 1)</p><p class="source-code"># Call the policy obtaining the action</p><p class="source-code">action = pi(state)</p><p class="source-code">print(action)</p><p>The output will be as follows:</p><p class="source-code">[[1.33244481]]</p></li>
			</ol>
			<p>This value is the action selected by our agent, given the state and the policy parameters. In this case, the selected action is <strong class="source-inline">[[1.33244481]]</strong>. The meaning of the action depends on the RL task.</p>
			<p>Of course, you will obtain different results based on the sampled parameters and sampled state. It is always possible to seed the NumPy random number generator to obtain reproducible results.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2Yvrku7">https://packt.live/2Yvrku7</a>. You can also refer to the Gaussian and Boltzmann policies that are implemented in the same notebook.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3dXc4Nc">https://packt.live/3dXc4Nc</a>.</p>
			<p>In this exercise, we practiced with different policies and parameterizations. These are simple policies, but they are the building blocks of more complex policies. The trick is just to substitute the state features with a neural network or any other feature extractor.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor066"/>Goals and Rewards</h2>
			<p>In RL, the agent's goal is to maximize the total amount of reward it receives during an episode.</p>
			<p>This is based on the famous reward hypothesis in <em class="italic">Sutton &amp; Barto 1998</em>:</p>
			<p><em class="italic">"That all of what we mean by goals and purposes can be well thought of as the maximization of the expected value of the cumulative sum of a received scalar signal (called reward)."</em></p>
			<p>The important thing here is that the reward should not describe how to achieve the goal; instead, it should describe the goal of the agent. The reward function is an element of the environment, but it can also be designed for a specific task. In principle, there are infinite reward functions for each task. Usually, reward functions that are characterized by a lot of information help the agent to learn. Sparse reward functions (with no information) makes learning difficult or, sometimes, impossible. Sparse reward functions are functions in which, most of the time, the reward is constant (or zero). </p>
			<p>Sutton's hypothesis, which we explained earlier, is the basis of the RL framework. This hypothesis may be wrong; probably, a scalar reward signal (and its maximization) is not enough to define complex goals; however, still, this hypothesis is very flexible, simple, and it can be applied to a wide range of tasks. At the time of writing, the reward function design is more art than engineering; there are no formal practices regarding how to write a reward function, rather there are only best practices based on experience. Usually, a simple reward function works very well. Usually, we associate a positive value with good actions and behavior and negative values with bad actions or actions that are not important at that particular moment. </p>
			<p>In a locomotion task (for example, teaching a robot how to move), the reward may be defined as proportional to the robot's forward movement. In chess, the reward may be defined as 0 for each timestep: +1 if the agent wins and -1 if the agent loses. If we want our agent to solve Rubik's Cube, the reward may be defined similarly: 0 every step and +1 if the cube is solved.</p>
			<p>Sometimes, as we learned earlier, defining a scalar reward function for a task is not easy, and, nowadays, it is more art than engineering or science. </p>
			<p>In each of these tasks, the final objective is to learn a policy, a way of selecting actions, maximizing the total rewards received by the agent. Tasks can be episodic or continuous. Episodic tasks have a finite length, that is, a finite number of timesteps (for example, T is finite). Continuous tasks can last forever or until the agent reaches its goal. In the first case, we can simply define the total reward (<strong class="bold">return</strong>) received by an agent as the sum of the individual rewards:</p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B16182_01_29.jpg" alt="Figure 1.29: Expression for a total reward&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.29: Expression for a total reward</p>
			<p>Usually, we are interested in the return from a certain timestep, <img src="image/B16182_01_29a.png" alt="61"/>. In other words, the return, <img src="image/B16182_01_29b.png" alt="62"/> , quantifies the agent's performance in the long term, and it can be calculated as the sum of immediate rewards following time t until the end of the episode (timestep <img src="image/B16182_01_12b.png" alt="d"/>):</p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B16182_01_30.jpg" alt="Figure 1.30: Expression for a return from timestep t&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.30: Expression for a return from timestep t</p>
			<p>It is straightforward to see that, with this formulation, the return for continuing tasks diverges to infinity.</p>
			<p>In order to deal with continuing tasks, we need to introduce the notion of a discounted return. This concept formalizes, in mathematical terms, the principle that the immediate reward (sometimes) is more valuable than the same amount of reward after many steps. This principle is widely known in economics. The discount factor, <img src="image/B16182_01_30a.png" alt="64"/>, quantifies the present value of future rewards. We are ready to present the unified notation for the return in episodic and continuing tasks.</p>
			<p>The discounted return is the cumulative, discounted sum of rewards until the end of the episode. In mathematical terms, it can be formalized as follows:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B16182_01_31.jpg" alt="Figure 1.31: Expression for the discounted return from timestep t&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.31: Expression for the discounted return from timestep t</p>
			<p>To understand how the discount affects the return, it is possible to see that the value of receiving reward <img src="image/B16182_01_31a.png" alt="e"/> after a <img src="image/B16182_01_31b.png" alt="66"/> timestep is <img src="image/B16182_01_31c.png" alt="67"/>, since <img src="image/B16182_01_31g.png" alt="68"/> is less than or equal to <img src="image/B16182_01_31f.png" alt="69"/>. It is worth introducing the effect of the discount on the return. If <img src="image/B16182_01_31d.png" alt="A picture containing object, clock&#10;&#10;Description automatically generated"/>, the return, even if composed by an infinite sum, has a bounded value. If <img src="image/B16182_01_31e.png" alt="70"/>, the agent is myopic since it cares only about the immediate reward, and it does not care about future rewards. A myopic agent can cause problems: the only thing it learns is to select the action yielding the highest immediate return. A myopic chess player can, for example, eat the opponent's pawn causing the game's loss. Notice that, for some tasks, this isn't always a problem. This includes tasks in which the current action does not affect the future reward and has no consequences for the agent's future. These tasks can be solved by finding the action that causes a higher immediate reward for each state independently. Most of the time, the current action influences the future of the agent and its rewards. If the discount factor is near to 1, the agent is farsighted; it is possible for them to sacrifice an action yielding to a good immediate reward now for a higher reward in future steps.</p>
			<p>It is important to understand the relationship between returns at different timesteps, both from a theoretical point of view but also from an algorithmic point of view, because many RL algorithms are based on this principle: </p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B16182_01_32.jpg" alt="Figure 1.32: Relationship between returns at different timesteps&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.32: Relationship between returns at different timesteps</p>
			<p>By following these simple steps, we can see that the return from the timestep equals the immediate reward plus the return at the following step scaled by gamma. This simple relationship will be extensively used in RL algorithms. </p>
			<h3 id="_idParaDest-50"><a id="_idTextAnchor067"/>Why Discount?</h3>
			<p>The following describes the motivations as to why many RL problems are discounted:</p>
			<ul>
				<li>It is convenient from a mathematical perspective to have a bounded return, and also in the case of continuing tasks.</li>
				<li>If the task is a financial task, immediate rewards may gain more interest than delayed rewards.</li>
				<li>Animal and human behavior show a preference for immediate rewards.</li>
				<li>A discounted reward may also represent uncertainty about the future.</li>
				<li>It is also possible to use an undiscounted return <img src="image/B16182_01_32a.png" alt="d"/> if all of the episodes terminate after a finite number of steps.</li>
			</ul>
			<p>This section introduced the main elements of RL, including agents, actions, environments, transition functions, and policies. In the next section, we will practice with these concepts by defining agents, environments, and measuring the performance of agents on some tasks. </p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor068"/>Reinforcement Learning Frameworks</h1>
			<p>In the previous sections, we learned the basic theory behind RL. In principle, an agent or an environment can be implemented in any way or any language. For RL, the primary language used by both academic and industrial people is Python, as it allows you to focus on the algorithms and not on the language details, making it very simple to use. Implementing, from scratch, an algorithm or a complex environment (that is, an autonomous driving environment) might be very difficult and error-prone. For this reason, several well-established and well-tested libraries make RL very easy for newcomers. In this section, we will explore the main Python RL libraries. We will present OpenAI Gym, a set of environments that is ready to use and easy to modify, and OpenAI Baselines, a set of high quality, state-of-the-art algorithms. By the end of this chapter, you will have learned about and practiced with environments and agents.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor069"/>OpenAI Gym</h2>
			<p>OpenAI Gym (<a href="https://gym.openai.com">https://gym.openai.com</a>) is a Python library that provides a set of RL environments ranging from toy environments to Atari environments and more complex environments, such as <strong class="bold">MuJoCo</strong> and <strong class="bold">Robotics</strong> environments. OpenAI Gym, besides providing this large set of tasks, also provides a unified interface for interacting with RL tasks and a set of interfaces that are useful for describing the environment's characteristics, such as the action space and the state space. An important property of Gym is that its only focus is on environments; it makes no assumption of the type of agent you have or the computational framework you use. We will not cover the installation details in this chapter for ease of presentation. Instead, we will focus on the main concepts and learn how to interact with these libraries. </p>
			<h3 id="_idParaDest-53"><a id="_idTextAnchor070"/>Getting Started with Gym – CartPole</h3>
			<p>CartPole is a classical control environment provided by Gym and used<a id="_idTextAnchor071"/><a id="_idTextAnchor072"/> by researchers as a starting point of algorithms. It consists of a cart that moves along the horizontal axis (1-dimensional) and a pole anchored to the cart on one endpoint:</p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B16182_01_33.jpg" alt="Figure 1.33: CartPole environment representation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.33: CartPole environment representation</p>
			<p>The agent has to learn how to move the cart to balance the pole (that is, to stop the pole from falling). The episode ends when the pole angle (<img src="image/B16182_01_33a.png" alt="71"/>) becomes higher than a certain threshold (<img src="image/B16182_01_33b.png" alt="72"/>). The state space is represented by the position of the cart along the axis, <img src="image/B16182_01_33c.png" alt="73"/>; the velocity along the axis, <img src="image/B16182_01_33d.png" alt="74"/>; the pole angle, <img src="image/B16182_01_33e.png" alt="75"/>; and the pole angular velocity, <img src="image/B16182_01_33f.png" alt="76"/>. The state space is continuous in this case, but it can also be discretized to make learning simpler. </p>
			<p>In the following steps, we will practice with Gym and its environments.</p>
			<p>Let's create a CartPole environment using Gym and analyze its properties in a Jupyter notebook. Please refer to the <em class="italic">Preface</em> for Gym installation instructions:</p>
			<p class="source-code"># Import the gym Library</p>
			<p class="source-code">import gym</p>
			<p class="source-code"># Create the environment using gym.make(env_name)</p>
			<p class="source-code">env = gym.make('CartPole-v1')</p>
			<p class="source-code">"""</p>
			<p class="source-code">Analyze the action space of cart pole using the property action_space</p>
			<p class="source-code">"""</p>
			<p class="source-code">print("Action Space:", env.action_space)</p>
			<p class="source-code">"""</p>
			<p class="source-code">Analyze the observation space of cartpole using the property observation_space</p>
			<p class="source-code">"""</p>
			<p class="source-code">print("Observation Space:", env.observation_space)</p>
			<p>If you run these lines, you will get the following output:</p>
			<p class="source-code">Action Space: Discrete(2)</p>
			<p class="source-code">Observation Space: Box(4,)</p>
			<p><strong class="source-inline">Discrete(2)</strong> means that the action space of CartPole is a discrete action space composed of two actions: Go Left and Go Right. These actions are the only actions available to the agent. The action of Go Left, in this case, is represented by action 0, and the action of Go Right by action 1.</p>
			<p><strong class="source-inline">Box(4,)</strong> means that the state space (the observation space) of the environment is represented by a 4-dimensional box, a subspace of <img src="image/B16182_01_33g.png" alt="d"/>. Formally, it is a Cartesian product of <strong class="source-inline">n</strong> intervals. The state space has a lower bound and an upper bound. The bounds may also be infinite, creating an unbounded box.</p>
			<p>To inspect the observation space better, we can use the properties of <strong class="source-inline">high</strong> and <strong class="source-inline">low</strong>:</p>
			<p class="source-code"># Analyze the bounds of the observation space</p>
			<p class="source-code">print("Lower bound of the Observation Space:", \</p>
			<p class="source-code">      env.observation_space.low)</p>
			<p class="source-code">print("Upper bound of the Observation Space:", \</p>
			<p class="source-code">      env.observation_space.high)</p>
			<p>This will print the following:</p>
			<p class="source-code">Lower bound of the Observation Space: [-4.8000002e+00 -3.4028235e+38 </p>
			<p class="source-code">-4.1887903e-01 -3.4028235e+38]</p>
			<p class="source-code">Upper bound of the Observation Space: [4.8000002e+00 3.4028235e+38 </p>
			<p class="source-code">4.1887903e-01 3.4028235e+38]</p>
			<p>Here, we can see that upper and lower bounds are arrays of 4 elements; one element for each state dimension. The following are some observations:</p>
			<ul>
				<li>The lower bound of the cart position (the first state dimension) is -4.8, while the upper bound is 4.8. </li>
				<li>The lower bound of the velocity (the second state dimension) is -3.10<span class="superscript">38</span>, basically  <img src="image/B16182_01_33n.png" alt="77"/>; and the upper bound is +3.10<span class="superscript">38</span>, basically <img src="image/B16182_01_33m.png" alt="78"/>.</li>
				<li>The lower bound of the pole angle (the third state dimension) is -0.4 radians, representing an angle of -24 degrees. The upper bound is 0.4 radians, representing an angle of +24 degrees.</li>
				<li>The lower and upper bounds of the pole angular velocity (the fourth state dimension) are, respectively, <img src="image/B16182_01_33p.png" alt="79"/> and <img src="image/B16182_01_33m.png" alt="80"/> , similar to the lower and upper bounds for the cart policy's angular velocity.</li>
			</ul>
			<h3 id="_idParaDest-54"><a id="_idTextAnchor073"/>Gym Spaces</h3>
			<p>The Gym <strong class="source-inline">Space</strong> class represents the way Gym describes actions and state spaces. The most used spaces are the <strong class="source-inline">Discrete</strong> and <strong class="source-inline">Box</strong> spaces.</p>
			<p>A discrete space is composed of a fixed number of elements. It can represent both a state space but also an action space, and it describes the number of elements through the <strong class="source-inline">n</strong> attribute. Its elements range from 0 to <strong class="source-inline">n-1</strong>.</p>
			<p>A <strong class="source-inline">Box</strong> space describes its shape through the <strong class="source-inline">shape</strong> attribute. It can have an n-dimensional shape that corresponds to an <strong class="source-inline">n</strong>-dimensional box. A <strong class="source-inline">Box</strong> space can also be unbounded. Each interval has the form of one of <img src="image/B16182_01_33h.png" alt="81"/>.</p>
			<p>It is possible to sample from the action space to gain insight into the elements it is composed of using the <strong class="source-inline">space.sample()</strong> method.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For the sampling distribution of box environments, to create a sample of the box, each coordinate is sampled according to the form of the interval in the following distributions:</p>
			<p class="callout">- <img src="image/B16182_01_33i.png" alt="82"/> : A uniform distribution</p>
			<p class="callout">-<img src="image/B16182_01_33j.png" alt="83"/>: A shifted exponential distribution</p>
			<p class="callout">- <img src="image/B16182_01_33k.png" alt="84"/>: A shifted negative exponential distribution</p>
			<p class="callout">- <img src="image/B16182_01_33l.png" alt="85"/>: A normal distribution</p>
			<p>Let's now demonstrate how to create simple spaces and how to sample from spaces:</p>
			<p class="source-code"># Type hinting</p>
			<p class="source-code">from typing import Tuple</p>
			<p class="source-code">import gym</p>
			<p class="source-code"># Import the spaces module</p>
			<p class="source-code">from gym import spaces</p>
			<p class="source-code"># Create a discrete space composed by N-elements (5)</p>
			<p class="source-code">n: int = 5</p>
			<p class="source-code">discrete_space = spaces.Discrete(n=n)</p>
			<p class="source-code"># Sample from the space using .sample method</p>
			<p class="source-code">print("Discrete Space Sample:", discrete_space.sample())</p>
			<p class="source-code">"""</p>
			<p class="source-code">Create a Box space with a shape of (4, 4)</p>
			<p class="source-code">Upper and lower Bound are 0 and 1</p>
			<p class="source-code">"""</p>
			<p class="source-code">box_shape: Tuple[int, int] = (4, 4)</p>
			<p class="source-code">box_space = spaces.Box(low=0, high=1, shape=box_shape)</p>
			<p class="source-code"># Sample from the space using .sample method</p>
			<p class="source-code">print("Box Space Sample:", box_space.sample())</p>
			<p>This will print the samples from our spaces:</p>
			<p class="source-code">Discrete Space Sample: 4</p>
			<p class="source-code">Box Space Sample: [[0.09071387 0.4223234  0.09272052 0.15551752]</p>
			<p class="source-code"> [0.8507258  0.28962377 0.98583364 0.55963445]</p>
			<p class="source-code"> [0.4308358  0.8658449  0.6882108  0.9076272 ]</p>
			<p class="source-code"> [0.9877584  0.7523759  0.96407163 0.630859  ]]</p>
			<p>Of course, the samples will change according to your seeds.</p>
			<p>As you can see, we have sampled element 4 from our discrete space composed of 5 elements (from 0 to 4). We sampled a random 4 x 4 matrix with elements between 0 and 1, the lower and the upper bound of our space.</p>
			<p>To obtain reproducible results, it is also possible to set the seed of an environment using the <strong class="source-inline">seed</strong> method:</p>
			<p class="source-code"># Seed spaces to obtain reproducible samples</p>
			<p class="source-code">discrete_space.seed(0)</p>
			<p class="source-code">box_space.seed(0)</p>
			<p class="source-code"># Sample from the seeded space</p>
			<p class="source-code">print("Discrete Space (seed=0) Sample:", discrete_space.sample())</p>
			<p class="source-code"># Sample from the seeded space</p>
			<p class="source-code">print("Box Space (seed=0) Sample:", box_space.sample())</p>
			<p>This will print the following:</p>
			<p class="source-code">Discrete Space (seed=0) Sample: 0</p>
			<p class="source-code">Box Space (seed=0) Sample: [[0.05436005 0.9653909  </p>
			<p class="source-code">0.63269097 0.29001734]</p>
			<p class="source-code"> [0.10248426 0.67307633 0.39257675 0.66984606]</p>
			<p class="source-code"> [0.05983897 0.52698725 0.04029069 0.9779441 ]</p>
			<p class="source-code"> 0.46293673 0.6296479  0.9470484  0.6992778 ]]</p>
			<p>The previous statement will always print the same sample since we set the seed to 0. Seeding an environment is very important in order to guarantee reproducible results.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor074"/>Exercise 1.03: Creating a Space for Image Observations</h2>
			<p>In this exercise, we will create a space to represent an image observation. Image-based observations are essential in RL since they allow the agent to learn from pixels and require minimal feature engineering or need to go through the feature extraction phase. The agent can focus on what is important for its task without being limited by manually decided heuristics. We will create a space representing RGB images with dimensions equal to 256 x 256:</p>
			<ol>
				<li value="1">Open a new Jupyter notebook and import the desired modules – <strong class="source-inline">gym</strong> and NumPy:<p class="source-code">import gym</p><p class="source-code">from gym import spaces</p><p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">%matplotlib inline</p><p class="source-code">import numpy as np # used for the dtype of the space</p></li>
				<li>We are dealing with 256 x 256 RGB images, so the space has a shape of (256, 256, 3). In addition, the images range from 0 to 255 (if we consider the <strong class="source-inline">uint8</strong> images):<p class="source-code">"""</p><p class="source-code">since the Space is RGB images with shape 256x256 the final shape is (256, 256, 3)</p><p class="source-code">"""</p><p class="source-code">shape = (256, 256, 3)</p><p class="source-code"># If we consider uint8 images the bounds are 0-255</p><p class="source-code">low = 0</p><p class="source-code">high = 255</p><p class="source-code"># Space type: unsigned int</p><p class="source-code">dtype = np.uint8</p></li>
				<li>We are now ready to create the space. An image is a <strong class="source-inline">Box</strong> space since it has defined bounds:<p class="source-code"># create the space</p><p class="source-code">space = spaces.Box(low=low, high=high, shape=shape, dtype=dtype)</p><p class="source-code"># Print space representation</p><p class="source-code">print("Space", space)</p><p>This will print the representation of our space: </p><p class="source-code">Space Box(256, 256, 3)</p><p>The first dimension is the image width, the second dimension is the image height, and the third dimension is the number of channels.</p></li>
				<li>Here is a sample from the space:<p class="source-code"># Sample from the space</p><p class="source-code">sample = space.sample()</p><p class="source-code">print("Space Sample", sample)</p><p>This will return the space sample; in this case, it is a huge tensor of 256 x 256 x 3 unsigned integers (between 0 and 255). The output (fewer lines are presented now) should be similar to the following:</p><p class="source-code">Space Sample [[[ 37 254 243]</p><p class="source-code">  [134 179  12]</p><p class="source-code">  [238  32   0]</p><p class="source-code">  ...</p><p class="source-code">  [100  61  73]</p><p class="source-code">  [103 164 131]</p><p class="source-code">  [166  31  68]]</p><p class="source-code"> [[218 109 213]</p><p class="source-code">  [190  22 130]</p><p class="source-code">  [ 56 235 167]</p></li>
				<li>To visualize the returned sample, use the following code:<p class="source-code">plt.imshow(sample)</p><p>The output will be as follows:</p><div id="_idContainer131" class="IMG---Figure"><img src="image/B16182_01_34.jpg" alt="Figure 1.34: A sample from a Box space of (256, 256) RGB&#13;&#10;"/></div><p class="figure-caption">Figure 1.34: A sample from a Box space of (256, 256) RGB</p><p>The preceding is not very informative because it is a random image.</p></li>
				<li>Now, suppose we want to give our agent the opportunity to see the last <strong class="source-inline">n=4</strong> frames. By adding the temporal component, we can obtain a state representation composed of 4 dimensions. The first dimension is the temporal one, the second is the width, the third is the height, and the last one is the number of channels. This is a very useful technique that allows the agent to understand its movement:<p class="source-code"># we want a space representing the last n=4 frames</p><p class="source-code">n_frames = 4  # number of frames</p><p class="source-code">width = 256  # image width</p><p class="source-code">height = 256  # image height</p><p class="source-code">channels = 3  # number of channels (RGB)</p><p class="source-code">shape_temporal = (n_frames, width, height, channels)</p><p class="source-code"># create a new instance of space</p><p class="source-code">space_temporal = spaces.Box(low=low, high=high, \</p><p class="source-code">                            shape=shape_temporal, dtype=dtype)</p><p class="source-code">print("Space with temporal component", space_temporal)</p><p>This will print the following:</p><p class="source-code">Space with temporal component Box(4, 256, 256, 3)</p></li>
			</ol>
			<p>As you can see, we have successfully created a space and, on inspecting the space representation, we notice that we have another dimension: the temporal dimension. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2AwJm7x">https://packt.live/2AwJm7x</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2UzxoAY">https://packt.live/2UzxoAY</a>.</p>
			<p>Image-based environments are very important in RL. They allow the agent to learn salient features for solving the task directly from raw pixels, without any preprocessing. In this exercise, we learned how to create a Gym space for image observations and how to deal with image spaces.</p>
			<h3 id="_idParaDest-56"><a id="_idTextAnchor075"/>Rendering an Environment</h3>
			<p>In the<a href="B16182_01_Final_SZ_ePub.xhtml#_idTextAnchor071"> <em class="italic">Getting Started with Gym – CartPol</em></a><em class="italic">e</em> section, we saw a sample from the CartPole state space. However, visualizing or understanding the CartPole state from a vector representation is not an easy task, at least for a human. Gym also allows you to visualize a given task (if possible) through the <strong class="source-inline">env.render()</strong> function. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">env.render()</strong> function is usually slow. Rendering an environment is done primarily to understand the behavior learned by the agent after the training or on intervals of many training steps. Usually, we train agents without rendering the environment state to improve the training speed.</p>
			<p>If we just call the <strong class="source-inline">env.render()</strong> function, we will always see the same scene, that is, the environment state does not change. To see the evolution of the environment in time, we must call the <strong class="source-inline">env.step()</strong> function, which takes as input an action belonging to the action space and applies the action in the environment. </p>
			<h3 id="_idParaDest-57"><a id="_idTextAnchor076"/>Rendering CartPole</h3>
			<p>The following code demonstrates how to render the CartPole environment. The action is a sample from the action space. For RL algorithms, the action will be smartly selected from the policy: </p>
			<p class="source-code"># Create the environment using gym.make(env_name)</p>
			<p class="source-code">env = gym.make("CartPole-v1")</p>
			<p class="source-code"># reset the environment (mandatory)</p>
			<p class="source-code">env.reset()</p>
			<p class="source-code"># render the environment for 100 steps</p>
			<p class="source-code">n_steps = 100</p>
			<p class="source-code">for i in range(n_steps):</p>
			<p class="source-code">    action = env.action_space.sample()</p>
			<p class="source-code">    env.step(action)</p>
			<p class="source-code">    env.render()</p>
			<p class="source-code"># close the environment correctly</p>
			<p class="source-code">env.close()</p>
			<p>If you run this script, you will see that <strong class="source-inline">gym</strong> opens a window and displays the CartPole environment with random actions, as shown in the following figure:</p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B16182_01_35.jpg" alt="Figure 1.35: A CartPole environment rendered in Gym (the initial state)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.35: A CartPole environment rendered in Gym (the initial state)</p>
			<h3 id="_idParaDest-58"><a id="_idTextAnchor077"/>A Reinforcement Learning Loop with Gym</h3>
			<p>To understand the consequences of an action, and to come up with a better policy, the agent observes its new state and a reward. Implementing this loop with <strong class="source-inline">gym</strong> is easy. The key element is the <strong class="source-inline">env.step()</strong> function. This function takes an action as input. It applies the action and returns four values, which are described as follows:</p>
			<ul>
				<li><strong class="bold">Observation</strong>: The observation is the next environmental state. This is represented as an element belonging to the observation space of the environment.</li>
				<li><strong class="bold">Reward</strong>: The reward associated with a step is a float value that is related to the action given as input to the function.</li>
				<li><strong class="bold">Done</strong>: This return value assumes the <strong class="source-inline">True</strong> value when the episode is finished, and it's time to call the <strong class="source-inline">env.reset()</strong> function to reset the environment state.</li>
				<li><strong class="bold">Info</strong>: This is a dictionary containing debugging information; usually, it is ignored.</li>
			</ul>
			<p>Let's now implement the RL loop within the Gym environment.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor078"/>Exercise 1.04: Implementing the Reinforcement Learning Loop with Gym</h2>
			<p>In this exercise, we will implement a basic RL loop with episodes and timesteps using the CartPole environment. You can change the environment and use other environments as well; nothing changes as the main goal of Gym is to unify the interfaces of all possible environments in order to build agents that are as environment-agnostic as possible. The transparency with respect to the environment is a very peculiar thing in RL: the algorithms are not usually suited to the task but are task-agnostic so that they can be applied successfully to a variety of environments and still solve them. </p>
			<p>We need to create the Gym CartPole environment as before using the <strong class="source-inline">gym.make()</strong> function. After that, we can loop for a defined number of episodes; for each episode, we loop for a defined number of steps or until the episode is terminated (by checking the <strong class="source-inline">done</strong> value). For each timestep, we have to call the <strong class="source-inline">env.step()</strong> function by passing an action (we will pass a random action for now), and then we collect the desired information: </p>
			<ol>
				<li value="1">Open a new Jupyter notebook and define the import, the environment, and the desired number of steps:<p class="source-code">import gym</p><p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">%matplotlib inline</p><p class="source-code">env = gym.make("CartPole-v1")</p><p class="source-code"># each episode is composed by 100 timesteps</p><p class="source-code"># define 10 episodes</p><p class="source-code">n_episodes = 10</p><p class="source-code">n_timesteps = 100</p></li>
				<li>Loop for each episode:<p class="source-code"># loop for the episodes</p><p class="source-code">for episode_number in range(n_episodes):</p><p class="source-code">    # here we are inside an episode</p></li>
				<li>Reset the environment and get the first observation:<p class="source-code">    """</p><p class="source-code">    the reset function resets the environment and returns</p><p class="source-code">    the first environment observation</p><p class="source-code">    """</p><p class="source-code">    observation = env.reset()</p></li>
				<li>Loop for each timestep:<p class="source-code">    """</p><p class="source-code">    loop for the given number of timesteps or</p><p class="source-code">    until the episode is terminated</p><p class="source-code">    """</p><p class="source-code">    for timestep_number in range(n_timesteps):</p></li>
				<li>Render the environment, select the action (randomly by using the <strong class="source-inline">env.action_space.sample()</strong> method), and then take the action:<p class="source-code">        # render the environment</p><p class="source-code">        env.render(mode="rgb-array")</p><p class="source-code">        # select the action</p><p class="source-code">        action = env.action_space.sample()</p><p class="source-code">        # apply the selected action by calling env.step</p><p class="source-code">        observation, reward, done, info = env.step(action)</p></li>
				<li>Check whether the episode has been terminated using the <strong class="source-inline">done</strong> variable:<p class="source-code">        """if done the episode is terminated, we have to reset</p><p class="source-code">        the environment</p><p class="source-code">        """</p><p class="source-code">        if done:</p><p class="source-code">            print(f"Episode Number: {episode_number}, \</p><p class="source-code">Timesteps: {timestep_number}")</p><p class="source-code">            # break from the timestep loop</p><p class="source-code">            break</p></li>
				<li>After the episode loop, close the environment in order to release the associated memory:<p class="source-code"># close the environment</p><p class="source-code">env.close()</p><p>If you run the previous code, the output should, approximately, be like this:</p><p class="source-code">Episode Number: 0, Timesteps: 34</p><p class="source-code">Episode Number: 1, Timesteps: 10</p><p class="source-code">Episode Number: 2, Timesteps: 12</p><p class="source-code">Episode Number: 3, Timesteps: 21</p><p class="source-code">Episode Number: 4, Timesteps: 16</p><p class="source-code">Episode Number: 5, Timesteps: 17</p><p class="source-code">Episode Number: 6, Timesteps: 12</p><p class="source-code">Episode Number: 7, Timesteps: 15</p><p class="source-code">Episode Number: 8, Timesteps: 16</p><p class="source-code">Episode Number: 9, Timesteps: 16</p></li>
			</ol>
			<p>We have the episode number and the number of steps taken in that episode. We can see that the average number of timesteps for an episode is approximately 17. This means that, using the random policy, after 17 episodes on average, the pole falls and the episode finishes.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2MOs5t5">https://packt.live/2MOs5t5</a>.</p>
			<p class="callout">This section does not currently have an online interactive example, and will need to be run locally.</p>
			<p>The goal of this exercise was to understand the bare bones of each RL algorithm. The only different thing here is that the action selection phase should take into account the environment state in order for it to be useful, and it should not be random.</p>
			<p>Let's now move toward completing an activity to measure the performance of an agent.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor079"/>Activity 1.01: Measuring the Performance of a Random Agent</h2>
			<p>The measurement of the performance and the design of an agent is an essential phase of every RL experiment. The goal of this activity is to practice with these two concepts by designing an agent that is able to interact with an environment using a random policy and then measure the performance. </p>
			<p>You need to design a random agent using a Python class to modularize and keep the agent independent from the main loop. After that, you have to measure the mean and the variance of the discounted return using a batch of 100 episodes. You can use every environment you want, taking into account that the agent's action should be compatible with the environment. You can design two different types of agents for discrete action spaces and continuous action spaces. The following steps will help you to complete the activity:</p>
			<ol>
				<li value="1">Import the required libraries: <strong class="source-inline">abc</strong>, <strong class="source-inline">numpy</strong>, and <strong class="source-inline">gym</strong>.</li>
				<li>Define the <strong class="source-inline">Agent</strong> abstract class in a very simple way, defining only the <strong class="source-inline">pi()</strong> function that represents the policy. The input should be an environment state. The <strong class="source-inline">__init__</strong> method should take as input the action space and build the distribution accordingly.</li>
				<li>Define a <strong class="source-inline">ContinuousAgent</strong> deriving from the <strong class="source-inline">Agent</strong> abstract class. The agent should check that the action space is coherent with it, and it should be a continuous action space. The agent should also initialize a probability distribution for sampling actions (you can use NumPy to define probability distributions). The continuous agent can change the distribution type according to the distributions defined by the Gym spaces.</li>
				<li>Define a <strong class="source-inline">DiscreteAgent</strong> deriving from the <strong class="source-inline">Agent</strong> abstract class. The discrete agent should, of course, initialize a uniform distribution.</li>
				<li>Implement the <strong class="source-inline">pi()</strong> function for both agents. This function is straightforward and should only sample from the distribution defined in the constructor and return it, ignoring the environment state. Of course, this is a simplification. You can also implement the <strong class="source-inline">pi()</strong> function in the <strong class="source-inline">Agent</strong> base class.</li>
				<li>Define the main RL loop in another file by importing the agent. </li>
				<li>Instantiate the correct agent according to the selected environment. Examples of environments are "CartPole-v1" or "MountainCar-Continuous-v0."</li>
				<li>Take actions according to the <strong class="source-inline">pi</strong> function of the agent.</li>
				<li>Measure the performance of the agent collecting (in a list or a NumPy array) the discounted return for each episode. Then, take the average and the standard deviation (you can use NumPy for this). Remember to apply the discount factor (user-defined) to the immediate reward. You have to keep a cumulated discount factor by multiplying the discount factor at each timestep. <p>The output should be similar to the following:</p><p class="source-code">Episode Number: 0, Timesteps: 27, Return: 28.0</p><p class="source-code">Episode Number: 1, Timesteps: 9, Return: 10.0</p><p class="source-code">Episode Number: 2, Timesteps: 13, Return: 14.0</p><p class="source-code">Episode Number: 3, Timesteps: 16, Return: 17.0</p><p class="source-code">Episode Number: 4, Timesteps: 31, Return: 32.0</p><p class="source-code">Episode Number: 5, Timesteps: 10, Return: 11.0</p><p class="source-code">Episode Number: 6, Timesteps: 14, Return: 15.0</p><p class="source-code">Episode Number: 7, Timesteps: 11, Return: 12.0</p><p class="source-code">Episode Number: 8, Timesteps: 10, Return: 11.0</p><p class="source-code">Episode Number: 9, Timesteps: 30, Return: 31.0</p><p class="source-code">Statistics on Return: Average: 18.1, Variance: 68.89000000000001</p><p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found on page 680. </p></li>
			</ol>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor080"/>OpenAI Baselines</h2>
			<p>OpenAI Baselines (<a href="https://github.com/openai/baselines">https://github.com/openai/baselines</a>) is a set of state-of-the-art RL algorithms. The main goal of Baselines is to make it easier to reproduce results on a set of benchmarks, to evaluate new ideas, and to compare them to existing algorithms. In this section, we will learn how to use Baselines to run an existing algorithm on an environment taken from Gym (refer to the previous section) and how to visualize the behavior learned by the agent. As for Gym, we will not cover the installation instructions; these can be found in the <em class="italic">Preface</em> section. The implementation of the Baselines' algorithm is based on TensorFlow, one of the most popular libraries for machine learning.</p>
			<h3 id="_idParaDest-62"><a id="_idTextAnchor081"/>Getting Started with Baselines – DQN on CartPole</h3>
			<p>Training a <strong class="bold">Deep Q Network (DQN)</strong> on CartPole is straightforward with Baselines; we can do it with just one line of Bash. </p>
			<p>Just use the terminal and run this command:</p>
			<p class="source-code"># Train model and save the results to cartpole_model.pkl</p>
			<p class="source-code">python -m baselines.run –alg=deepq –env=CartPole-v0 –save_path=./cartpole_model.pkl –num_timesteps=1e5</p>
			<p>Let's understand the parameters, as follows:</p>
			<ul>
				<li><strong class="source-inline">--alg=deepq</strong> specifies the algorithm to be used to train our agent. In our case, we selected <strong class="source-inline">deepq</strong>, that is, DQN.</li>
				<li><strong class="source-inline">--env=CartPole-v0</strong> specifies the environment to be used. We selected CartPole, but we can also select many other environments.</li>
				<li><strong class="source-inline">--save_path=./cartpole_model.pkl</strong> specifies where to save the trained agent.</li>
				<li><strong class="source-inline">--num_timesteps=1e5</strong> is the number of training timesteps.</li>
			</ul>
			<p>After having trained the agent, it is also possible to visualize the learned behavior using the following:</p>
			<p class="source-code"># Load the model saved in cartpole_model.pkl </p>
			<p class="source-code"># and visualize the learned policy</p>
			<p class="source-code">python -m baselines.run --alg=deepq --env=CartPole-v0 --load_path=./cartpole_model.pkl --num_timesteps=0 --play</p>
			<p>DQN is a very powerful algorithm; using it for a simple task such as CartPole is almost overkill. We can see that the agent has learned a stable policy, and the pole almost never falls. We will explore DQN in more detail in the following chapters.</p>
			<p>In the following steps, we will train a DQN agent on the CartPole environment using Baselines: </p>
			<ol>
				<li value="1">First, we import <strong class="source-inline">gym</strong> and <strong class="source-inline">baselines</strong>:<p class="source-code">import gym</p><p class="source-code"># Import the desired algorithm from baselines</p><p class="source-code">from baselines import deepq</p></li>
				<li>Define a callback to inform <strong class="source-inline">baselines</strong> when to stop training. The callback should return <strong class="source-inline">True</strong> if the reward is satisfying:<p class="source-code">def callback(locals, globals):</p><p class="source-code">    """</p><p class="source-code">    function called at every step with state of the algorithm.</p><p class="source-code">    If callback returns true training stops.</p><p class="source-code">    stop training if average reward exceeds 199</p><p class="source-code">    time should be greater than 100 and the average of </p><p class="source-code">    last 100 returns should be &gt;= 199</p><p class="source-code">    """</p><p class="source-code">    is_solved = (locals["t"] &gt; 100 and \</p><p class="source-code">                 sum(locals["episode_rewards"]\</p><p class="source-code">                           [-101:-1]) / 100 &gt;= 199)</p><p class="source-code">    return is_solved</p></li>
				<li>Now, let's create the environment and prepare the algorithm's parameters: <p class="source-code"># create the environment</p><p class="source-code">env = gym.make("CartPole-v0")</p><p class="source-code">"""</p><p class="source-code">Prepare learning parameters: network and learning rate</p><p class="source-code">the policy is a multi-layer perceptron</p><p class="source-code">"""</p><p class="source-code">network = "mlp"</p><p class="source-code"># set learning rate of the algorithm</p><p class="source-code">learning_rate = 1e-3</p></li>
				<li>We can use the <strong class="source-inline">deep.learn()</strong> method to start the training and solve the task:<p class="source-code">"""</p><p class="source-code">launch learning on this environment using DQN</p><p class="source-code">ignore the exploration parameter for now</p><p class="source-code">"""</p><p class="source-code">actor = deepq.learn(env, network=network, lr=learning_rate, \</p><p class="source-code">                    total_timesteps=100000, buffer_size=50000, \</p><p class="source-code">                    exploration_fraction=0.1, \</p><p class="source-code">                    exploration_final_eps=0.02, print_freq=10, \</p><p class="source-code">                    callback=callback,)</p></li>
			</ol>
			<p>After some time, depending on your hardware (it usually takes a few minutes), the learning phase terminates, and you will have the CartPole agent saved to your current working directory. </p>
			<p>We should see the <strong class="source-inline">baselines</strong> logs reporting the agent's performance over time.</p>
			<p>Consider the following example:</p>
			<p class="source-code">--------------------------------------</p>
			<p class="source-code">| % time spent exploring  | 2        |</p>
			<p class="source-code">| episodes                | 770      |</p>
			<p class="source-code">| mean 100 episode reward | 145      |</p>
			<p class="source-code">| steps                   | 6.49e+04 |</p>
			<p>The following are the observations from the preceding logs:</p>
			<ul>
				<li>The <strong class="source-inline">episodes</strong> parameter reports the episode number we are referring to.</li>
				<li><strong class="source-inline">mean 100 episode reward</strong> is the average return obtained in the last 100 episodes.</li>
				<li><strong class="source-inline">steps</strong> is the number of training steps the algorithm has performed.</li>
			</ul>
			<p>Now we can save our actor so that we can reuse it without retraining it:</p>
			<p class="source-code">print("Saving model to cartpole_model.pkl")</p>
			<p class="source-code">actor.save("cartpole_model.pkl")</p>
			<p>After the <strong class="source-inline">actor.save</strong> function, the <strong class="source-inline">"cartpole_model.pkl"</strong> file contains the trained model.</p>
			<p>Now it is possible to use the model and visualize the agent's behavior.</p>
			<p>The actor returned by <strong class="source-inline">deepq.learn</strong> is actually a callable that returns the action given the current observation – it is the agent policy. We can use it by passing the current observation, and it returns the selected action:</p>
			<p class="source-code"># Visualize the policy</p>
			<p class="source-code">n_episodes = 5</p>
			<p class="source-code">n_timesteps = 1000</p>
			<p class="source-code">for episode in range(n_episodes):</p>
			<p class="source-code">    observation = env.reset()</p>
			<p class="source-code">    episode_return = 0</p>
			<p class="source-code">    for timestep in range(n_timesteps):</p>
			<p class="source-code">        # render the environment</p>
			<p class="source-code">        env.render()</p>
			<p class="source-code">        # select the action according to the actor</p>
			<p class="source-code">        action = actor(observation[None])[0]</p>
			<p class="source-code">        # call env.step function</p>
			<p class="source-code">        observation, reward, done, _ = env.step(action)</p>
			<p class="source-code">        """</p>
			<p class="source-code">        since the reward is undiscounted we can simply add </p>
			<p class="source-code">        the reward to the cumulated return</p>
			<p class="source-code">        """</p>
			<p class="source-code">        episode_return += reward</p>
			<p class="source-code">        if done:</p>
			<p class="source-code">            break</p>
			<p class="source-code">    # here an episode is terminated, print the return</p>
			<p class="source-code">    print("Episode return", episode_return) </p>
			<p class="source-code">        """</p>
			<p class="source-code">        here an episode is terminated, print the return </p>
			<p class="source-code">        and the number of steps</p>
			<p class="source-code">        """</p>
			<p class="source-code">    print(f"Episode return {episode_return}, \</p>
			<p class="source-code">Number of steps: {timestep}")</p>
			<p>If you run the preceding code, you should see the agent's performance on the CartPole task. </p>
			<p>You should get, as output, the return for each episode; it should be something similar to the following:</p>
			<p class="source-code">Episode return 200.0, Number of steps: 199</p>
			<p class="source-code">Episode return 200.0, Number of steps: 199</p>
			<p class="source-code">Episode return 200.0, Number of steps: 199</p>
			<p class="source-code">Episode return 200.0, Number of steps: 199</p>
			<p class="source-code">Episode return 200.0, Number of steps: 199 </p>
			<p>This means our agent always reaches the maximum possible return for CartPole (<strong class="source-inline">200.0</strong>) and the maximum possible number of steps (<strong class="source-inline">199</strong>).</p>
			<p>We can compare the return obtained using a trained DQN agent with respect to the return obtained using a random agent (<em class="italic">Activity 1.01, Measuring the Performance of a Random Agent</em>). The random agent yields an average return of <strong class="source-inline">20.0</strong>, while DQN obtains the maximum return possible for CartPole, which is <strong class="source-inline">200.0</strong>.</p>
			<p>In this section, we presented OpenAI Gym and OpenAI Baselines, the two main frameworks for RL research and experiments. There are many other frameworks for RL, each with their pros and cons. Gym is particularly suited due to its unified interface in the RL loop, while OpenAI Baselines is very useful for understanding how to implement sophisticated state-of-the-art RL algorithms and how to compare new algorithms with existing ones.</p>
			<p>In the following section, we will explore some interesting RL applications in order to better understand the possibilities offered by the framework as well as its flexibility.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor082"/>Applications of Reinforcement Learning</h1>
			<p>RL has exciting and useful applications in many different contexts. Recently, the us<a id="_idTextAnchor083"/>age of deep neural networks has augmented the number of possible applications considerably.</p>
			<p>When used in a deep learning context, RL can also be referred to as deep RL.</p>
			<p>The applications vary from games and video games to real-world applications, such as robotics and autonomous driving. In each of these applications, RL is a game-changer, allowing you to solve tasks that are considered to be almost impossible (or, at least, very difficult) without these techniques.</p>
			<p>In this section, we will present some RL applications, describe the challenges of each application, and begin to understand why RL is preferred among other methods, along with its advantages and its drawbacks.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor084"/>Games</h2>
			<p>Nowadays, RL is widely used in video games and board games.</p>
			<p>Games are used to benchmark RL algorithms because, usuall<a id="_idTextAnchor085"/>y, they are very complex to solve yet easy to implement and to evaluate. Games also represent a simulated reality in which the agent can freely move and behave without affecting the real environment:</p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/B16182_01_36.jpg" alt="Figure 1.36:  Breakout – one of the most famous Atari games&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.36:  Breakout – one of the most famous Atari games</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The preceding screenshot has been sourced from the official documentation of OpenAI Gym. Please refer to the following link for more examples: <a href="https://gym.openai.com/envs/#atari">https://gym.openai.com/envs/#atari</a>.</p>
			<p>Despite appearing to be secondary or relatively limited-use applications, games represent a useful benchmark for RL and, in general, artificial intelligence algorithms. Very often, artificial intelligence algorithms are tested on games due to the significant challenges that arise in these scenarios.</p>
			<p>The two main characteristics required to play games are <strong class="bold">planning</strong> and <strong class="bold">real-time control</strong>.</p>
			<p>An algorithm that is not able to plan won't be able to win strategic games. Having a long-term plan is also fundamental in the early stages of a game. Planning is also fundamental in real-world applications in which taken actions may have long-term consequences. </p>
			<p>Real-time control is another fundamental challenge that requires an algorithm to be able to respond within a small timeframe. This challenge is similar to one an algorithm has to face when applied to real-world cases such as autonomous driving, robot control, and many others. In these cases, the algorithm can't evaluate all the possible actions or all the possible consequences of these actions; therefore, the algorithm should learn an efficient (and maybe compressed) state representation and should understand the consequences of its actions without simulating all of the possible scenarios.</p>
			<p>Recently, RL has been able to exceed human performance in games such as Go, and in video games such as Dota II and StarCraft, thanks to work done by DeepMind and OpenAI.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor086"/>Go</h2>
			<p>Go is a very complex, highly strategic board game. In Go, two players are competing against each other. The aim is to use<a id="_idTextAnchor087"/> the game pieces, also called stones, to surround more territory than the opponent. At each turn, the player can place its stone in a vacant intersection on the board. At the end of the game, when no player can place a stone, the player surrounding more territories wins.</p>
			<p>Go has been studied for many years to understand the strategies and moves necessary to lead a player to victory. Until recently, no algorithm succeeded in producing strong players – even algorithms working very well for similar games, such as chess. This difficulty is due to Go's huge search space, the variety of possible moves, and the average length (in terms of moves) of Go games, which, for example, is longer than the average length of chess games. RL, and in particular <strong class="bold">AlphaGo</strong> by DeepMind, succeeded recently in beating a human player on a standard dimension board. AlphaGo is actually a mix of RL, supervised learning, and tree search algorithms trained on an extensive set of games from both human and artificial players. AlphaGo denoted a real milestone in artificial intelligence history, which was made possible mainly due to the advances in RL algorithms and their improved efficiency.</p>
			<p>The successor of <strong class="bold">AlphaGo</strong> is <strong class="bold">AlphaGo Zero</strong>. AlphaGo Zero has been trained fully in a self-play fashion, learning from itself completely with no human intervention (Zero comes from this characteristic). It is currently the world's top player at Go and Chess:</p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B16182_01_37.jpg" alt="Figure 1.37: The Go board&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.37: The Go board</p>
			<p>Both AlphaGo and AlphaGo Zero used a deep <strong class="bold">Convolutional Neural Network (CNN)</strong> to learn a suitable game representation starting from the "raw" board. This peculiarity shows that a deep CNN can also extract features starting from a sparse representation such as the Go board. One of the main strengths of RL is that it can use, in a transparent way, machine learning models that are widely studied in other fields or problems.</p>
			<p>Deep convolutional networks are usually used for classification or segmentation problems that, at first glance, might seem very different from RL problems. Actually, the way CNNs are used in RL is very similar to a classification or a regression problem. The CNN of AlphaGo Zero, for example, takes the raw board representation and outputs the probabilities for each possible action together with the value of each action. It can be seen as a classification and regression problem at the same time. The difference is that the labels, or actions in the case of RL, are not given in the training set, rather it is the algorithm itself that has to discover the real labels through interaction. AlphaGo, the predecessor of AlphaGo Zero, used two different networks: one for action probabilities and another for value estimates. This technique is called actor-critic. The network tasked with predicting actions is called the actor, and the network that has to evaluate actions is called the critic.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor088"/>Dota 2</h2>
			<p>Dota 2 is a complex, real-time strategy game in which there are two teams of five players competing, with each player controlling a "hero." The characteristics of Dota, from an RL perspective, are as follows:</p>
			<ul>
				<li><strong class="bold">Long-Time Horizon</strong>: A Dota game can have around 20,000 moves and can last for 45 minutes. As a reference, a chess game ends before 40 moves and a Go game ends before 150 moves.</li>
				<li><strong class="bold">Partially Observed State</strong>: In Dota, agents can only see a small portion of the full map, that is, only the portion around them. A strong player should make predictions about the position of the enemies and their actions. As a reference, Go and Chess are fully observable games where agents can see the whole situation and the actions taken by the opponents.</li>
				<li><strong class="bold">High-Dimensional and Continuous Action Space</strong>: Dota has a vast number of actions available to each player at each step. The possible actions have been discretized by researchers in around 170,000 actions, with an average of 1,000 possible actions for each step. In comparison, the number of average actions in chess is 35, and in Go, it is 250. With a huge action space, learning becomes very difficult.</li>
				<li><strong class="bold">High-Dimensional and Continuous Observation Space</strong>: While Chess and Go have a discretized observation space, Dota has a continuous state space with around 20,000 dimensions. The state space, as we will learn later in the book, includes all of the information available to players that must be taken into consideration when selecting an action. In a video game, the state space is represented by the characteristics and position of the enemies, the state of the current player, including its ability, its equipment, and its health status, and other domain-specific features.</li>
			</ul>
			<p>OpenAI Five, the RL algorithm able to exceed human performance at Dota, is composed of five neural networks collaborating together. The algorithm learns to play by itself through self-play, playing an equivalent of 180 years per day. The algorithm used for training the five neural networks is called <strong class="bold">Proximal Policy Optimization</strong>, representing the current state of the art of RL algorithms.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To read more on OpenAI Five, refer to the following link: <a href="https://openai.com/blog/openai-five/">https://openai.com/blog/openai-five/</a></p>
			<h3 id="_idParaDest-67"><a id="_idTextAnchor089"/>StarCraft</h3>
			<p>StarCraft has characteristics that make it very similar to Dota, including a huge number of moves per play, imperfect information available to players, and highly dimensional state and action spaces. <strong class="bold">AlphaStar</strong>, the player developed by DeepMind, is the first artificial intelligence agent able to reach the top league without any game restrictions. AlphaStar uses machine learning techniques such as neural networks, self-play through RL, multi-agent learning methods, and imitation learning to learn from other human players in a supervised way.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For further reading on AlphaStar, refer to the following paper: <a href="https://arxiv.org/pdf/1902.01724.pdf">https://arxiv.org/pdf/1902.01724.pdf</a></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor090"/>Robot Control</h2>
			<p>Robots are starting to become ubiquitous nowadays and are widely used in various industries because of their ab<a id="_idTextAnchor091"/>ility to perform repetitive tasks in a precise and efficient way. RL can be beneficial for robotics applications, by simplifying the development of complex behaviors. At the same time, robotics applications represent a set of benchmark and real-world validations for RL algorithms. Researchers test their algorithm on robotic tasks such as locomotion (for example, learning to move) or grasping (for example, learning how to grasp an object). Robotics offers unique challenges, such as the <strong class="bold">curse of dimensionality</strong>, the <strong class="bold">effective usage of samples</strong> (also called sample efficiency), the possibility of <strong class="bold">transferring knowledge</strong> from similar or simulated tasks, and the <strong class="bold">need for safety</strong>:</p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/B16182_01_38.jpg" alt="Figure 1.38: A robotic task from the Gym robotics suite&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.38: A robotic task from the Gym robotics suite</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The preceding diagram has been sourced from the official documentation for OpenAI Gym: <a href="https://gym.openai.com/envs/#robotics">https://gym.openai.com/envs/#robotics</a></p>
			<p class="callout">Please refer to the link for more examples of robot control.</p>
			<p>The <strong class="bold">curse of dimensionality</strong> is a challenge that can also be found in supervised learning applications. Still, in these cases, it is softened by restricting the space of possible solutions to a limited class of functions or by injecting prior knowledge elements in the models through architectural decisions. Robots usually have many degrees of freedom, making the space of possible states and possible actions very large.</p>
			<p>Robots interact with the physical environment by definition. The interaction of a real robot with an environment is usually time-consuming, and it can be dangerous. Usually, RL algorithms require millions of samples (or episodes) in order to become efficient. Sample efficiency is a problem in this field, as the required time may be impractical. The usage of collected samples in a smart way is the key to successful RL-based robotics applications. A technique that can be used in these cases is the so-called <strong class="bold">sim2real</strong>, in which an initial learning phase is practiced in a simulated environment that is usually safer and faster than the real environment. After this phase, the learned behavior is transferred to the real robot in the real environment. This technique requires a simulated environment that is very similar to the real environment or the generalization capabilities of the algorithm. </p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor092"/>Autonomous Driving</h2>
			<p>Autonomous driving is another exciting application of RL. The main challenge this task presents is the lack<a id="_idTextAnchor093"/> of precise specifications. In autonomous driving, it is challenging to formalize what it means to drive well, whether steering in a given situation is good or bad, or whether the driver should accelerate or break. As with robotic applications, autonomous driving can also be hazardous. Testing an RL algorithm, or, in general, a machine learning algorithm, on a driving task, is very problematic and raises many concerns. </p>
			<p>Aside from the concerns, the autonomous driving scenario fits very well in the RL framework. As we will explore later in the book, we can think of the driver as the decision-maker. At each step, they receive an observation. The observation includes the road's state, the current velocity, the acceleration, and all of the car's characteristics. The driver, based on the current state, should make a decision corresponding to what to do with the car's commands, steering, brakes, and acceleration. Designing a rule-based system that is able to drive in real situations is complicated, due to the infinite number of different situations to confront. For this reason, a learning-based system would be far more efficient and effective in tasks such as this. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are many simulated environments available for developing efficient algorithms in the context of autonomous driving, listed as follows:</p>
			<p class="callout"><strong class="bold">Voyage Deepdrive:</strong> <a href="https://news.voyage.auto/introducing-voyage-deepdrive-69b3cf0f0be6">https://news.voyage.auto/introducing-voyage-deepdrive-69b3cf0f0be6</a></p>
			<p class="callout"><strong class="bold">AWS DeepRacer:</strong> <a href="https://aws.amazon.com/fr/deepracer/">https://aws.amazon.com/fr/deepracer/</a></p>
			<p>In this section, we analyzed some interesting RL applications, the main challenges of them, and the main techniques used by researchers. Games, robotics, and autonomous driving are just some examples of real-world RL applications, but there are many others. In the remainder of this book, we will deep dive into RL; we will understand its components and the techniques presented in this chapter.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor094"/>Summary</h1>
			<p>RL is one of the fundamental paradigms under the umbrella of machine learning. The principles of RL are very general and interdisciplinary, and they are not bound to a specific application.</p>
			<p>RL considers the interaction of an agent with an external environment, taking inspiration from the human learning process. RL explicitly targets the need to explore efficiently and the exploration-exploitation trade-off appearing in almost all human problems; this is a peculiarity that distinguishes this discipline from others. </p>
			<p>We started this chapter with a high-level description of RL, showing some interesting applications. We then introduced the main concepts of RL, describing what an agent is, what an environment is, and how an agent interacts with its environment. Finally, we implemented Gym and Baselines by showing how these libraries make RL extremely simple.</p>
			<p>In the next chapter, we will learn more about the theory behind RL, starting with Markov chains and arriving at MDPs. We will present the two functions at the core of almost all RL algorithms, namely the state-value function, which evaluates the goodness of states, and the action-value function, which evaluates the quality of the state-action pair.</p>
		</div>
		<div>
			<div id="_idContainer137" class="Basic-Text-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer138" class="Content">
			</div>
		</div>
	</body></html>