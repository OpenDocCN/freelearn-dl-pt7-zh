["```py\nimport os\nimport re\nimport pandas as pd\nimport matplotlib.pyplot as plt \nimport seaborn as sns\n\nfrom sklearn.metrics import classification_report,roc_curve, auc,confusion_matrix,f1_score\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.feature_selection import RFE\nfrom sklearn import linear_model,tree\nfrom sklearn.neural_network import MLPClassifier\nfrom sklearn.preprocessing import StandardScaler\n\nimport pickle\nimport graphviz\n```", "```py\ndef select_columns(df, col_list):\n    ...\ndef generate_column_lists(col_support,col_list):\n    ...\ndef optimize_RFE(logreg, X, Y, target_features = 10):\n    ...\n    while trial_cnt<=target_features:\n        rfe = RFE(logreg,trial_cnt,verbose=1)\n        ...    \n        select_cols = generate_column_lists(col_support, col_list)\n        X_selected = select_columns(X,select_cols)\n       ...            \n        #build model\n        ...    \n        ##metric 1: roc\n       ...        \n        #memorize this setting if this ROC is the highest\n        ...        \n    return max_roc_auc, best_col_list, result_list\n\ndef train_logreg(X,Y):\n    print('Logistic Regression')\n    logreg = linear_model.LogisticRegression(C=1e5)\n    roc_auc, best_col_list, result_list = optimize_RFE(logreg, \\\n                                                       X, Y, 20)    \n    scaler = StandardScaler()\n    scaler.fit(X_train)\n    ...\n    ##metric 1: roc\n    ...\n    ##metric 2: Confusion matrix\n    Y_pred_logreg = logreg.predict(X_test)\n    confusion_matrix_logreg = confusion_matrix(Y_test, \\\n                                               Y_pred_logreg)\n    ...\n    #common standard to compare across models\n    f1_clf = f1_score(Y_test, Y_pred_logreg, average='binary')\n    ##Quality Check: test for dependency\n    ...\n    ##save model\n...\n```", "```py\n'''\n## Decision Tree\n'''\n#feed in data to the decision tree\ndef train_tree(X,Y):\n    print('Decision Tree')\n    #split the dataset into training set and testing set\n    ...\n    tree_clf = \\\n        tree.DecisionTreeClassifier(min_samples_leaf=min_leaf_size)\n\n    #preprocessing the data\n    scaler = StandardScaler()\n    scaler.fit(X_train)    \n    ...    \n    #fit the training data to the model\n    ...\n    ##metric 1: roc\n    ...\n    ##metric 2: Confusion matrix\n    ...\n    #common standard to compare across models\n    ...\n    ##save model\n    ...\n```", "```py\n##Grid search that simulate the performance of different neural network #design\ndef grid_search(X_train,X_test, Y_train,Y_test,num_training_sample):\n    ...\n    #various depth\n    for depth in range(1,5):\n        ...\n        for layer_size in range(1,8):\n            ...\n            nn_clf = MLPClassifier(alpha=1e-5, \\\n                     hidden_layer_sizes=hidden_layers_tuple, \\\n                     random_state=1)\n            ...\n    ...\n\n    #various size\n\ndef train_NN(X,Y):\n    print('Neural Network')\n    #split the dataset into training set and testing set\n    ...\n\n    #preprocessing the data\n    scaler = StandardScaler()\n    scaler.fit(X_train)\n    ...\n```", "```py\nf1_list = []\nf1_score_temp= 0\n\n#logistic regression model\nlog_reg,f1_score_temp = train_logreg(X,Y)\nf1_list.append(f1_score_temp)\nlog_reg.get_params()\n\n#decision tree\ntree_clf,f1_score_temp = train_tree(X,Y)\nf1_list.append(f1_score_temp)\ntree_clf.get_params()\n\n#neural network\nnn_clf,f1_score_temp = train_NN(X,Y)\nf1_list.append(f1_score_temp)\nnn_clf.get_params()\n```", "```py\n'''\n#4 Visualize the result\n'''\nprint('********************')\nprint('f1 of the models')\nprint(f1_list)\nprint('********************')\n```", "```py\n#for visualization of decision tree\nx_feature_name = fields_list[:-1]\ny_target_name = fields_list[-1]\nd_tree_out_file = 'decision_tree'\ndot_data = tree.export_graphviz(tree_clf, out_file=None, \n                         feature_names=x_feature_name,  \n                         class_names=y_target_name,  \n                         filled=True, rounded=True,  \n                         special_characters=True) \ngraph = graphviz.Source(dot_data) \ngraph.render(d_tree_out_file)\n```", "```py\n##Step 1: Import Data from the list of Loans and Deposits\n##Based on an input file, generate list of borrowers and depositors at the beginning\n##Keep the master copy of clean clients list\n'''\nlist_depositors_template,list_borrowers_template = generate_list(f_deposit_path,f_loan_path,start_date)\n```", "```py\nprint('running simulation')\nfor run in range(0,1000):\n    print('simulation ' +str(run))\n    #reward function reset\n    reward = 0\n\n    list_depositors = copy.deepcopy(list_depositors_template)\n    list_borrowers = copy.deepcopy(list_borrowers_template)\n    ...\n```", "```py\n#build a model if this is the first run, otherwise, load the saved model\n#bank and environment objects created\n...\ndeposit_pricing_grid_pred = jpm.generate_deposit_grid(deposit_constant_grid)\nloan_pricing_grid_pred = jpm.generate_loan_grid(loan_constant_grid)\nloan_pricing_grid_prev = loan_empty_grid\ndeposit_pricing_grid_prev = deposit_empty_grid\nloan_pricing_grid_final = loan_empty_grid\ndeposit_pricing_grid_final = deposit_empty_grid\n\n#market is also a bank (collective behavior of many banks)\n#market object created\nmarket = bank()\n...\n\ndaily_loan_list=[]\ndaily_deposit_list=[]\ndaily_net_asset_list=[]\ncum_income_earned =0\ncum_expense_paid =0\n\nmkt_expense = 0\nmkt_income = 0\n\nfor i_depositor in list_depositors_template:\n...\n\nfor i_borrower in list_borrowers_template:\n...\n```", "```py\n##Generate two pricing grids for the day\nmkt_deposit_pricing_grid, mkt_loan_pricing_grid = \\\n                            market.generate_pricing_grids_MC()\nloan_pricing_grid_pred,x_np_loan = jpm.generate_loan_grid_ML(...)\ndeposit_pricing_grid_pred,x_np_deposit = \\\n                            jpm.generate_deposit_grid_ML(...)\nloan_pricing_grid_prev = loan_pricing_grid_final\ndeposit_pricing_grid_prev = deposit_pricing_grid_final\n...\n```", "```py\n## Generating list of all possible loan / deposit pricing, including previous, and current predicted pricing\n...\n#generate lots of variations:\nfor i in range(0,num_randomized_grid):\n...\n\n#accessing each of the choice\n...\n\n## Predict the reward values of each the variation and make the choice of pricing\nfor loan_i in range(0,num_grid_variations):\n     for deposit_i in range(0,num_grid_variations):\n     ...\n     #Policy A\n     if max_reward<= temp_reward:\n     ...\n\n     #Policy B: if both conditions fail, randomize the choice\n     ...\n\n     #Policy C: Choose the best choice & reward\n     ...\n```", "```py\n#Carry forward the deposit and Roll-over the loan\n#stay or not\n##Update borrower and depositor\nfor i_borrower in list_borrowers:\n...\n\nfor i_depositor in list_depositors:\n...\n\n# Actualized p n l\n##*************************************\n# with clients\nfor i_borrower in list_borrowers:\n#pocket in the loan interest\n...\n\nfor i_depositor in list_depositors:\n#pay out the deposit interest\n...\n\n#market operations\n...\n\n##*************************************\n#End of day closing\n##*************************************\n#cumulative income = income earned from client + income earned from market (if any excess deposit placed overnight)\n...\n\n#cumulative expense = expense paid to the client + expense paid to market (if any insufficient deposit to fund overnight pos)\n...\n\n#Closed book for the day\n...\n\nf_log.write('\\n****************summary run:' +str(run) + ' day ' +str(day_cnt)+'****************')\n...\n```", "```py\n#output result of this run and save model\nprint('run ' + str(run) + ' is completed')\n...\n```"]