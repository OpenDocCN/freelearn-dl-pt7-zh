- en: Using Features and Reinforcement Learning to Automate Bank Financing
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特征和强化学习来自动化银行融资
- en: Commercial banks make money by earning interest on money that was loaned to
    borrowers. In many cases, the loan becomes a **Non-Performing Asset** (**NPA**)
    for the bank. There are instances where the borrower could go bankrupt, leaving
    the bank with a loss. In such situations, it becomes critical for commercial banks
    to assess the borrower's ability to repay the loan in a timely manner.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 商业银行通过对借款人贷款收取利息来赚取利润。在许多情况下，贷款会变成银行的**不良资产**（**NPA**）。有些情况下，借款人可能会破产，导致银行遭受损失。在这种情况下，商业银行必须及时评估借款人还款能力，变得至关重要。
- en: Now, if we look at this scenario closely, we realize that every loan is funded
    by the money deposited by other customers. Thus, the commercial bank owes interest
    to the depositor for the money deposited for a time period. This is usually the
    interest on the depositor's money that is credited by the banks on a quarterly
    basis. The bank also profits if it charges the borrower more interest and pays
    a low interest to the depositor.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们仔细看这个场景，我们会意识到每一笔贷款都是由其他客户存款提供资金的。因此，商业银行需要向存款人支付利息，这是对存款人资金的一种回报，通常是按季度计算的。银行还可以通过向借款人收取更高的利息，并向存款人支付较低的利息来获利。
- en: In this chapter, we will derive the solution for both of these situations by
    using **Reinforcement Learning** (**RL**), which is an important area of machine
    learning. Apart from this, we shall also look at examples of how RL can be helpful
    in banking functions. RL is one of the three areas of machine learning, with the
    others being supervised learning and unsupervised learning. RL is specifically
    applicable where decision-making is required based on the surroundings or the
    current environment. In RL, an agent is presented with options to move toward
    the reward. The agent has to choose one of the options available. If the correct
    option is chosen, the agent gets a reward. Otherwise, the agent gets penalized.
    The goal for the agent is to maximize their chance of getting closer to the reward
    with each step and to ultimately obtain it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过使用**强化学习**（**RL**），这一机器学习的重要领域，推导出这两种情况的解决方案。除此之外，我们还将看看强化学习如何在银行职能中提供帮助。强化学习是机器学习的三个领域之一，另外两个是监督学习和无监督学习。强化学习特别适用于基于环境或当前环境做出决策的场景。在强化学习中，代理会面临多种选择，朝着奖励前进。代理需要选择一个可用选项。如果选择了正确的选项，代理会得到奖励，否则会受到惩罚。代理的目标是通过每一步最大化接近奖励的机会，并最终获得奖励。
- en: 'All of these concepts shall be divided into the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些概念将分为以下主题：
- en: Breaking down the functions of a bank
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆解银行的功能
- en: AI modeling techniques
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工智能建模技术
- en: Metrics of model performance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型性能的度量
- en: Building a bankruptcy prediction model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建破产预测模型
- en: Funding the loan using reinforcement learning
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用强化学习为贷款提供资金
- en: Before we move forward and learn about RL, it is necessary to understand the
    banking business and how it functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续深入了解强化学习（RL）之前，了解银行业务及其运作方式是必要的。
- en: Breaking down the functions of a bank
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆解银行的功能
- en: 'Within a bank, as an intermediary between those with excess money (the depositors)
    and those who need money (the borrowers), there are two important questions that
    need to be answered:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在银行内部，作为资金过剩者（存款人）和资金需求者（借款人）之间的中介，有两个重要问题需要回答：
- en: How risky is a borrower?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 借款人的风险有多大？
- en: What is the funding cost of money?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资金成本是什么？
- en: These are the two important questions that need to be considered before we look
    at the profit required for sustaining the business operations in order to cover
    its running costs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们在查看支持业务运营所需的利润之前，需要考虑的两个重要问题，以覆盖其运行成本。
- en: 'When these decisions are not made properly, it threatens the viability of a
    bank. There could be two possible outcomes in such instances:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些决策没有正确做出时，会威胁到银行的生存能力。在这种情况下，可能会有两种结果：
- en: If the bank does not make enough profit to cover the cost of risk and operations
    when a risky event occurs, the bank could collapse.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果银行在发生风险事件时无法赚取足够的利润来覆盖风险和运营成本，银行可能会倒闭。
- en: If the bank fails to meet the depositor's requirements or fails to honor its
    borrower's agreements to lend, it hurts the credibility of the bank, thus driving
    potential customers away.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Major risk types
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To answer the question, *How risky is a borrower?,* we first need to understand
    the factors contributing to risk.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**Risk** is an unfavorable outcome in the future that impacts the functioning
    of a bank. For a bank, the major contributors include the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '**Credit risk**: This risk concerns the borrower''s inability to repay the
    capital back to the bank in a lending transaction; for example, the financial
    distress of the borrowing firm, causing its inability to repay the loan.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Market risk**: This risk concerns unfavorable price movements in financial
    markets, such as an interest rate hike in the market from which the bank sources
    its funding.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operational risk**: This risk concerns events happening in the operations
    of the bank as an organization. This could include internal theft, a cyber attack,
    and so on.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a complete list of the types of risk, please refer to the Basel Framework by
    BIS ([https://www.bis.org/bcbs/basel3.htm](https://www.bis.org/bcbs/basel3.htm)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Asset liability management
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Commercial banks need deposits in order to fund loans. As well as assessing
    the riskiness of borrowers, the bank also performs a useful function in that they
    convert deposits from savers into loans for borrowers. Thus, a pricing mechanism
    for both depositors and borrowers is important. To a bank, loans sit on the asset
    side of financial statements, while deposits sit on the liabilities side of the
    business. Therefore, this is often called **Asset and Liability Management** (**ALM**).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will focus on only one part of the entire ALM function – the
    funding aspect – without covering other risks such as liquidity risk, interest
    rate risk, and foreign exchange risk. The following are the objectives of the
    ALM function of a bank:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The first objective of ALM is to ensure that loans are supported by deposits
    and that the bank will have sufficient deposits, in case the depositors ask for
    their money back. In terms of the total quantity, approximately, a $100 deposit
    supports a $70 loan. Referencing the ratios from some of the biggest banks, the
    ratios should be around 1.2:1 to 1.5:1 for a customer deposit to a customer loan.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, there is another aspect with regard to how long deposits are placed
    for and loans are lent out. The question of how long is referred to as the **duration**.
    To meet long-term loan commitments, the bank also needs deposits to be locked
    in for a long enough time to ensure that loans are supported by deposits in a
    long-term manner.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thirdly, the ALM function needs to be profitable, which means the ALM income
    should be higher than the ALM cost. The *cost* is the ALM pricing that you are
    giving out. This cost is, in fact, the income for ALMs/banks, while the deposit
    rate quoted to the client is the bank's expense.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part of a bank''s well-known secret for profit is to convert the short-term
    deposit (lower-priced) into a long-term loan (higher interest income). The following
    curve shows the pricing aspect for a bank for its deposits and loans:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 银行盈利的一个知名秘诀是将短期存款（低价）转化为长期贷款（高利息收入）。以下曲线显示了银行存款和贷款的定价情况：
- en: '![](img/b5ae9587-1f39-45f6-8620-e8c2db1b43df.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5ae9587-1f39-45f6-8620-e8c2db1b43df.png)'
- en: In the preceding graph, the *x* axis shows how long (in days) the deposit/loan
    position will remain with the bank, while the *y* axis shows the annualized interest
    rate.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，*x*轴表示存款/贷款在银行中保持的时间（以天为单位），而*y*轴表示年化利率。
- en: Interest rate calculation
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利率计算
- en: Though there are many ways to calculate the interest to be paid on the deposit,
    the most common way to calculate interest is to quote the interest in its annualized
    form; that is, as if the interest has been put in place for a year, regardless
    of how long it will be placed for.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有许多方法来计算存款应支付的利息，但最常见的计算利息的方法是以年化形式报价；也就是说，无论存款时间有多长，都假设利息是以一年的时间来计算的。
- en: 'For example, if the 7-day interest rate for a deposit is 1%, this means that
    within 7 days, we will get the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果存款的7天利率为1%，这意味着在7天内，我们将获得以下收益：
- en: '![](img/40783a18-fb4d-4228-ae8d-c4d25bd24962.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40783a18-fb4d-4228-ae8d-c4d25bd24962.png)'
- en: We only need to divide the annualized interest rate by 7 days in order to get
    what we shall get for the 7-day period. The reason behind this is that it is useful
    for a market dealer to have a standardized way to quote pricing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将年化利率除以7天，就能得到7天期间的利率。其背后的原因是，市场交易员需要一种标准化的方式来报价。
- en: We will use this formula for interest pricing and deposit pricing in the *Funding
    a loan using reinforcement learning* section, later in this chapter. However,
    there are a lot of other fine details with regard to interest pricing, with different
    ways of compounding (interest can be earned from interest) and day-count conventions
    (365 days, actual calendar or actual working days, 360 days, 220 days, and so
    on). For illustration purposes, we will assume a year is made up of 365 days and
    we will use simple interest rates without compounding.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面“*使用强化学习为贷款融资*”一节中使用此公式进行利息定价和存款定价。然而，关于利息定价，还有很多其他细节问题，包括不同的复利方式（利息可以从利息中赚取）和天数计数规则（365天、实际日历或实际工作日、360天、220天等）。为了简化说明，我们假设一年有365天，并且使用不计复利的简单利率。
- en: Credit rating
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信用评级
- en: Besides the cost of lending described in ALM, another role of the bank is to
    assess the level of risk when getting involved with a client. This riskiness is
    added to the cost of funding. This concept is known as **credit rating** in banks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在ALM中描述的借贷成本外，银行的另一个职能是评估在与客户打交道时所承担的风险水平。这种风险性会被加到资金成本中。这个概念在银行中被称为**信用评级**。
- en: The Basel Committee assesses and imposes global regulations on risk management
    in banks. According to the definition provided by the *Definition on Defaul**t/Loss*
    by the Basel Committee ([https://www.bis.org/bcbs/qis/qis3qa_f.htm](https://www.bis.org/bcbs/qis/qis3qa_f.htm)),
    credit rating predicts the probability of a borrower (who is the one being rated)
    going bankrupt in a year's time. Borrowers usually default on a loan due to the
    bankruptcy of companies. So, we normally use default and bankruptcy interchangeably.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 巴塞尔委员会评估并实施全球银行风险管理的相关规定。根据巴塞尔委员会提供的*违约/损失定义*（[https://www.bis.org/bcbs/qis/qis3qa_f.htm](https://www.bis.org/bcbs/qis/qis3qa_f.htm)），信用评级预测借款人（即被评级者）在一年内破产的概率。借款人通常因公司破产而违约。因此，我们通常将违约和破产互换使用。
- en: The essential question is, given the required information, how likely is it
    that the company could go bankrupt within 1 year, thus failing to meet its repayment
    obligation? This could be driven by many reasons, but one obvious reason is that
    the financial health of the company is not good.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 关键问题是，考虑到所需信息，公司在1年内破产、无法履行偿还义务的可能性有多大？这可能由多种原因驱动，但一个显而易见的原因是公司的财务状况不好。
- en: A financial statement is like the report card of a company – even though it
    takes time to produce, it conforms to a certain internationally accepted standard
    and comes with the guarantee of quality by the auditors.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 财务报表就像公司的成绩单——尽管它需要时间来制作，但它符合某种国际公认的标准，并且有审计师的质量保证。
- en: AI modeling techniques
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能建模技术
- en: Now that we've understood the functions of a business, it's time to move onto
    some technical concepts. In this section, we will learn about AI modeling techniques,
    including Monte Carlo simulation, the logistic regression model, decision trees,
    and neural networks.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了业务的功能，是时候了解一些技术概念了。在这一部分中，我们将学习人工智能建模技术，包括蒙特卡洛模拟、逻辑回归模型、决策树和神经网络。
- en: Monte Carlo simulation
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟
- en: Monte Carlo simulation uses heavy computation to predict the behavior of objects
    by assuming random movements that can be described by probability. This approach
    is a standard tool that's used to study the movements of molecules in physics,
    which can only be predicted with a certainty of the movement pattern, which is
    described by probability.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟通过假设可以用概率描述的随机运动，使用大量计算预测物体的行为。这种方法是研究分子在物理学中运动的标准工具，分子的运动只能以模式的确定性描述，通常使用概率来预测。
- en: Finance professionals adopt this method to describe the pricing movement of
    securities. We will use it to simulate pricing in the *Funding the loan using
    reinforcement learning* section, later in this chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 金融专业人士采用这种方法来描述证券价格的变动。我们将在本章稍后的*使用强化学习为贷款提供资金*部分中使用该方法进行定价模拟。
- en: The logistic regression model
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑回归模型
- en: The logistic regression model is one of the most popular adoptions of AI in
    banking, especially in the domain of credit risk modeling. The target variable
    of the model will be a binary outcome of 1 or 0, with a probability of meeting
    the target of 1\. The decision of what 1 and 0 refer to depends on how we prepare
    the data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归模型是人工智能在银行业中最常见的应用之一，尤其是在信用风险建模领域。该模型的目标变量将是1或0的二元结果，1的概率表示满足目标。1和0的具体含义取决于我们如何准备数据。
- en: In this case, the target variable can be a company filing for bankruptcy within
    1 year. The model is called logistic because the function that models the 1 and
    0 is called **logit**. It is called regression because it belongs to a statistical
    model called the regression model, which strives to determine the causation of
    factors of an outcome.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，目标变量可以是公司在1年内破产的情况。该模型称为逻辑回归，因为用于建模1和0的函数被称为**logit**。它被称为回归模型，因为它属于一种统计模型——回归模型，旨在确定影响结果的因果关系。
- en: Decision trees
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决策树
- en: The decision tree algorithm actually belongs to the supervised learning group
    of algorithms. However, due to the nature of the algorithm, it is commonly used
    to solve regression and classification problems. Regression and classification
    often require decision-making based on the situation at hand. So, these problems
    are commonly solved using reinforcement learning algorithms.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 决策树算法实际上属于监督学习算法组。然而，鉴于该算法的性质，它常用于解决回归和分类问题。回归和分类通常需要根据当前情况做出决策。因此，这些问题通常使用强化学习算法来解决。
- en: 'The beneficial element of having a decision tree is that we can actually visualize
    the decision tree''s representation. The decision-making process starts at the
    top of the tree and branches out toward the leaf nodes of the tree. The leaf nodes
    are the point at which the target variables will end up. All the values of a variable
    that are classified to the same leaf node contain the same probability of defaulting.
    The following is an example visualization of a decision tree algorithm that is
    making a decision to give a loan to the applicant:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 决策树的有益之处在于我们实际上可以可视化决策树的表示。决策过程从树的顶部开始，向树的叶子节点分支。叶子节点是目标变量最终落点的地方。所有被分类到同一叶子节点的变量值，具有相同的违约概率。以下是一个决策树算法可视化示例，展示了如何做出是否向申请人发放贷款的决策：
- en: '![](img/d40afa56-e04a-40ae-9fe9-7de7d29a8c63.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d40afa56-e04a-40ae-9fe9-7de7d29a8c63.png)'
- en: The most common way to move forward in the decision tree is to look at the minimal
    leaf size, which refers to the size of the bucket that each of the training samples
    is being classified in. If the bucket contains too few samples than `min_samples_leaf`
    dictates, then it will be scrapped. This can be done to reduce the number of buckets
    (known as the **leaf node of a decision tree**).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 决策树中最常见的前进方式是查看最小叶子大小，这指的是每个训练样本被分类到的桶的大小。如果桶内的样本数量少于`min_samples_leaf`所规定的数量，则该桶将被舍弃。这样做可以减少桶的数量（称为**决策树的叶子节点**）。
- en: Reading the decision tree is easy. However, it is quite amazing to realize how
    the machine learns about the various conditions used for splitting.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Neural networks
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A simple neural network looks like the one shown in the following diagram:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fe31c9c-dd00-4146-9426-10c46bd80f44.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: It consists of three layers, namely the **input layer**, the **hidden layer**,
    and the **output layer**. Each layer is made up of nodes. The artificial neural
    network that is used to solve AI problems mimics the physical neural network present
    in the human brain. The neurons in the human brain are represented by nodes in
    the artificial neural network. The connections between the neurons are represented
    in the artificial neural network by weights.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand the significance of each of the layers in the neural network.
    The input layer is used to feed the input into the model. It is also responsible
    for presenting the condition that the model is being trained for. Every neuron
    or node in the input layer represents one independent variable that has influence
    over the output.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The hidden layer is the most crucial because its job is to process the data
    it has received from the input layer and is responsible for extracting the necessary
    features from the input data. The hidden layer consists of one or more layers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: In the case of solving a problem with linearly represented data, the activation
    function (which processes the input data) can be included in the input layer itself.
    However, for processing complex representations of data, one or more hidden layers
    are required. The number of hidden layers depends on the complexity of the data.
    The hidden layer passes on the processed data to the output layer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The output layer is responsible for collecting and transmitting information.
    The pattern that the output layer presents can be traced back to the input layer.
    The number of nodes in the output layer depends on the number of decisions to
    be made eventually.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Reinforcement learning
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the case of reinforcement learning, the model receives feedback on every
    step that it takes. First, let''s understand the entities involved in reinforcement
    learning:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '**Agent**: This is someone who acts; in our case, it is the bank.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: This is the actual work done by the agent. In our case, actions
    refer to the pricing grid offered by the bank.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utility function**: This assigns numbers to represent the desirability of
    a state. The utility function is learned via interactions from the feedback given
    by the actual **Profit and Loss** (**P&L**)/funding status versus pricing grids
    (both deposit and loan) offered.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rewards**: This is the numeric representation of the desirability of the
    outcome. In our case, it is cumulative P&L (the binary result of meeting or failing
    the self-funding target, with 1 representing meeting and 0 representing failing).
    The cumulative P&L will equal 0 if the bank fails the self-funding requirements.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policy**: Choose the action based on the utilities estimated. In our case,
    our policy does not evolve as it strives to take the pricing grid that provides
    the maximum next states'' rewards. The policy we have leads to exploitation, not
    exploration, which means the policy does not give away current P&L to generate
    long-term P&L. This is because the depositors and borrowers will display a certain
    level of stickiness if they witness non-profitability in the short term while
    gaining P&L over the long term. Exploration is a normal action among relationship
    bankers, who treasure the long-term profitability of relationships.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep learning
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With each of the models or techniques that we are learning, the complexity increases.
    In this example, we will assume that there will be 36 variables/features in the
    input layer. There will be two variables/features in the output layer – one for
    profitability and one for the self-funding status. There will be two hidden layers
    in-between the input and output layers – one next to the input layer with 10 neurons,
    followed by another layer with 15 neurons. This example will form a neural network
    that makes general pricing decisions for banks.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: To estimate the profitability and self-funding status of the neural network,
    there are 127 variables in the input layer, three hidden layers each with 15 neurons,
    and one output layer with one output neuron to generate profitability (cumulative
    profit and loss for the day) or the percentage of client deposit to client loan.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: In comparison to the logistic regression model, the input features are much
    more complex in the case of deep learning and the number of parameters involved
    is in the magnitude of 10 times more or above.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows a summary of the pricing model:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '| **Layer** | **Shape** | **No of parameters** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| Input | (1, 36) | 0 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| Hidden 1 | (1, 10) | 370 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| Hidden 2 | (1, 15) | 165 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| Hidden 3 | (1, 15) | 240 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| **Total parameters** | **775** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: In the preceding table, the first column lists which layer it is – input or
    hidden. The second column represents the shape of the layer in terms of the number
    of parameters connected from the previous layer to the current layer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the number of parameters, let's consider the **Hidden 1** layer.
    In this case, 36 features from the previous layer connect to 10 neurons in the
    current layer. We also need constants equal to the number of features in the current
    layer to achieve scaling across features. So, the total parameters come to 36*10
    + 10 = 370 parameters in the **Hidden 1** layer.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to count the parameters helps us see whether the amount of training
    data is sufficient enough to train the network. It is strongly suggested that
    we ensure that the number of parameters is at least equal to *number of records*
    * *number of epochs*. Think of how many formulas will be required to determine
    a problem with two variables – at least two. The formula is like training data
    in deep learning, while the variables are like the parameters of the network.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Metrics of model performance
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we build an AI model, the most important aspect of the process is to define
    a way to measure the performance of a model. This enables the data scientist to
    decide how to improve and pick the best model.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn about three common metrics that are commonly
    used in the industry to assess the performance of the AI model.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Metric 1 – ROC curve
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Receiver Operating Characteristic** (**ROC**) metric measures how well
    the classifier performs its classification job versus a randomized classifier.
    The classifier that's used in this metric is a binary classifier. The binary classifier
    classifies the given set of data into two groups on the basis of a predefined
    classification rule.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: This is linked to a situation where, say, we compare this model against flipping
    a fair coin to classify the company as being default or non-default, with heads
    indicating default and tails indicating non-default. Here, there's a 50% chance
    of classifying default and a 50% chance of classifying non-default.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: For a completely randomized predictive system such as coin flipping, it is very
    likely that the probability of hitting a true positive is the same as hitting
    a false positive rate. But in the case of companies defaulting in 1 year, in the
    following example, it is 6.3% (123 out of 1,828), which means we have an actual
    count of 1,828 non-default cases and 123 default cases. A truly random model will
    predict half of the default cases as non-default.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Let's plot a chart that shows the true positive and false positive rate as an
    ROC chart. True or false means the prediction that was made for the default event
    is factually true or false. Positive means that the classifier is positive (equals
    1, which is default, in this case).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: When we make no prediction, the true positive and false positive rate is 0\.
    When we have gone through 50% of the sample, which is given as 1,951/2, we should
    be getting 50% of the sample by default, where 50% of the guesses are false positive.
    When we get to 100% of the sample, we should have 100% of the sample as true positive
    and 100% as false positive.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'This randomized classifier''s performance is denoted by the dotted line in
    this diagram:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17680b0a-71e6-4d56-a749-03dcb6b3a1f0.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: In the most ideal classifier case, we should be able to improve the true positive
    rate to 100%, with the false positive rate at 0% (denoted by the yellow line in
    the preceding diagram).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: For the worst classifier, which classifies everything as 100% incorrect, the
    true positive rate should be 0% and the false positive rate should be 100% (denoted
    by the red dot). The use of ROC is also prevalent in credit risk model validation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Metric 2 – confusion matrix
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The confusion matrix is the most popular metric used to measure the performance
    of a classifier and has two outcomes:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  | **Actual: Ground Truth** |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '|  |  | True Default | False/Non-default |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| **Prediction by Classifier** | Positive/Default | 62 | 27 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| Negative/Non-default | 61 | 1,801 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '|  |  | True Positive Rate = 62/(62+61) | False Positive Rate = 27/(27+1,801)
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: The confusion matrix also provides results similar to the ROC curve. The major
    idea behind this is to separate prediction and the ground truth by rows and columns.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Metric 3 – classification report
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The classification report is another way to appraise the performance of the
    model, with the following indicators:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/239d7cff-13cb-44bb-bc07-04f493ccef0c.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'The details of the indicators are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '**Precision and recall:** Precision addresses the true positive rate of the
    model prediction, while recall addresses the coverage of the model. Precision
    measures the percentage of the predicted value being the predicted value. Recall
    measures the percentage of the target values being predicted as the expected values.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**F1-score**: One of the most important measures of the overall accuracy of
    the model is the F1-score. It is the harmonic mean of precision and recall. This
    is what we use to compare the performance of models.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Support**: This is another term that means the number of records that are
    of the value listed in the leftmost column. There are 123 actual default cases
    (with target *value = 1* under the *default* column).'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a bankruptcy risk prediction model
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bank, as the lender, needs to dictate the interest rates that will cover
    the cost of lending. The bank provides the interest rate by considering its cost
    of borrowing from others, plus the risk that the company might file for bankruptcy
    after taking the loan from the bank.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we shall assume the role of a banker to assess the probability
    of the borrowers becoming bankrupt. The data for this has been obtained from data.world
    ([https://data.world](https://data.world)), which provides us with the data for
    the bankruptcy predictions for different companies. The data available at this
    link was collected from the **Emerging Markets Information Services** (**EMIS**).
    The EMIS database has information about the emerging markets in the world.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: EMIS analyzed bankrupt companies for the period 2000-2012 and operating companies
    for the period 2007-2013\. After the data was collected, five classifications
    were made based on the forecasting period. The first year class is the data that
    contains the financial rates from the year of the forecasting period. Another
    class label shows what the bankruptcy status would be after 5 years.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the data
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to use an open source program for data conversion, followed by
    another program to train a model from the data downloaded:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: We begin by obtaining the data that has been downloaded from a new data source.
    However, it is downloaded via a browser, and not via a data feed. Files ending
    with `.arff` will be obtained from data.world. The URL for this is [https://data.world/uci/polish-companies-bankruptcy-data](https://data.world/uci/polish-companies-bankruptcy-data).
    Usually, we can use 1-year bankruptcy data as the model predicts bankruptcy within
    1 year. For the sake of our example, we will use a dataset containing 5 years'
    worth of data.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then preprocess the data, as well as performing feature engineering
    by extraction, transformation, and loading. In this case, the file that will be
    downloaded from data.world is in `.arff` file format, which can't be read easily
    by Python. The code that can be used to convert the file type can be found on
    GitHub ([https://github.com/jeffreynghm/AIFinance_Packt](https://github.com/jeffreynghm/AIFinance_Packt)).
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building the model
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we will try out three types of models: logistic regression,
    decision tree, and neural network.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Before the computing power becomes readily available, it is quite common to
    choose the model according to the problem we are trying to solve, as well as what
    answers we need from the machine. However, nowadays, we tend to try out all possible
    models and pick the best model that delivers the best performance.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we can label it as something we want to predict. The target behavior
    that we wish to predict is the company default—this is called a target variable
    in the machine learning world. We will establish how accurate the model is at
    predicting the target variable when given the input data by deploying common metrics
    to compare performance across different models.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will need the following libraries:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '`os`: For file path manipulation.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`re`: Regular expression for matching column headers.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pandas`: DataFrame to keep the data.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matplotlib.pyplot`: For plotting the model''s result to showcase its accuracy.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`seaborn`: A beautiful visualization tool for data analysis.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sklearn`: A machine learning library, including very strong data preparation
    for splitting, training, and testing sets, rescaling the data values to feed to
    the neural network, handling missing values or value abnormality, and so on.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pickle`: The file format that''s used to save the model generated from the
    machine learning process.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`graphviz`: Used to visualize the decision tree.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Import all the relevant libraries using the following code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For logistic regression, when it comes to deciding which features are to be
    chosen, we will rely on testing the accuracy of different features. The combination
    that delivers the highest accuracy will be chosen.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `optimize_RFE()` function, which will perform the feature selection
    process. This function will try out different combinations of features that give
    the highest true positive and the lowest possible false positive. We will measure
    the performance in order to decide on the number of features that generate the
    best performance. The following is the code for the function definitions:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Besides a logic regression model, we will also build a decision tree. Feature
    selection will be performed by the algorithm at the time of training. Therefore,
    unlike the logistic regression model, we do not need to limit the number of features
    that are provided as input to the training process:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Lastly, we will add a neural network into the mix of models. It is similar
    to the decision tree. Feature selection will be performed by the algorithm at
    training time. However, it is important to perform a grid search for hyperparameter
    tuning. The hyperparameters that we are searching for belong to the neural network
    architecture; that is, how many layers we need to build to deliver the maximum
    performance. The following code is used to train the logistic regression model:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For all the models listed in this chapter, we also need to measure the accuracy.
    We are going to use two different approaches to measure accuracy. Various metrics
    are used in this classification problem. However, we need to be certain when it
    comes to building a machine learning model that classifies a company as default
    or non-default.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining these functions, we use the following code sample to actually
    call the function. All three models are built one by one. The results are stored
    in `f1_list` so that they can be printed out later:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Visualize the performance of each model using the following code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Use the following code sample to visualize the model:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the next section, we will use reinforcement learning to decide whether the
    loan to the customer shall be funded or not.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Funding a loan using reinforcement learning
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assuming that our role is the head of the bank, it becomes important to figure
    out the cost of funding the loan. The problem we are solving is comprised of three
    parties (or as we call them, **agents**)—the bank, depositors, and borrowers.
    To begin with, we assume that there is only one bank but many depositors and borrowers.
    The depositors and borrowers will be created through randomized generated data.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to simulating different behaviors for these parties in machine
    learning, each of these is called an agent or an instance of an object. We need
    to create thousands of agents, with some being depositors, some being borrowers,
    one being a bank, and one being a market. These represent the collective behavior
    of competing banks. Next, we will describe the behavior of each type of agent.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we assume the role of treasurer of the bank or head of the treasury.
    The job of the head of the treasury is to quote the risk-free funding cost. The
    banker dealing with the customer will take the cost of funding and add the credit
    risk premium to make up the total cost of financing. Any extra margin higher than
    this total cost of financing shall be the net contribution of the banker. But
    when it comes to reporting on financial statements, actual interest income from
    the client will net off the net interest cost paid to by depositor or borrower
    to the bank.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: What we want to produce is loan and deposit pricings for each maturity (1 day,
    2 days, and so on) before the bank opens for business. There is no such dataset
    in the public domain. Therefore, we will simulate the data. Maturity, amount of
    loan or deposit, starting date, and interest rate will all be simulated.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the stakeholders
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While defining the solution using AI modeling, we usually simulate the behavior
    of the entities involved. It becomes critical for us to understand the behavior
    of stakeholders first. For the sake of this example, we must understand the behavioral
    aspects of three entities – the bank, the depositor, and the borrower.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'A bank has two objectives:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Generate the pricing grid for the deposit and the loan.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate its profit/loss, as well as its self-funding status at any point in
    time.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pricing grid for the deposit and the loan is assumed to be priced at a different
    maturity.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: In this example, reinforcement learning has been introduced to update the pricing,
    as well as to take on feedback by considering the impact of recent actions on
    the profit and loss and asset and liability ratios. Depositors are assumed to
    have varying expectations for the deposit interest as and when the deposit matures.
    At the end of the day, we assume the depositor is claiming their own interest
    income, along with the amount of deposit reported in the bank's account.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: During the day before the market opens and on the maturity date of the deposit,
    the depositor will consider whether they want to stay or withdraw the deposit.
    At this point, we simulate the decision by randomizing the decision by generating
    a % chance of expected interest. There is a 50% chance of expectation for interest
    increasing and a 50% demand for the interest reducing. This expectation will then
    be compared against the bank's offer rate at that specific maturity. If the bank
    meets this expectation, then the deposit will stay; otherwise, the deposit will
    leave the bank for the same maturity period.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'With regard to how the interest rate expectation changes, there are two variations
    used for depositors: one is completely linear, while the other follows a normal
    distribution. If the deposit leaves the bank, we assume that the same amount of
    deposit will be placed in another bank. So, on the maturity date of the deposit
    in the other bank, the depositors will set their expectations and evaluate whether
    to stay or go back to the original bank.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: For the borrower, the behavior is assumed to be the same as the depositors',
    with the same day-end accrual activities. However, during the day, borrowers whose
    loans mature on the same day will reconsider their intention to stay or not. This
    is represented by the interest rate expectation and the exact method of simulation
    is the same as depositors'—but with the difference that the loan offered by the
    bank has to be lower than the expected pricing of the borrowers for it to stay
    for refinancing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Arriving at the solution
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps for creating the borrowers and depositors to close
    the bank''s book on a daily basis:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the data from the list of loans and deposits to generate
    a list of borrowers and depositors. In this step, scenarios are loaded from a
    spreadsheet to simulate the borrowers and depositors that come in on different
    days. The following code sample shows the function definition for generating the
    list of borrowers and depositors:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At the beginning of each iteration (except the first day of business), the
    market pricing is provided and the bank needs to provide pricing as well. We generate
    a fixed amount of simulation (1,000 times). In each simulation, we assume a period
    of 10 years (3,650 days = 365days/year x 10 years). On any given day, depositors
    and borrowers set their expectations by referencing the market rate. When we begin
    the first day of each simulation, depositors and borrowers are created from the
    list of deposits and loans. The following code runs 1,000 simulations:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Executing the preceding code will create an object of the bank. At that time,
    two neural networks are initialized inside the bank – one for the deposit pricing
    and one for the loan pricing. The same thing is done for the bank called **market**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Market pricing is randomized based on the initial pricing input into the market
    by Monte Carlo simulation. Based on the market pricing, borrowers and depositors
    set their expectations by referencing the market pricing, along with the tendency
    to attribute. After setting their expectations, two variations of the deposit
    pricing and loan pricing grids are generated.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Deposit pricing and loan pricing are generated by two neural networks and Monte
    Carlo simulations. The neural network dictates the required grid movement for
    the loan and deposit pricing grids. However, the `bank` object also generates
    randomized pricing based on the pricing generated by the neural network. The following
    code is used to build the model:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this, the environment has been created. Here, the environment object contains
    the neural network model that provides the reward estimation for the given pricing
    grids (loan and deposit), as well as external environments such as market pricing,
    maturing borrowers, and depositors.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a pricing grid for the day:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The pricing model of the bank is based on the machine learning model. The market
    is based on the randomized process referencing the initial values we hardcoded. At
    the same time, the maturity profile (loan and deposit maturing today) will be
    calculated and the customers' expectation for pricing is established. This expectation
    is based on market pricing and the internal demand randomized by the helper function
    defined.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate the list of possible pricings, predict the reward, and pick the best
    pricing. This step is called **action** in the reinforcement learning domain.
    Action is the act of quoting prices to customers and market peers. Based on the
    pricing generated in the previous step, we create a lot more variations (20, in
    our case) with a randomized process:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using the environment object's machine learning model, we can predict the outcome
    of each of the variations and choose the best variation to maximize the profitability,
    satisfying the funding requirements with the deposit.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the pricing grid. Income and expenses are generated based on the chosen
    pricing grid that generates the maximum estimated net profit while meeting the
    self-funding balance objective. Once the bank''s pricing grid has been chosen,
    it is executed with the maturing borrowers and depositors. Some will stay and
    some will leave the bank:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At the end of the day, interest will be accrued for those who stay with the
    bank and will be updated in the bank's accounting book (variables in the `bank`
    object). The daily position is also output to the log file.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The winning combination will be fed to the model for further reinforcement learning
    both for the bank and the environment. The feedback will contain the actual P&L
    for the bank for both deposit and loan grid pricing; for the environment, the
    actual profitability and self-funding status will be fed back to the reward model.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The actual P&L and self-funding statuses are provided as feedback to the `environment`
    object and `bank` object in order to predict the reward and pricing more accurately.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'After each simulation, the results are saved in an output file and we get to
    monitor the progress of reinforcement learning. At the end of each simulation,
    the last day''s snapshot result is output. Use the following code to generate
    the output:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each bar on the *x* axis represents the average P&L of 10 simulations. The P&L
    of the simulation peaked at the eighth bar. By performing a detailed analysis
    of each simulation result in the log file, we can see that the improvement of
    P&L stopped at the eighty-seventh simulation since P&L plateaued and stabilized
    at the eightieth plus simulation. With further training, the P&L dropped, thus
    showing signs of over-training.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about different AI modeling techniques through two
    examples—the first with regard to predicting the chances of the borrower going
    bankrupt and the other with regard to figuring out the funding for the loan. We
    also learned about reinforcement learning in this chapter. Other artificial intelligence
    techniques, including deep learning, neural networks, the logistic regression
    model, decision trees, and Monte Carlo simulation were also covered. We also learned
    about the business functions of the bank in the context of the examples provided
    in this chapter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to learn about more AI modeling techniques.
    We will learn about the linear optimization and linear regression models and use
    them to solve problems regarding investment banking. We will also learn how AI
    techniques can become instrumental in mechanizing capital market decisions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
